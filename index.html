<!DOCTYPE html>
<!--
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë VIDIST - Precision Creative Engine                                       ‚ïë
‚ïë üìç Version: See js/version.js (SINGLE SOURCE OF TRUTH)                   ‚ïë
‚ïë ‚ö†Ô∏è NEVER hardcode version numbers - ALWAYS load from js/version.js       ‚ïë
‚ïë AI-Powered Prompt & Video Crafting Platform                              ‚ïë
‚ïë By: iarcanar                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

VERSION HISTORY & UPDATE GUIDELINES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Version Numbering Scheme:
  - Major.Minor format (e.g., v1.5, v2.0)
  - Major version: Significant feature additions or architectural changes
  - Minor version: Feature enhancements, bug fixes, UI improvements
  - Build date: MMDDYYYY format (e.g., 12212025 = December 21, 2025)

Update Policy:
  ‚úÖ MUST update version on:
     - New major features (Red Mode Toggle, new AI models, etc.)
     - Breaking changes or architectural refactors
     - Significant UI/UX redesigns
     - Security fixes or critical bug fixes

  üìù SHOULD update version on:
     - Minor feature additions
     - Performance improvements
     - CSS/styling updates
     - Documentation updates

  ‚ùå DO NOT update version for:
     - Comment changes only
     - Code formatting/linting
     - Minor text changes

Current Release (v1.6 - 12/21/2025):
  üîß Scalability Improvements - Easy model addition (config-driven)
  üìã Dynamic Model Dropdown - Auto-generated from MODEL_CONFIG
  ‚öôÔ∏è Unified API Function - Merged duplicate code, simplified logic
  üéØ Config-Driven Architecture - Add new models by editing config.js only

Previous Releases:
  v1.5 - WAN 2.5 Extend + Optimized UI Layout + Negative Prompt improvements
  v1.4 (WIP) - WAN 2.5 Extend initial implementation
  v1.3 - Layout optimizations and UI improvements
  v1.2 - Red Mode Toggle with Creative Mode system prompts
  v1.1 - Prompt Craft feature with Gemini 2.0 Flash integration
  v1.0 - Initial release with Wavespeed API integration
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-->
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <!-- Mobile optimizations -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <title>VIDIST - Precision Creative Engine</title>
    <link rel="icon" type="image/x-icon" href="assets/VIDIST_ICO.ico?v=2">
    <link rel="shortcut icon" type="image/x-icon" href="assets/VIDIST_ICO.ico?v=2">
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/mobile.css">
</head>

<body class="cyber-grid">
    <!-- Header -->
    <header class="relative z-10 border-b border-purple-500/20">
        <div class="max-w-7xl mx-auto px-4 py-3 sm:py-4">
            <!-- Single row horizontal layout on all screens -->
            <div class="flex flex-row items-center justify-between gap-3 sm:gap-6">

                <!-- Left: Logo + Name + Version -->
                <div class="flex items-center gap-3 sm:gap-4 justify-start">
                    <!-- Logo (32px mobile, 48px desktop) -->
                    <div class="w-8 h-8 sm:w-12 sm:h-12 rounded-lg overflow-hidden neon-border pulse-glow"
                        style="box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);">
                        <img src="assets/VIDIST_LOGO.png" alt="VIDIST Logo" class="w-full h-full object-cover">
                    </div>

                    <!-- Name + Version Section -->
                    <div class="text-left">
                        <!-- Title: VIDIST (version loaded from js/version.js) -->
                        <h1 class="text-lg sm:text-3xl font-bold glitch neon-text inline-flex items-baseline gap-1.5 sm:gap-2" data-text="VIDIST">
                            <span>VIDIST<span class="mobile-only"> - mobile</span></span>
                            <span class="text-xs sm:text-base font-light text-purple-400" id="version-display">...</span>
                        </h1>

                        <!-- Subtitle: PRECISION CREATIVE ENGINE (build loaded from js/version.js) -->
                        <p class="text-[9px] sm:text-xs text-cyan-400 neon-text-cyan tracking-wider mt-0.5">
                            PRECISION CREATIVE ENGINE
                            <span class="hidden sm:inline text-[10px] text-gray-500 ml-2" id="build-display">...</span>
                        </p>
                    </div>
                </div>

                <!-- Right: Compact Balance + Top Up Button -->
                <a href="https://wavespeed.ai/top-up" target="_blank"
                   class="balance-topup-button w-[75px] sm:w-auto sm:min-w-[120px] px-2 py-1.5 sm:px-4 sm:py-2.5 rounded-lg sm:rounded-xl
                          bg-gradient-to-r from-cyan-600 to-cyan-700 hover:from-cyan-500 hover:to-cyan-600
                          border-2 border-cyan-400/50 hover:border-cyan-300
                          transition-all duration-200 transform hover:scale-105
                          shadow-lg hover:shadow-cyan-500/50
                          flex flex-col items-center justify-center gap-0.5
                          cursor-pointer touch-target flex-shrink-0">

                    <!-- Balance Amount -->
                    <span class="text-xs sm:text-xl font-bold text-white neon-text-cyan leading-none whitespace-nowrap" id="credit_balance">
                        $-.---
                    </span>

                    <!-- TOP UP Label -->
                    <span class="text-[7px] sm:text-[10px] text-cyan-100 font-semibold uppercase tracking-wider whitespace-nowrap">
                        TOP UP
                    </span>
                </a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 py-8 relative z-10">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Column: Video Creation -->
            <div class="lg:col-span-2 space-y-6">
                <!-- API Key Section (Collapsible) -->
                <div class="cyber-card rounded-2xl overflow-hidden">
                    <button id="toggle-api-key"
                        class="w-full px-6 py-4 flex items-center justify-between hover:bg-purple-500/5 transition-all">
                        <div class="flex items-center gap-3">
                            <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z">
                                </path>
                            </svg>
                            <span class="font-semibold text-purple-400 uppercase tracking-wide">API Configuration</span>
                        </div>
                        <svg id="api-key-chevron" class="w-5 h-5 text-gray-400 transition-transform" fill="none"
                            stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7">
                            </path>
                        </svg>
                    </button>
                    <div id="api-key-section" class="hidden px-6 pb-6 space-y-4">
                        <!-- Wavespeed API Key -->
                        <div>
                            <div class="flex items-center justify-between mb-2">
                                <label
                                    class="block text-sm font-semibold text-gray-400 uppercase tracking-wide">Wavespeed
                                    API Key</label>
                                <label class="api-toggle-container">
                                    <input type="checkbox" id="toggle-wavespeed-api" class="api-toggle-checkbox"
                                        checked>
                                    <span class="api-toggle-slider"></span>
                                    <span class="text-xs text-gray-500 ml-2">Enabled</span>
                                </label>
                            </div>
                            <div class="flex gap-2">
                                <input type="password" id="api-key-wavespeed" placeholder="Enter your Wavespeed API Key"
                                    class="flex-1 px-4 py-3 rounded-xl focus:ring-2 focus:ring-cyan-500/50 font-mono text-sm"
                                    value="">
                                <button id="save-wavespeed-key"
                                    class="px-4 py-3 rounded-xl bg-cyan-600 hover:bg-cyan-700 text-white font-semibold text-sm transition-all flex items-center gap-2 whitespace-nowrap">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                    <span>Save</span>
                                </button>
                            </div>
                            <p class="mt-1 text-xs text-gray-500">Used for Wavespeed Wan 2.5 model.</p>
                        </div>

                        <!-- Gemini API Key (for Prompt Craft) -->
                        <div>
                            <div class="flex items-center justify-between mb-2">
                                <label class="block text-sm font-semibold text-gray-400 uppercase tracking-wide">Gemini
                                    API Key (Prompt Craft)</label>
                                <label class="api-toggle-container">
                                    <input type="checkbox" id="toggle-gemini-api" class="api-toggle-checkbox" checked>
                                    <span class="api-toggle-slider"></span>
                                    <span class="text-xs text-gray-500 ml-2">Enabled</span>
                                </label>
                            </div>
                            <div class="flex gap-2">
                                <input type="password" id="api-key-gemini" placeholder="Enter your Gemini API Key"
                                    class="flex-1 px-4 py-3 rounded-xl focus:ring-2 focus:ring-purple-500/50 font-mono text-sm"
                                    value="">
                                <button id="save-gemini-key"
                                    class="px-4 py-3 rounded-xl bg-purple-600 hover:bg-purple-700 text-white font-semibold text-sm transition-all flex items-center gap-2 whitespace-nowrap">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                    <span>Save</span>
                                </button>
                            </div>
                            <p class="mt-1 text-xs text-gray-500">Used for AI-powered prompt generation. Get your key at
                                <a href="https://aistudio.google.com/app/apikey" target="_blank"
                                    class="text-purple-400 hover:text-purple-300 underline">Google AI Studio</a>
                            </p>
                        </div>

                        <!-- Grok API Key (x.ai) -->
                        <div>
                            <div class="flex items-center justify-between mb-2">
                                <label class="block text-sm font-semibold text-gray-400 uppercase tracking-wide">Grok API Key (x.ai)</label>
                            </div>
                            <div class="flex gap-2">
                                <input type="password" id="api-key-grok" placeholder="Enter your Grok API Key (xai-...)"
                                    class="flex-1 px-4 py-3 rounded-xl focus:ring-2 focus:ring-green-500/50 font-mono text-sm"
                                    value="">
                                <button id="save-grok-key"
                                    class="px-4 py-3 rounded-xl bg-green-600 hover:bg-green-700 text-white font-semibold text-sm transition-all flex items-center gap-2 whitespace-nowrap">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                    <span>Save</span>
                                </button>
                            </div>
                            <p class="mt-1 text-xs text-gray-500">Used for Grok Imagine Video & Image. Get your key at
                                <a href="https://console.x.ai/" target="_blank"
                                    class="text-green-400 hover:text-green-300 underline">xAI Console</a>
                            </p>
                        </div>

                        <!-- imgbb API Key (for Grok video generation) -->
                        <div>
                            <div class="flex items-center justify-between mb-2">
                                <label class="block text-sm font-semibold text-gray-400 uppercase tracking-wide">imgbb API Key</label>
                            </div>
                            <div class="flex gap-2">
                                <input type="password" id="api-key-imgbb" placeholder="Enter your imgbb API Key"
                                    class="flex-1 px-4 py-3 rounded-xl focus:ring-2 focus:ring-blue-500/50 font-mono text-sm"
                                    value="">
                                <button id="save-imgbb-key"
                                    class="px-4 py-3 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-semibold text-sm transition-all flex items-center gap-2 whitespace-nowrap">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                    <span>Save</span>
                                </button>
                            </div>
                            <p class="mt-1 text-xs text-gray-500">Required for Grok video generation (image hosting). Get your key at
                                <a href="https://api.imgbb.com/" target="_blank"
                                    class="text-blue-400 hover:text-blue-300 underline">imgbb API</a>
                            </p>
                        </div>

                        <div class="mt-3 p-3 rounded-lg bg-gray-800/50 border border-gray-700">
                            <p class="text-xs text-gray-400 flex items-start gap-2">
                                <svg class="w-4 h-4 text-cyan-400 flex-shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <span>Your API keys are stored locally in your browser and will persist across sessions until manually deleted. Click <strong>Save</strong> to confirm storage.</span>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Video Generation Form -->
                <div class="cyber-card rounded-2xl p-6">
                    <h2 class="text-2xl font-bold mb-6 neon-text-cyan flex items-center gap-3">
                        <div
                            class="w-8 h-8 bg-cyan-500/20 rounded-lg flex items-center justify-center neon-border-cyan">
                            <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z">
                                </path>
                            </svg>
                        </div>
                        CREATE NEW VIDEO
                    </h2>
                    <!-- AI Model Selection (Custom Dropdown with Icons) -->
                    <div class="mb-6">
                        <label class="block text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wide">AI
                            Model</label>
                        <!-- Hidden select for form compatibility -->
                        <select id="model-select" class="hidden">
                            <!-- Options populated dynamically from MODEL_CONFIG -->
                        </select>
                        <!-- Custom Dropdown -->
                        <div id="model-dropdown" class="relative">
                            <button type="button" id="model-dropdown-btn"
                                class="w-full px-4 py-3 rounded-xl font-semibold bg-gray-900/50 border border-gray-700/50 hover:border-cyan-500/50 focus:ring-2 focus:ring-cyan-500/50 text-left flex items-center justify-between transition-all">
                                <div class="flex items-center gap-2">
                                    <img id="model-selected-icon" src="assets/wan.png" alt="" class="w-5 h-5">
                                    <span id="model-selected-text" class="text-gray-200">Wan 2.5 I2V</span>
                                </div>
                                <svg class="w-5 h-5 text-gray-400 transition-transform" id="model-dropdown-chevron"
                                    fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            <div id="model-dropdown-list"
                                class="hidden absolute z-50 w-full mt-1 bg-gray-900 border border-gray-700/50 rounded-xl overflow-hidden shadow-lg shadow-black/50">
                                <!-- Options populated by JS -->
                            </div>
                        </div>
                    </div>

                    <!-- ========== KEEP: Prompt Collection (Collapsible) ========== -->
                    <div class="cyber-card rounded-xl overflow-hidden mb-6 border border-pink-500/20">
                        <button id="toggle-keep-section"
                            class="w-full px-4 py-3 flex items-center justify-between hover:bg-pink-500/5 transition-all">
                            <div class="flex items-center gap-3">
                                <svg class="w-5 h-5 text-pink-400" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z">
                                    </path>
                                </svg>
                                <span class="font-semibold text-pink-400 uppercase tracking-wide text-sm">Keep</span>
                                <span id="keep-count" class="text-xs text-gray-500">(0)</span>
                            </div>
                            <svg id="keep-chevron" class="w-5 h-5 text-gray-400 transition-transform" fill="none"
                                stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M19 9l-7 7-7-7">
                                </path>
                            </svg>
                        </button>
                        <div id="keep-section" class="hidden px-4 pb-4">
                            <!-- Add new prompt input -->
                            <div class="mb-3">
                                <textarea id="keep-new-prompt" placeholder="‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å prompt ‡∏ó‡∏µ‡πà‡∏ä‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."
                                    class="w-full px-3 py-2 rounded-lg text-sm resize-none h-16 bg-gray-900/50 border border-gray-700/50 focus:border-pink-500/50 focus:ring-1 focus:ring-pink-500/30 text-gray-300 placeholder-gray-500"></textarea>
                                <button id="keep-add-btn"
                                    class="mt-2 px-3 py-1.5 text-xs rounded-lg bg-pink-500/20 text-pink-400 hover:bg-pink-500/30 border border-pink-500/30 transition-all">
                                    + Add to Keep
                                </button>
                            </div>
                            <!-- Keep list (3-column grid) -->
                            <div id="keep-list"
                                class="grid grid-cols-3 gap-2 max-h-[300px] overflow-y-auto custom-scrollbar">
                                <!-- Cards rendered by JS -->
                            </div>
                        </div>
                    </div>

                    <!-- ========== NEW: Horizontal Layout - Image Upload + Prompt Craft ========== -->
                    <div class="mb-6 flex gap-4">

                        <!-- LEFT: Image Upload Section (for I2V & Prompt Craft) -->
                        <div id="image-upload-section-left" class="flex-shrink-0" style="width: 280px;">
                            <!-- Image Preview -->
                            <div id="image-preview-container-left" class="hidden">
                                <div class="inline-block relative group cursor-pointer" id="preview-wrapper-left">
                                    <img id="image-preview-left"
                                        class="w-full h-auto rounded-xl border-2 border-cyan-500/30 neon-border-cyan"
                                        src="#" style="object-fit: contain; max-height: 400px;">

                                    <!-- Delete Icon (Top-Right) -->
                                    <button type="button" id="delete-image-btn-left"
                                        class="absolute top-2 right-2 w-8 h-8 bg-gradient-to-br from-red-500/90 to-pink-600/90 hover:from-red-400 hover:to-pink-500 border border-red-400/50 hover:border-pink-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-red-500/50"
                                        style="backdrop-filter: blur(10px);">
                                        <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]"
                                            fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"
                                                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                                            </path>
                                        </svg>
                                    </button>

                                    <!-- Drag-Drop Overlay -->
                                    <div id="preview-drag-overlay-left"
                                        class="absolute inset-0 bg-cyan-500/20 border-2 border-dashed border-cyan-400 flex items-center justify-center opacity-0 transition-opacity rounded-xl pointer-events-none z-10">
                                        <div class="text-center">
                                            <svg class="w-10 h-10 mx-auto text-cyan-400 mb-2" fill="none"
                                                stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12">
                                                </path>
                                            </svg>
                                            <span class="text-cyan-300 text-xs font-semibold">Drop to Replace</span>
                                        </div>
                                    </div>

                                    <!-- Click to Enlarge Overlay -->
                                    <div
                                        class="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity rounded-xl pointer-events-none z-5">
                                        <span class="text-white text-xs font-medium">Click to enlarge</span>
                                    </div>

                                    <!-- Image Edit Processing Overlay (Hologram Effect) -->
                                    <div id="image-edit-processing-overlay"
                                        class="hidden absolute inset-0 rounded-xl overflow-hidden z-30 pointer-events-none">
                                        <!-- Hologram Effect -->
                                        <div class="absolute inset-0 hologram-overlay rounded-xl"></div>

                                        <!-- Status Text (No Spinner - Simplified) -->
                                        <div class="absolute inset-0 flex items-center justify-center">
                                            <p id="image-edit-status-text"
                                                class="text-cyan-400 text-sm font-semibold drop-shadow-[0_2px_8px_rgba(0,0,0,0.9)]">
                                                ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û...</p>
                                        </div>
                                    </div>

                                    <!-- ‚ú® NEW: Floating Processing Image (v2.8.2) -->
                                    <div id="floating-processing-container"
                                         class="hidden absolute pointer-events-none"
                                         style="z-index: 40;">

                                        <!-- Scaled image with hologram overlay -->
                                        <div class="relative">
                                            <img id="floating-processing-image"
                                                 class="rounded-xl border-2 border-cyan-500/50"
                                                 src="#"
                                                 style="object-fit: contain;">

                                            <!-- Hologram overlay on floating image -->
                                            <div class="absolute inset-0 rounded-xl overflow-hidden">
                                                <div class="absolute inset-0 hologram-overlay rounded-xl"></div>

                                                <!-- Progress text -->
                                                <div class="absolute inset-0 flex items-center justify-center">
                                                    <p id="floating-status-text"
                                                       class="text-cyan-400 text-sm font-semibold drop-shadow-[0_2px_8px_rgba(0,0,0,0.9)]">
                                                        processing... 0%
                                                    </p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- ‚ú® NEW: Dim overlay for base image (v2.8.2) -->
                                    <div id="base-image-dim"
                                         class="hidden absolute inset-0 bg-black/40 rounded-xl pointer-events-none"
                                         style="z-index: 25;"></div>
                                </div>
                            </div>

                            <!-- Image Edit Controls (Wan 2.6) -->
                            <div id="image-edit-controls" class="hidden mt-4 space-y-2">
                                <!-- Model Selector -->
                                <div class="mb-2">
                                    <label class="block text-xs font-semibold text-gray-400 mb-1.5 uppercase tracking-wide">
                                        Editing Model
                                    </label>
                                    <select id="image-edit-model-select"
                                            class="w-full px-3 py-2 rounded-lg bg-gray-900/50 border border-gray-700/50
                                                   hover:border-pink-500/50 focus:ring-2 focus:ring-pink-500/50 focus:outline-none
                                                   text-sm text-gray-200 font-medium transition-all">
                                        <option value="gemini-25-flash-image" selected>
                                            Gemini 2.5 Flash - $0.039 per edit
                                        </option>
                                        <option value="ws-wan-26-image-edit">
                                            WAN 2.6 - $0.035 per edit
                                        </option>
                                    </select>
                                </div>

                                <!-- Edit Button -->
                                <button id="edit-image-btn"
                                    class="w-full px-4 py-2.5 rounded-lg bg-gradient-to-r from-pink-500/20 to-purple-500/20
                                           text-pink-400 font-semibold hover:from-pink-500/30 hover:to-purple-500/30
                                           transition-all border border-pink-500/30 flex items-center justify-center gap-2">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                    </svg>
                                    <span id="edit-btn-text">Edit Image</span>
                                </button>

                                <!-- Auto-save Toggle -->
                                <div class="flex items-center justify-between px-3 py-2 rounded-lg bg-gray-800/50 border border-gray-700/50">
                                    <span class="text-xs text-gray-400 flex items-center gap-1.5">
                                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                                        </svg>
                                        Auto-save
                                    </span>
                                    <label class="relative inline-flex items-center cursor-pointer">
                                        <input type="checkbox" id="auto-save-toggle" class="sr-only peer" checked>
                                        <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-pink-500"></div>
                                    </label>
                                </div>

                                <!-- Undo/Redo Navigation (shown after edit) -->
                                <div id="edit-history-nav"
                                    class="hidden w-full flex items-center justify-center gap-2 px-4 py-2 rounded-lg bg-gray-700/20 border border-gray-600/30">
                                    <button id="history-prev-btn"
                                        class="w-8 h-8 flex items-center justify-center rounded-lg bg-gray-700/30 text-gray-300 hover:bg-gray-700/50 hover:text-pink-400 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
                                        title="Previous image">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M15 19l-7-7 7-7" />
                                        </svg>
                                    </button>
                                    <span id="history-status"
                                        class="text-xs text-pink-400 font-semibold min-w-[80px] text-center">Edited</span>
                                    <button id="history-next-btn"
                                        class="w-8 h-8 flex items-center justify-center rounded-lg bg-gray-700/30 text-gray-300 hover:bg-gray-700/50 hover:text-pink-400 transition-all disabled:opacity-30 disabled:cursor-not-allowed"
                                        title="Next image">
                                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M9 5l7 7-7 7" />
                                        </svg>
                                    </button>
                                </div>
                            </div>

                            <!-- Drag & Drop Area -->
                            <div id="drag-drop-area-left"
                                class="border-2 border-dashed border-cyan-500/50 rounded-xl p-6 text-center cursor-pointer hover:border-cyan-400 hover:bg-cyan-500/10 transition-all">
                                <svg class="w-10 h-10 mx-auto text-gray-500 mb-2" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                                    </path>
                                </svg>
                                <p class="text-gray-400 text-xs mb-1">Drag & Drop</p>
                                <p class="text-[10px] text-gray-600">JPG, PNG, WEBP</p>
                                <p class="text-[10px] text-gray-600">Max 25MB</p>
                                <input type="file" id="file-input-left" class="hidden"
                                    accept="image/jpeg,image/png,image/webp">
                                <button type="button" id="browse-button-left"
                                    class="mt-2 text-[10px] text-cyan-400 hover:text-cyan-300 underline">Browse
                                    File</button>
                            </div>

                            <!-- Image URL Input (Below drag & drop) -->
                            <!-- üöß TEMPORARILY HIDDEN: URL input not working due to CORS - See DEVELOPMENT.md -->
                            <div class="mt-3 hidden">
                                <input type="url" id="image-url-left" placeholder="Or paste image URL..."
                                    class="w-full px-3 py-2 rounded-lg text-xs bg-gray-900/50 border border-gray-700 text-white focus:border-cyan-500 focus:outline-none focus:ring-1 focus:ring-cyan-500/50">
                            </div>
                        </div>

                        <!-- RIGHT: Prompt Craft Section -->
                        <div class="flex-1">
                            <div class="p-4 rounded-xl border border-purple-500/30 bg-purple-500/5 h-full">
                                <div class="flex items-center gap-2 mb-3">
                                    <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor"
                                        viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z">
                                        </path>
                                    </svg>
                                    <span class="text-sm font-semibold text-purple-400 uppercase tracking-wide">Prompt
                                        Craft</span>
                                    <span
                                        class="text-[10px] bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded border border-purple-500/30">AI
                                        Powered</span>

                                    <!-- Red Mode Toggle (Hidden, Desktop-Friendly) -->
                                    <div id="red-mode-toggle-container" class="red-mode-toggle-container ml-auto"
                                        title="Red Mode Toggle: Swipe up for NSFW mode">
                                        <div class="red-mode-toggle-track">
                                            <div class="red-mode-toggle-thumb"></div>
                                            <div class="red-mode-toggle-glow"></div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Intensity Level Selector (Red Mode Only) -->
                                <div id="intensity-level-selector" class="hidden mb-2">
                                    <div class="grid grid-cols-5 gap-1">
                                        <!-- Level 1 -->
                                        <label class="intensity-btn cursor-pointer group">
                                            <input type="radio" name="intensity-level" value="1"
                                                class="hidden intensity-radio">
                                            <div
                                                class="intensity-label flex flex-col items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <svg class="w-3 h-3 text-purple-300/60 group-hover:text-purple-300/80 transition-colors"
                                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                    stroke-width="1.5">
                                                    <circle cx="12" cy="12" r="9" />
                                                </svg>
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">I</span>
                                            </div>
                                        </label>

                                        <!-- Level 2 -->
                                        <label class="intensity-btn cursor-pointer group">
                                            <input type="radio" name="intensity-level" value="2"
                                                class="hidden intensity-radio">
                                            <div
                                                class="intensity-label flex flex-col items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <svg class="w-3 h-3 text-purple-300/60 group-hover:text-purple-300/80 transition-colors"
                                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                    stroke-width="1.5">
                                                    <path
                                                        d="M12 2.5 C12 2.5, 8.5 6, 8.5 10 C8.5 13.5, 10 15.5, 12 15.5 C14 15.5, 15.5 13.5, 15.5 10 C15.5 6, 12 2.5, 12 2.5 Z"
                                                        stroke-linecap="round" stroke-linejoin="round" />
                                                    <path d="M12 15.5 L12 21.5" stroke-linecap="round" />
                                                </svg>
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">II</span>
                                            </div>
                                        </label>

                                        <!-- Level 3 (Default) -->
                                        <label class="intensity-btn cursor-pointer group">
                                            <input type="radio" name="intensity-level" value="3"
                                                class="hidden intensity-radio" checked>
                                            <div
                                                class="intensity-label flex flex-col items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <svg class="w-3 h-3 text-purple-300/60 group-hover:text-purple-300/80 transition-colors"
                                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                    stroke-width="1.5">
                                                    <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z" stroke-linecap="round"
                                                        stroke-linejoin="round" />
                                                </svg>
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">III</span>
                                            </div>
                                        </label>

                                        <!-- Level 4: Grok (Safe Words) -->
                                        <label class="intensity-btn cursor-pointer group">
                                            <input type="radio" name="intensity-level" value="4"
                                                class="hidden intensity-radio">
                                            <div
                                                class="intensity-label flex flex-col items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <svg class="w-3 h-3 text-purple-300/60 group-hover:text-purple-300/80 transition-colors"
                                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                    stroke-width="1.5">
                                                    <path
                                                        d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
                                                        stroke-linecap="round" stroke-linejoin="round" />
                                                </svg>
                                                <span
                                                    class="text-[10px] font-extralight text-purple-300/70 tracking-wide group-hover:text-purple-300/90 transition-colors">grok</span>
                                            </div>
                                        </label>

                                        <!-- Level 5: IMG (Image Edit Mode) -->
                                        <label class="intensity-btn cursor-pointer group">
                                            <input type="radio" name="intensity-level" value="img"
                                                class="hidden intensity-radio">
                                            <div
                                                class="intensity-label flex flex-col items-center justify-center py-1 px-1 rounded border border-pink-500/20 bg-pink-500/5 transition-all hover:border-pink-400/40 hover:bg-pink-500/10">
                                                <svg class="w-3 h-3 text-pink-300/60 group-hover:text-pink-300/80 transition-colors"
                                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                                    stroke-width="1.5">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                                                </svg>
                                                <span
                                                    class="text-[10px] font-extralight text-pink-300/70 tracking-wide group-hover:text-pink-300/90 transition-colors">img</span>
                                            </div>
                                        </label>
                                    </div>
                                </div>

                                <!-- Language Selector (Show in both Creative & Red Mode) -->
                                <div id="language-selector" class="mb-2">
                                    <div class="grid grid-cols-3 gap-1">
                                        <!-- English -->
                                        <label class="language-btn cursor-pointer group">
                                            <input type="radio" name="prompt-language" value="en"
                                                class="hidden language-radio" checked>
                                            <div
                                                class="language-label flex items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">EN</span>
                                            </div>
                                        </label>

                                        <!-- Thai -->
                                        <label class="language-btn cursor-pointer group">
                                            <input type="radio" name="prompt-language" value="th"
                                                class="hidden language-radio">
                                            <div
                                                class="language-label flex items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">TH</span>
                                            </div>
                                        </label>

                                        <!-- Japanese -->
                                        <label class="language-btn cursor-pointer group">
                                            <input type="radio" name="prompt-language" value="ja"
                                                class="hidden language-radio">
                                            <div
                                                class="language-label flex items-center justify-center py-1 px-1 rounded border border-purple-500/20 bg-purple-500/5 transition-all hover:border-purple-400/40 hover:bg-purple-500/10">
                                                <span
                                                    class="text-xs font-extralight text-purple-300/70 tracking-wider group-hover:text-purple-300/90 transition-colors">JA</span>
                                            </div>
                                        </label>
                                    </div>
                                </div>

                                <!-- Step Complexity Selector (Red Mode Level 3 Only) -->
                                <div id="step-complexity-container" class="mb-3" style="display: none;">
                                    <!-- Card wrapper with slightly increased height -->
                                    <div class="cyber-card rounded-xl p-3">
                                        <div class="grid grid-cols-3 gap-2">
                                            <!-- Simple (6 steps) -->
                                            <button type="button" data-steps="6"
                                                class="step-complexity-btn flex items-center justify-center gap-1.5 py-2 px-3 rounded border border-pink-500/20 bg-pink-500/5 hover:bg-pink-500/10 transition-all cursor-pointer">
                                                <img src="assets/step_A.png" alt="Step A" class="w-5 h-5">
                                                <div class="text-xs font-light text-pink-300/70">6 Step</div>
                                            </button>

                                            <!-- Moderate (9 steps) -->
                                            <button type="button" data-steps="9"
                                                class="step-complexity-btn flex items-center justify-center gap-1.5 py-2 px-3 rounded border border-pink-500/20 bg-pink-500/5 hover:bg-pink-500/10 transition-all cursor-pointer">
                                                <img src="assets/step_B.png" alt="Step B" class="w-5 h-5">
                                                <div class="text-xs font-light text-pink-300/70">9 Step</div>
                                            </button>

                                            <!-- Detailed (12 steps) -->
                                            <button type="button" data-steps="12"
                                                class="step-complexity-btn flex items-center justify-center gap-1.5 py-2 px-3 rounded border border-pink-500/20 bg-pink-500/5 hover:bg-pink-500/10 transition-all cursor-pointer">
                                                <img src="assets/step_C.png" alt="Step C" class="w-5 h-5">
                                                <div class="text-xs font-light text-pink-300/70">12 Step</div>
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- MUTE Checkbox (Red Mode Only) -->
                                <div id="mute-audio-container" class="hidden mb-3">
                                    <label class="flex items-center gap-2 cursor-pointer group">
                                        <input type="checkbox" id="mute-audio-checkbox"
                                            class="w-4 h-4 rounded border-red-500/30 bg-red-500/5 text-red-500 focus:ring-2 focus:ring-red-500/50 transition-all">
                                        <span
                                            class="text-xs font-extralight text-red-300/70 tracking-widest group-hover:text-red-300/90 transition-colors">üîá
                                            MUTE</span>
                                        <span class="text-[10px] text-gray-500 ml-auto">
                                            (‡∏õ‡∏¥‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
                                        </span>
                                    </label>
                                </div>

                                <!-- Custom Speech Override (Red Mode Only) -->
                                <div id="custom-dialog-container" class="hidden mb-3">
                                    <label class="flex items-center gap-2 cursor-pointer group mb-2">
                                        <input type="checkbox" id="custom-dialog-checkbox"
                                            class="w-4 h-4 rounded border-purple-500/30 bg-purple-500/5 text-purple-500 focus:ring-2 focus:ring-purple-500/50 transition-all">
                                        <span
                                            class="text-xs font-extralight text-purple-300/70 tracking-widest group-hover:text-purple-300/90 transition-colors">‚óé
                                            SPEECH</span>
                                    </label>
                                    <div id="custom-dialog-input-container" class="hidden">
                                        <input type="text" id="custom-dialog-input" placeholder="Dialogs override..."
                                            class="w-full px-3 py-2 rounded-lg text-sm bg-gray-900/50 border border-purple-500/30 text-gray-200 placeholder-gray-500 focus:ring-2 focus:ring-purple-500/50 transition-all">
                                    </div>
                                </div>

                                <!-- Craft Input Textarea -->
                                <div>
                                    <textarea id="prompt-craft-input" rows="3"
                                        placeholder="Describe what you want to see in the video based on your image..."
                                        class="w-full px-4 py-3 rounded-xl font-semibold focus:ring-2 focus:ring-purple-500/50 text-sm bg-gray-900/50 border border-purple-500/30 text-gray-200 placeholder-gray-500 resize-y min-h-[90px]"></textarea>

                                    <!-- Buttons positioned below textarea -->
                                    <div class="flex gap-2 mt-2 justify-end">
                                        <button type="button" id="clear-craft-input-btn"
                                            class="px-3 py-2 rounded-lg text-gray-400 hover:text-white bg-gray-800/70 hover:bg-gray-700/70 border border-gray-600/30 hover:border-gray-500/50 transition-all flex items-center gap-1.5"
                                            title="Clear craft input">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                                                </path>
                                            </svg>
                                            <span class="text-xs font-medium">Clear</span>
                                        </button>

                                        <button type="button" id="prompt-craft-btn"
                                            class="px-4 py-2 rounded-lg text-white font-bold text-sm uppercase tracking-wider flex items-center gap-2 bg-gradient-to-r from-purple-600 to-purple-800 hover:from-purple-500 hover:to-purple-700 transition-all shadow-lg shadow-purple-500/20"
                                            title="Generate enhanced prompt using AI">
                                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                                            </svg>
                                            <span>Craft</span>
                                            <span id="prompt-craft-spinner" class="loader hidden"></span>
                                        </button>
                                    </div>
                                </div>

                                <p class="mt-2 text-xs text-gray-500">
                                    AI will analyze your uploaded image and description to create an optimized prompt.
                                    Press Ctrl+Z to undo changes.
                                </p>
                            </div>
                        </div>

                    </div>
                    <!-- ========== END: Horizontal Layout ========== -->

                    <!-- Prompt (Full Width) -->
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-3">
                            <label class="text-sm font-semibold text-gray-400 uppercase tracking-wide">Prompt</label>
                            <div class="flex items-center gap-2">
                                <button id="copy-prompt-btn" onclick="copyPromptToClipboard()"
                                    title="Copy prompt to clipboard"
                                    class="copy-prompt-btn px-2 py-1 rounded-lg transition-all border text-xs font-semibold flex items-center gap-1 opacity-70 hover:opacity-100 bg-gray-800/50 hover:bg-gray-700 border-gray-600/30 text-cyan-400">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z">
                                        </path>
                                    </svg>
                                    <span>Copy</span>
                                </button>
                                <button id="clear-prompt-btn" onclick="clearPrompts()" title="Clear prompts"
                                    class="clear-prompt-btn px-2 py-1 rounded-lg transition-all border text-xs font-semibold flex items-center gap-1 opacity-70 hover:opacity-100">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                                        </path>
                                    </svg>
                                    <span>Clear</span>
                                </button>
                            </div>
                        </div>
                        <!-- Full Width Prompt Textarea -->
                        <textarea id="prompt" rows="7" placeholder="Describe your video in detail..."
                            class="w-full px-4 py-3 rounded-xl focus:ring-2 focus:ring-cyan-500/50 resize-y min-h-[180px]"></textarea>

                        <!-- Hidden Radio Buttons for Compatibility -->
                        <div class="hidden">
                            <input type="radio" name="gen-type" value="text-to-video" checked>
                            <input type="radio" name="gen-type" value="image-to-video" id="i2v-card">
                        </div>
                    </div>

                    <!-- Enable Prompt Expansion Checkbox (Wan 2.5 & 2.6 - Compact Version) -->
                    <div id="prompt-expansion-section" class="mb-6 hidden">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="prompt-expansion"
                                class="w-4 h-4 rounded border-gray-600 bg-gray-800 text-purple-500 focus:ring-2 focus:ring-purple-500/50">
                            <span class="text-sm text-gray-400">Enable Prompt Expansion
                                (‡∏Ç‡∏¢‡∏≤‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÉ‡∏´‡πâ‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡∏™‡∏±‡πâ‡∏ô)</span>
                        </label>
                    </div>

                    <!-- Negative Prompt with Pink/Magenta Border -->
                    <div id="negative-prompt-section" class="mb-6 hidden">
                        <label class="block text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wide">Negative
                            Prompt (Optional)</label>
                        <textarea id="negative-prompt" rows="2" placeholder="Things to avoid..."
                            class="w-full px-4 py-3 rounded-xl border-2 border-pink-500/50 bg-gray-900/50 focus:ring-2 focus:ring-pink-500/50 focus:border-pink-500 resize-y min-h-[60px]"></textarea>
                    </div>

                    <!-- Last Image Upload (Kling O1 Only) -->
                    <div id="last-image-section" class="mb-6 hidden">
                        <label class="block text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wide">Last Image
                            (Optional) üé¨</label>
                        <p class="text-xs text-gray-500 mb-3">Upload final frame to guide video generation (enables
                            3-10s duration)</p>

                        <!-- Last Image Preview -->
                        <div id="last-image-preview-container" class="hidden mb-3">
                            <div class="relative">
                                <img id="last-image-preview" src="#" alt="Last Image Preview"
                                    class="w-full h-auto rounded-xl border-2 border-cyan-500/30 cursor-pointer hover:border-cyan-500/60 transition-all"
                                    onclick="openImageModal(this.src)">
                                <button type="button" onclick="clearLastImage()"
                                    class="absolute top-2 right-2 px-3 py-1.5 rounded-lg bg-red-600/90 hover:bg-red-500 text-white text-xs font-semibold transition-all">
                                    Remove
                                </button>
                            </div>
                        </div>

                        <!-- Last Image Drag & Drop Area -->
                        <div id="last-image-drop-area" class="drag-drop-area">
                            <input type="file" id="last-image-file-input" accept="image/*" class="hidden">
                            <svg class="w-12 h-12 mb-3 text-cyan-400" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                                </path>
                            </svg>
                            <p class="text-sm font-semibold text-gray-300 mb-1">Drop last frame image here</p>
                            <p class="text-xs text-gray-500">or <button type="button"
                                    onclick="document.getElementById('last-image-file-input').click()"
                                    class="text-cyan-400 hover:text-cyan-300 underline">browse files</button></p>
                            <p class="text-xs text-gray-600 mt-2">Supported: JPG, PNG, WEBP (max 25MB)</p>
                        </div>
                    </div>

                    <!-- ========== START: Top Generate Button & Progress (NEW - Horizontal Layout) ========== -->
                    <div class="mb-6 flex gap-3 items-center">
                        <!-- Progress Bar (Left - Flexible Width) -->
                        <div id="status-container-top" class="flex-1 cyber-card rounded-xl p-4">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center gap-2">
                                    <span id="status-badge-top"
                                        class="status-badge status-ready text-xs px-2 py-1">READY</span>
                                    <span id="status-text-top" class="text-cyan-400 font-semibold text-sm">Ready to
                                        generate</span>
                                </div>
                                <span id="elapsed-time-top" class="text-cyan-400 text-sm font-mono">0s</span>
                            </div>
                            <!-- Segmented HUD-style progress bar -->
                            <div style="position: relative; width: 100%;">
                                <!-- Segment container -->
                                <div id="segmented-progress-container" class="segmented-progress-container">
                                    <!-- 24 segments will be generated by JavaScript -->
                                </div>

                                <!-- Scanline overlay -->
                                <div class="segmented-progress-scanline"></div>
                            </div>
                            <div id="generation-details-top" class="hidden text-xs text-gray-500 mt-2 flex gap-4">
                                <span><span class="text-gray-400">Provider:</span> <span id="generation-provider-top"
                                        class="font-semibold text-purple-400">-</span></span>
                                <span><span class="text-gray-400">ID:</span> <span id="generation-id-top"
                                        class="font-mono text-cyan-400">-</span></span>
                            </div>
                        </div>

                        <!-- Generate Button (Right - Fixed Width) -->
                        <button type="button" id="generate-btn-top"
                            class="cyber-btn px-8 py-5 rounded-xl text-white font-bold text-base uppercase tracking-wider flex items-center justify-center gap-2 whitespace-nowrap">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z">
                                </path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span>Generate</span>
                            <span id="generate-spinner-top" class="loader hidden"></span>
                        </button>
                    </div>

                    <!-- Cancel Button (Top - Full Width, Hidden by Default) -->
                    <button id="cancel-generation-btn-top"
                        class="hidden mb-6 w-full py-3 rounded-xl bg-gradient-to-r from-red-500 to-red-600 text-white font-bold text-sm uppercase tracking-wider hover:from-red-600 hover:to-red-700 transition-all flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                        <span>Cancel Generation</span>
                    </button>
                    <!-- ========== END: Top Generate Button & Progress (NEW - Horizontal Layout) ========== -->

                    <!-- Image Upload (for I2V) - OLD SECTION - NOW HIDDEN, REPLACED BY LEFT SIDEBAR -->
                    <div id="image-upload-section" class="mb-6 hidden" style="display: none !important;">

                        <!-- ========== START: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô HTML ‡∏ô‡∏µ‡πâ ========== -->
                        <!-- NEW: Drag & Drop Area (Wavespeed Only) -->
                        <div id="drag-drop-area"
                            class="hidden mb-4 border-2 border-dashed border-cyan-500/50 rounded-xl p-8 text-center cursor-pointer hover:border-cyan-400 hover:bg-cyan-500/10 transition-all">
                            <svg class="w-12 h-12 mx-auto text-gray-500 mb-3" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M7 16a4 4 0 01-4-4V7a4 4 0 014-4h10a4 4 0 014 4v5a4 4 0 01-4 4H7z M5 10h14M12 6v12m-4-4l4 4 4-4">
                                </path>
                            </svg>
                            <p class="text-gray-400 text-sm">‡∏•‡∏≤‡∏Å‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (Drag & Drop Image Here)</p>
                            <p class="text-xs text-gray-600 mt-1">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö (Supports): JPG, PNG, WEBP (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 25MB)</p>
                            <input type="file" id="file-input-fallback" class="hidden"
                                accept="image/jpeg,image/png,image/webp">
                            <button type="button" id="browse-button"
                                class="mt-3 text-xs text-cyan-400 hover:text-cyan-300 underline">‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå (Or
                                Browse File)</button>
                        </div>
                        <!-- ========== END: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô HTML ‡∏ô‡∏µ‡πâ ========== -->

                        <!-- Image Preview (Existing structure - Ensure it's AFTER DragDrop Area) -->
                        <div id="image-preview-container" class="mt-4 hidden">
                            <!-- Preview Image with Delete Icon and Drag-Drop Overlay -->
                            <div class="inline-block relative group cursor-pointer" id="preview-wrapper">
                                <img id="image-preview"
                                    class="max-h-32 w-auto rounded-lg border border-cyan-500/30 neon-border-cyan"
                                    src="#">

                                <!-- Delete Icon (Top-Right, visible on hover) - Cyber Style (Smaller: 7x7) -->
                                <button type="button" id="delete-image-btn"
                                    class="absolute top-1.5 right-1.5 w-7 h-7 bg-gradient-to-br from-red-500/90 to-pink-600/90 hover:from-red-400 hover:to-pink-500 border border-red-400/50 hover:border-pink-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-red-500/50"
                                    style="backdrop-filter: blur(10px);">
                                    <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]"
                                        fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5"
                                            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                                        </path>
                                    </svg>
                                </button>

                                <!-- Drag-Drop Overlay (visible when dragging over) -->
                                <div id="preview-drag-overlay"
                                    class="absolute inset-0 bg-cyan-500/20 border-2 border-dashed border-cyan-400 flex items-center justify-center opacity-0 transition-opacity rounded-lg pointer-events-none z-10">
                                    <div class="text-center">
                                        <svg class="w-10 h-10 mx-auto text-cyan-400 mb-2" fill="none"
                                            stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12">
                                            </path>
                                        </svg>
                                        <span class="text-cyan-300 text-sm font-semibold">Drop to Replace</span>
                                    </div>
                                </div>

                                <!-- Click to Enlarge Overlay (shows on hover) -->
                                <div
                                    class="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity rounded-lg pointer-events-none z-5">
                                    <span class="text-white text-xs font-medium">Click to enlarge</span>
                                </div>

                                <!-- Video Generation Processing Overlay (Hologram Effect) -->
                                <div id="video-generation-processing-overlay"
                                    class="hidden absolute inset-0 rounded-lg overflow-hidden z-30 pointer-events-none">
                                    <!-- Hologram Effect -->
                                    <div class="absolute inset-0 hologram-overlay rounded-lg"></div>

                                    <!-- Status Text -->
                                    <div class="absolute inset-0 flex items-center justify-center">
                                        <p id="video-generation-status-text"
                                            class="text-cyan-400 text-sm font-semibold drop-shadow-[0_2px_8px_rgba(0,0,0,0.9)]">
                                            ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠...</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- ========== START: ‡πÄ‡∏û‡∏¥‡πà‡∏° div ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ========== -->
                        <!-- üöß TEMPORARILY HIDDEN: URL input not working due to CORS - See DEVELOPMENT.md -->
                        <div id="image-url-input-group" class="hidden">
                            <!-- ========== END: ‡πÄ‡∏û‡∏¥‡πà‡∏° div ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ========== -->
                            <label for="image-url"
                                class="block text-sm font-semibold text-gray-400 mb-2 uppercase tracking-wide">Source
                                Image URL</label>
                            <input type="url" id="image-url" placeholder="https://example.com/image.jpg"
                                class="w-full px-4 py-3 rounded-xl focus:ring-2 focus:ring-cyan-500/50">
                            <p class="mt-2 text-xs text-gray-500">Must be a publicly accessible URL</p>
                            <!-- ========== START: ‡πÄ‡∏û‡∏¥‡πà‡∏° /div ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏£‡∏≠‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ========== -->
                        </div>
                        <!-- ========== END: ‡πÄ‡∏û‡∏¥‡πà‡∏° /div ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏£‡∏≠‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ========== -->
                    </div>

                    <!-- Video Upload (for Video Extend) -->
                    <div id="video-upload-section" class="mb-6 hidden">
                        <h3 class="text-lg font-semibold text-cyan-400 mb-3 flex items-center gap-2">
                            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2 6a2 2 0 012-2h6a2 2 0 012 2v8a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                                <path
                                    d="M14.553 7.106A1 1 0 0014 8v4a1 1 0 00.553.894l2 1A1 1 0 0018 13V7a1 1 0 00-1.447-.894l-2 1z" />
                            </svg>
                            Source Video
                        </h3>

                        <!-- Video URL Input -->
                        <div class="mb-4">
                            <label class="block text-sm text-gray-400 mb-2">Video URL</label>
                            <input type="text" id="video-url-input" placeholder="https://example.com/video.mp4"
                                class="w-full bg-gray-900/50 border border-gray-700 rounded-xl px-4 py-3 text-white text-sm focus:border-cyan-500 focus:outline-none focus:ring-2 focus:ring-cyan-500/50" />
                            <p class="text-xs text-gray-500 mt-1">Or upload a video file below</p>
                        </div>

                        <!-- Video File Upload -->
                        <div id="video-drop-zone"
                            class="border-2 border-dashed border-gray-700 rounded-xl p-8 text-center cursor-pointer hover:border-cyan-500 hover:bg-cyan-500/10 transition-all">
                            <input type="file" id="video-file-input" accept="video/mp4,video/webm,video/quicktime"
                                class="hidden" />
                            <svg class="w-12 h-12 mx-auto text-gray-600 mb-3" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                            </svg>
                            <p class="text-gray-400 mb-1">Drag & drop video or click to browse</p>
                            <p class="text-xs text-gray-600">MP4, WebM, MOV ‚Ä¢ Max 100MB</p>
                        </div>

                        <!-- Video Preview -->
                        <div id="video-preview-container" class="mt-4 hidden relative group">
                            <video id="video-preview" controls
                                class="w-full rounded-xl border border-cyan-500/30 max-h-64"></video>

                            <!-- Hover Delete Button (Top-Right) -->
                            <button type="button" id="remove-video-btn"
                                class="absolute top-2 right-2 w-8 h-8 bg-gradient-to-br from-red-500/90 to-pink-600/90 hover:from-red-400 hover:to-pink-500 border border-red-400/50 hover:border-pink-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-red-500/50 hover:scale-110"
                                title="Remove Video"
                                style="backdrop-filter: blur(10px);">
                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                </svg>
                            </button>

                            <!-- Drag-Drop Overlay -->
                            <div id="video-drag-overlay"
                                class="absolute inset-0 bg-cyan-500/20 border-2 border-dashed border-cyan-400 flex items-center justify-center opacity-0 transition-opacity rounded-xl pointer-events-none z-10">
                                <div class="text-center">
                                    <svg class="w-10 h-10 mx-auto text-cyan-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                    </svg>
                                    <p class="text-white text-sm font-semibold">Drop to Replace Video</p>
                                </div>
                            </div>

                            <!-- Video Info -->
                            <div class="mt-2">
                                <span id="video-info" class="text-xs text-gray-500"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Lipsync (Optional) -->
                    <div id="audio-url-section" class="mb-4 hidden">
                        <label
                            class="block text-sm font-semibold text-gray-400 mb-2 uppercase tracking-wide text-xs">Audio
                            Lipsync</label>
                        <input type="url" id="audio-url"
                            placeholder="https://example.com/audio.mp3 (wav/mp3, 3-30s, ‚â§15MB)"
                            class="w-full px-4 py-3 rounded-xl focus:ring-2 focus:ring-cyan-500/50 text-sm">
                        <p class="mt-1 text-xs text-gray-500">Audio will be synced/truncated to video duration</p>
                    </div>

                    <!-- Compact Parameters: Duration + Resolution + Cost (Single Row) -->
                    <div class="mb-6 flex gap-3 items-end">
                        <!-- Duration -->
                        <div id="duration-section" class="flex-1">
                            <label
                                class="block text-xs font-semibold text-gray-400 mb-2 uppercase tracking-wide">Duration</label>
                            <select id="duration-select-wavespeed"
                                class="w-full px-4 py-3 rounded-xl font-semibold focus:ring-2 focus:ring-cyan-500/50">
                                <option value="3" selected>3 sec</option>
                                <option value="5">5 sec</option>
                                <option value="10">10 sec</option>
                            </select>
                        </div>

                        <!-- Resolution -->
                        <div class="flex-1">
                            <label
                                class="block text-xs font-semibold text-gray-400 mb-2 uppercase tracking-wide">Resolution</label>
                            <select id="resolution"
                                class="w-full px-4 py-3 rounded-xl font-semibold focus:ring-2 focus:ring-cyan-500/50">
                                <option value="480p" selected>480p</option>
                                <option value="720p">720p</option>
                                <option value="1080p">1080p</option>
                            </select>
                        </div>

                        <!-- Cost Display (Compact) -->
                        <div id="wavespeed-cost-section" class="hidden flex-1">
                            <label
                                class="block text-xs font-semibold text-gray-400 mb-2 uppercase tracking-wide">Cost</label>
                            <div class="px-4 py-3 rounded-xl border border-cyan-500/30 bg-cyan-500/10 text-center">
                                <p id="wavespeed-cost" class="text-lg font-bold neon-text-cyan">$0.00</p>
                            </div>
                        </div>
                    </div>

                    <!-- Aspect Ratio (T2V Only - Hidden by Default) -->
                    <div id="aspect-ratio-section" class="mb-6 hidden">
                        <label class="block text-sm font-semibold text-gray-400 mb-3 uppercase tracking-wide">Aspect
                            Ratio</label>
                        <div class="grid grid-cols-5 gap-3">
                            <!-- 16:9 Landscape -->
                            <div class="aspect-ratio-card rounded-xl p-3 selected" data-aspect="16:9">
                                <div class="w-16 h-16 mx-auto bg-black rounded-lg flex items-center justify-center p-2">
                                    <img src="assets/scale_16_9.png" alt="16:9" class="w-full h-full object-contain">
                                </div>
                                <p class="text-center text-xs font-semibold mt-2">16:9</p>
                            </div>
                            <!-- 4:3 Classic -->
                            <div class="aspect-ratio-card rounded-xl p-3" data-aspect="4:3">
                                <div class="w-16 h-16 mx-auto bg-black rounded-lg flex items-center justify-center p-2">
                                    <svg class="w-10 h-8" viewBox="0 0 40 30" fill="none" stroke="white"
                                        stroke-width="2">
                                        <rect x="2" y="2" width="36" height="26" rx="2" />
                                    </svg>
                                </div>
                                <p class="text-center text-xs font-semibold mt-2">4:3</p>
                            </div>
                            <!-- 1:1 Square -->
                            <div class="aspect-ratio-card rounded-xl p-3" data-aspect="1:1">
                                <div class="w-16 h-16 mx-auto bg-black rounded-lg flex items-center justify-center p-2">
                                    <img src="assets/scale_1_1.png" alt="1:1" class="w-full h-full object-contain">
                                </div>
                                <p class="text-center text-xs font-semibold mt-2">1:1</p>
                            </div>
                            <!-- 9:16 Portrait -->
                            <div class="aspect-ratio-card rounded-xl p-3" data-aspect="9:16">
                                <div class="w-16 h-16 mx-auto bg-black rounded-lg flex items-center justify-center p-2">
                                    <img src="assets/scale_9_16.png" alt="9:16" class="w-full h-full object-contain">
                                </div>
                                <p class="text-center text-xs font-semibold mt-2">9:16</p>
                            </div>
                            <!-- 9:21 TikTok/Shorts -->
                            <div class="aspect-ratio-card rounded-xl p-3" data-aspect="9:21">
                                <div class="w-16 h-16 mx-auto bg-black rounded-lg flex items-center justify-center p-2">
                                    <svg class="w-6 h-12" viewBox="0 0 21 49" fill="none" stroke="white"
                                        stroke-width="2">
                                        <rect x="2" y="2" width="17" height="45" rx="2" />
                                    </svg>
                                </div>
                                <p class="text-center text-xs font-semibold mt-2">9:21</p>
                            </div>
                        </div>
                    </div>

                    <!-- Shot Type (Wan 2.6 Only) -->
                    <div id="shot-type-section"
                        class="mb-6 hidden p-4 rounded-xl border border-purple-500/30 bg-purple-500/5">
                        <div class="flex items-center gap-2 mb-3">
                            <span class="text-sm font-semibold text-purple-400 uppercase tracking-wide">Shot Type</span>
                            <span
                                class="text-[10px] bg-purple-500/20 text-purple-300 px-2 py-0.5 rounded border border-purple-500/30">Wan
                                2.6</span>
                        </div>

                        <select id="shot-type"
                            class="w-full px-3 py-2.5 rounded-lg font-semibold bg-gray-900/50 border border-purple-500/30 focus:border-purple-400 text-sm">
                            <option value="single">Single Shot - ‡∏ä‡πá‡∏≠‡∏ï‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</option>
                            <option value="multi">Multi Shot - ‡∏ï‡∏±‡∏î‡∏ï‡πà‡∏≠‡∏´‡∏•‡∏≤‡∏¢‡∏°‡∏∏‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</option>
                        </select>
                        <p class="mt-2 text-[10px] text-gray-500">
                            <span class="font-semibold">Single:</span> ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ä‡πá‡∏≠‡∏ï‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á |
                            <span class="font-semibold">Multi:</span> AI ‡∏ï‡∏±‡∏î‡∏ï‡πà‡∏≠‡∏´‡∏•‡∏≤‡∏¢‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
                        </p>
                    </div>

                </div>

                <!-- Video Player -->
            </div>

            <!-- Right Column: Video History -->
            <div class="lg:col-span-1">
                <div class="cyber-card rounded-2xl p-6 sticky top-4">
                    <div class="flex items-center justify-between mb-6">
                        <div class="flex flex-col gap-1">
                            <h2 class="text-xl font-bold neon-text-cyan uppercase flex items-center gap-2">
                                <!-- ‚ú® NEW: Clickable filter icon -->
                                <svg id="history-filter-icon" onclick="cycleHistoryFilter()"
                                    class="w-6 h-6 cursor-pointer transition-all duration-200 hover:scale-110"
                                    fill="none" stroke="currentColor" viewBox="0 0 24 24"
                                    title="Click to filter: All / Videos / Images">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10">
                                    </path>
                                </svg>
                                History
                            </h2>
                            <!-- ‚ú® NEW: Filter mode description -->
                            <p id="history-filter-description" class="text-xs text-gray-400 pl-8">
                                All videos and images
                            </p>
                        </div>
                        <div class="flex gap-2 items-center">
                            <!-- Toggle History Visibility -->
                            <button id="toggle-history-btn" onclick="toggleHistoryVisibility()"
                                title="Show/Hide History"
                                class="px-2 py-2 bg-gray-700/30 hover:bg-gray-600/40 rounded-lg transition-all text-xs">
                                <svg id="history-icon-visible" class="w-4 h-4 text-gray-400" fill="none"
                                    stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z">
                                    </path>
                                </svg>
                                <svg id="history-icon-hidden" class="w-4 h-4 text-gray-400 hidden" fill="none"
                                    stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21">
                                    </path>
                                </svg>
                            </button>
                            <!-- Grid/List View Toggle Button -->
                            <button id="toggle-grid-btn" onclick="toggleGridView()" title="Toggle Grid/List View"
                                class="px-2 py-2 bg-gray-700/30 hover:bg-gray-600/40 rounded-lg transition-all text-xs">
                                <!-- Grid Icon (show when in list mode) -->
                                <svg id="grid-icon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z">
                                    </path>
                                </svg>
                                <!-- List Icon (show when in grid mode) -->
                                <svg id="list-icon" class="w-4 h-4 text-gray-400 hidden" fill="none"
                                    stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 6h16M4 12h16M4 18h16"></path>
                                </svg>
                            </button>
                            <button onclick="refreshHistory()" title="Refresh History"
                                class="px-3 py-2 bg-purple-500/20 hover:bg-purple-500/30 rounded-lg transition-all neon-border text-xs font-semibold text-purple-400">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                                    </path>
                                </svg>
                            </button>
                            <!-- Clear History button removed - individual delete buttons now available on each card -->
                        </div>
                    </div>

                    <!-- Mini Progress Bar (History Panel) -->
                    <div style="position: relative; width: 100%; margin-bottom: 16px;">
                        <div id="segmented-progress-mini" class="segmented-progress-mini">
                            <!-- 24 segments will be generated by JavaScript -->
                        </div>
                        <div class="segmented-progress-scanline-mini"></div>
                    </div>

                    <!-- ========== ‚ú® NEW: Search/Filter/Export Controls ========== -->
                    <div class="flex flex-col gap-2 mb-3">
                        <!-- Search Box -->
                        <input
                            type="text"
                            id="history-search-input"
                            placeholder="üîç Search prompts, resolution, duration, type..."
                            oninput="applyHistorySearchFilter()"
                            class="w-full px-3 py-2 bg-gray-900/50 border border-cyan-500/30 rounded-lg text-sm text-gray-300 placeholder-gray-500 focus:outline-none focus:border-cyan-400 transition-all"
                        />

                        <!-- Filter/Sort/Export Row -->
                        <div class="flex gap-2">
                            <!-- Status Filter -->
                            <select
                                id="history-status-filter"
                                onchange="applyHistorySearchFilter()"
                                class="flex-1 px-2 py-1.5 bg-gray-900/50 border border-purple-500/30 rounded-lg text-xs text-gray-300 focus:outline-none focus:border-purple-400 transition-all">
                                <option value="all">All Status</option>
                                <option value="completed">Completed</option>
                                <option value="failed">Failed</option>
                                <option value="processing">Processing</option>
                            </select>

                            <!-- Sort -->
                            <select
                                id="history-sort-order"
                                onchange="applyHistorySearchFilter()"
                                class="flex-1 px-2 py-1.5 bg-gray-900/50 border border-green-500/30 rounded-lg text-xs text-gray-300 focus:outline-none focus:border-green-400 transition-all">
                                <option value="newest">Newest First</option>
                                <option value="oldest">Oldest First</option>
                            </select>

                            <!-- Kebab Menu -->
                            <div class="relative" id="export-menu-container">
                                <!-- Kebab Button -->
                                <button
                                    id="export-menu-btn"
                                    onclick="toggleExportMenu()"
                                    title="More Options"
                                    class="px-3 py-1.5 bg-gradient-to-r from-orange-500/20 to-pink-500/20 hover:from-orange-500/30 hover:to-pink-500/30 border border-orange-500/30 rounded-lg transition-all text-xs font-semibold text-orange-400 whitespace-nowrap">
                                    ‚ãÆ
                                </button>

                                <!-- Dropdown Menu -->
                                <div
                                    id="export-menu-list"
                                    class="hidden absolute right-0 mt-1 w-40 bg-gray-900 border border-orange-500/30 rounded-lg shadow-lg shadow-black/50 overflow-hidden z-50">
                                    <button
                                        onclick="exportHistory(); hideExportMenu()"
                                        class="w-full px-4 py-2.5 text-left flex items-center gap-2 hover:bg-orange-500/10 transition-colors text-sm text-orange-400">
                                        <span>üì•</span>
                                        <span>Export</span>
                                    </button>
                                    <!-- Future menu items can be added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- ========== END: Search/Filter/Export Controls ========== -->

                    <div id="video-history"
                        class="space-y-3 max-h-[calc(100vh-100px)] overflow-y-auto custom-scrollbar pr-2">
                        <p class="text-sm text-gray-500 text-center py-8">No videos yet. Generate your first video!</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Video Modal -->
    <div id="video-modal" class="fixed inset-0 bg-black/90 hidden items-center justify-center z-50 p-4 backdrop-blur-sm"
        onclick="closeVideoModalOnBackdrop(event)">
        <div class="cyber-card rounded-2xl max-w-5xl w-full mx-auto max-h-[95vh] overflow-y-auto flex flex-col custom-scrollbar"
            onclick="event.stopPropagation()">
            <div
                class="flex justify-between items-center p-4 border-b border-purple-500/20 sticky top-0 bg-[#131320]/95 z-10 rounded-t-2xl backdrop-blur-sm">
                <h3 class="text-xl font-bold neon-text-cyan uppercase">Video Player</h3>
                <button id="close-modal"
                    class="text-gray-400 hover:text-cyan-400 text-3xl font-bold leading-none transition-all">&times;</button>
            </div>
            <div class="p-6 flex-1">
                <div id="modal-video-container" class="relative bg-black rounded-xl overflow-hidden neon-border-cyan"
                    style="max-height: calc(95vh - 200px);">
                    <video id="modal-video-player" class="w-full h-full" controls preload="auto"
                        crossorigin="anonymous" loop style="max-height: calc(95vh - 200px);"></video>

                    <!-- ‚ú® Loading Overlay - Cyber Design -->
                    <div id="video-loading-overlay"
                        class="absolute inset-0 bg-gradient-to-br from-black via-purple-900/20 to-black flex items-center justify-center rounded-xl"
                        style="display: none; backdrop-filter: blur(10px);">
                        <div class="text-center">
                            <!-- Cyber Loading Animation -->
                            <div class="relative w-24 h-24 mx-auto mb-6">
                                <!-- Outer Ring -->
                                <div class="absolute inset-0 border-4 border-purple-500/30 rounded-full"></div>
                                <!-- Spinning Ring -->
                                <svg class="absolute inset-0 animate-spin" viewBox="0 0 100 100">
                                    <circle cx="50" cy="50" r="45" fill="none" stroke="url(#gradient)" stroke-width="4"
                                        stroke-dasharray="70 200" stroke-linecap="round" />
                                    <defs>
                                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:#a855f7;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:1" />
                                        </linearGradient>
                                    </defs>
                                </svg>
                                <!-- Center Glow -->
                                <div class="absolute inset-0 flex items-center justify-center">
                                    <div class="w-8 h-8 bg-cyan-400 rounded-full animate-pulse"
                                        style="box-shadow: 0 0 20px rgba(6, 182, 212, 0.8), 0 0 40px rgba(6, 182, 212, 0.4);">
                                    </div>
                                </div>
                            </div>

                            <!-- Loading Text -->
                            <p class="text-cyan-400 font-bold text-xl mb-2 neon-text-cyan tracking-wider uppercase">
                                Loading Video
                            </p>
                            <p class="text-purple-400 text-sm animate-pulse">Please wait...</p>

                            <!-- Progress Dots -->
                            <div class="flex justify-center gap-2 mt-4">
                                <div class="w-2 h-2 bg-cyan-400 rounded-full animate-bounce"
                                    style="animation-delay: 0s; box-shadow: 0 0 10px rgba(6, 182, 212, 0.8);"></div>
                                <div class="w-2 h-2 bg-purple-400 rounded-full animate-bounce"
                                    style="animation-delay: 0.2s; box-shadow: 0 0 10px rgba(168, 85, 247, 0.8);"></div>
                                <div class="w-2 h-2 bg-cyan-400 rounded-full animate-bounce"
                                    style="animation-delay: 0.4s; box-shadow: 0 0 10px rgba(6, 182, 212, 0.8);"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="mt-4">
                    <p id="modal-video-info" class="text-sm text-gray-400 break-words"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Image Modal -->
    <div id="image-modal" class="fixed inset-0 bg-black/90 hidden items-center justify-center z-50 p-4 backdrop-blur-sm"
        onclick="closeImageModalOnBackdrop(event)">
        <div class="cyber-card rounded-2xl p-4 max-w-4xl w-full relative max-h-[95vh] overflow-auto custom-scrollbar"
            onclick="event.stopPropagation()">
            <button id="close-image-modal"
                class="absolute top-2 right-2 bg-purple-500 hover:bg-purple-600 rounded-full h-9 w-9 text-2xl font-bold flex items-center justify-center z-10 cursor-pointer transition-all neon-border text-white shadow-lg hover:shadow-purple-500/50">&times;</button>

            <!-- ‚ú® NEW: Navigation Buttons -->
            <button id="modal-prev-btn" onclick="event.stopPropagation(); navigateModalImage(-1)"
                class="absolute left-4 top-1/2 -translate-y-1/2 w-12 h-12 flex items-center justify-center rounded-lg bg-purple-600/80 hover:bg-purple-600 text-white transition-all disabled:opacity-30 disabled:cursor-not-allowed z-20 shadow-lg hover:shadow-purple-500/50"
                title="Previous image">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                </svg>
            </button>
            <button id="modal-next-btn" onclick="event.stopPropagation(); navigateModalImage(1)"
                class="absolute right-4 top-1/2 -translate-y-1/2 w-12 h-12 flex items-center justify-center rounded-lg bg-purple-600/80 hover:bg-purple-600 text-white transition-all disabled:opacity-30 disabled:cursor-not-allowed z-20 shadow-lg hover:shadow-purple-500/50"
                title="Next image">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
            </button>

            <!-- History Counter -->
            <div id="modal-history-counter" class="absolute top-2 left-2 px-3 py-1.5 rounded-lg bg-black/60 text-white text-sm font-semibold z-10 backdrop-blur-sm">
                <span id="modal-history-text">1/1</span>
            </div>

            <img id="modal-image-full" src="#" alt="Full Image Preview"
                class="w-full max-h-[85vh] object-contain rounded-lg">
        </div>
    </div>

    <!-- ========== ‚úÖ VERSION MANAGEMENT: Single Source of Truth ========== -->
    <script src="js/version.js"></script>

    <!-- ========== ‚úÖ PERFORMANCE FIX: Load centralized config file ========== -->
    <script src="js/config.js"></script>

    <!-- ========== ‚úÖ VERSION UI UPDATE: Dynamic version display ========== -->
    <script>
        // Update version display in header (if elements exist)
        document.addEventListener('DOMContentLoaded', function () {
            const versionDisplay = document.getElementById('version-display');
            const buildDisplay = document.getElementById('build-display');

            if (versionDisplay && typeof VIDIST_VERSION !== 'undefined') {
                versionDisplay.textContent = VIDIST_VERSION.full;
            }

            if (buildDisplay && typeof VIDIST_VERSION !== 'undefined') {
                buildDisplay.textContent = `build ${VIDIST_VERSION.build}`;
            }
        });
    </script>

    <script>
        // --- Configuration ---
        // ‚úÖ PERFORMANCE FIX: MODEL_CONFIG and WAVESPEED_API_BASE_URL now loaded from config.js
        // (Removed ~85 lines of duplicate code)

        // Model configurations - Removed (now in config.js)
        // Status translations - Removed (now in config.js)

        // --- DOM Elements ---
        const apiKeyInput_ws = document.getElementById('api-key-wavespeed');
        const toggleApiKeyBtn = document.getElementById('toggle-api-key');
        const apiKeySection = document.getElementById('api-key-section');
        const apiKeyChevron = document.getElementById('api-key-chevron');
        const toggleWavespeedApi = document.getElementById('toggle-wavespeed-api');
        const modelSelect = document.getElementById('model-select');
        const genTypeRadios = document.querySelectorAll('input[name="gen-type"]');
        const promptTextarea = document.getElementById('prompt');
        const negativePromptSection = document.getElementById('negative-prompt-section');
        const negativePromptInput = document.getElementById('negative-prompt');
        // Prompt Craft Elements
        const promptCraftInput = document.getElementById('prompt-craft-input');
        const promptCraftBtn = document.getElementById('prompt-craft-btn');
        const promptCraftSpinner = document.getElementById('prompt-craft-spinner');
        const geminiApiKeyInput = document.getElementById('api-key-gemini');
        const toggleGeminiApi = document.getElementById('toggle-gemini-api');
        const imageUploadSection = document.getElementById('image-upload-section');
        // ========== Image Upload Elements (NEW - Left Sidebar) ==========
        const imageUploadSectionLeft = document.getElementById('image-upload-section-left');
        const imagePreviewContainerLeft = document.getElementById('image-preview-container-left');
        const imagePreviewLeft = document.getElementById('image-preview-left');
        const dragDropAreaLeft = document.getElementById('drag-drop-area-left');
        const fileInputLeft = document.getElementById('file-input-left');
        const browseButtonLeft = document.getElementById('browse-button-left');
        const deleteImageBtnLeft = document.getElementById('delete-image-btn-left');
        const previewWrapperLeft = document.getElementById('preview-wrapper-left');
        const previewDragOverlayLeft = document.getElementById('preview-drag-overlay-left');
        const imageUrlLeft = document.getElementById('image-url-left');
        // ========== END: Left Sidebar Elements ==========

        // Old elements (kept for backward compatibility, but hidden)
        const dragDropArea = document.getElementById('drag-drop-area');
        const imageUrlInputGroup = document.getElementById('image-url-input-group');
        const fileInputFallback = document.getElementById('file-input-fallback');
        const browseButton = document.getElementById('browse-button');
        const previewWrapper = document.getElementById('preview-wrapper');
        const previewDragOverlay = document.getElementById('preview-drag-overlay');
        const imageUrl = document.getElementById('image-url');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const audioUrlSection = document.getElementById('audio-url-section');
        const audioUrlInput = document.getElementById('audio-url');
        // Video upload elements (for Video Extend)
        const videoUploadSection = document.getElementById('video-upload-section');
        const videoUrlInput = document.getElementById('video-url-input');
        const videoDropZone = document.getElementById('video-drop-zone');
        const videoFileInput = document.getElementById('video-file-input');
        const videoPreviewContainer = document.getElementById('video-preview-container');
        const videoPreview = document.getElementById('video-preview');
        const videoInfoSpan = document.getElementById('video-info');
        const removeVideoBtn = document.getElementById('remove-video-btn');
        const videoDragOverlay = document.getElementById('video-drag-overlay');
        // Duration elements
        const durationSection = document.getElementById('duration-section');
        const durationSelectWavespeed = document.getElementById('duration-select-wavespeed');
        const maxDurationText = document.getElementById('max-duration-text');
        // ---
        const resolutionSelect = document.getElementById('resolution');
        const aspectRatioSection = document.getElementById('aspect-ratio-section');
        const aspectCards = document.querySelectorAll('.aspect-ratio-card[data-aspect]');
        // ========== START: Top Button & Progress Elements ==========
        const generateBtn = document.getElementById('generate-btn-top');
        const generateSpinner = document.getElementById('generate-spinner-top');
        const cancelGenerationBtn = document.getElementById('cancel-generation-btn-top');
        const statusContainer = document.getElementById('status-container-top');
        const statusBadge = document.getElementById('status-badge-top');
        const statusText = document.getElementById('status-text-top');
        const progressBar = document.getElementById('progress-bar-top'); // Legacy (not used anymore)
        const generationProvider = document.getElementById('generation-provider-top');
        const generationId = document.getElementById('generation-id-top');
        const elapsedTime = document.getElementById('elapsed-time-top');

        // ========== Segmented Progress Bar Config ==========
        const TOTAL_SEGMENTS = 24; // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏µ‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        let segmentElements = []; // ‡πÄ‡∏Å‡πá‡∏ö DOM elements ‡∏Ç‡∏≠‡∏á segments (main)
        let segmentElementsMini = []; // ‡πÄ‡∏Å‡πá‡∏ö DOM elements ‡∏Ç‡∏≠‡∏á segments (mini)
        const segmentedProgressContainer = document.getElementById('segmented-progress-container');
        const segmentedProgressMini = document.getElementById('segmented-progress-mini');

        /**
         * ‡∏™‡∏£‡πâ‡∏≤‡∏á 24 segments ‡πÉ‡∏ô progress bar
         * ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ï‡∏≠‡∏ô DOMContentLoaded
         */
        function initSegmentedProgressBar() {
            if (!segmentedProgressContainer) {
                console.warn('‚ö†Ô∏è Segmented progress container not found');
                return;
            }

            // Clear existing segments (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            segmentedProgressContainer.innerHTML = '';
            segmentElements = [];

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á 24 segments
            for (let i = 0; i < TOTAL_SEGMENTS; i++) {
                const segment = document.createElement('div');
                segment.className = 'progress-segment inactive';
                segment.dataset.index = i; // ‡πÄ‡∏Å‡πá‡∏ö index ‡πÑ‡∏ß‡πâ debug

                segmentedProgressContainer.appendChild(segment);
                segmentElements.push(segment);
            }

            console.log(`‚úÖ Segmented Progress Bar initialized (${TOTAL_SEGMENTS} segments)`);
        }

        /**
         * ‡∏™‡∏£‡πâ‡∏≤‡∏á 24 segments ‡πÉ‡∏ô mini progress bar (History Panel)
         * ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ï‡∏≠‡∏ô DOMContentLoaded
         */
        function initMiniProgressBar() {
            if (!segmentedProgressMini) {
                console.warn('‚ö†Ô∏è Mini progress container not found');
                return;
            }

            // Clear existing segments (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            segmentedProgressMini.innerHTML = '';
            segmentElementsMini = [];

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á 24 segments
            for (let i = 0; i < TOTAL_SEGMENTS; i++) {
                const segment = document.createElement('div');
                segment.className = 'progress-segment-mini inactive';
                segment.dataset.index = i;

                segmentedProgressMini.appendChild(segment);
                segmentElementsMini.push(segment);
            }

            console.log(`‚úÖ Mini Progress Bar initialized (${TOTAL_SEGMENTS} segments)`);
        }

        /**
         * ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï progress bar ‡πÅ‡∏ö‡∏ö segmented
         * @param {number} progressPercent - ‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå (0-100)
         * @param {string} statusClass - CSS class ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ (e.g., 'status-in-progress')
         */
        function updateSegmentedProgress(progressPercent, statusClass = '') {
            if (segmentElements.length === 0) return;

            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô segments ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á active
            const activeCount = Math.floor((progressPercent / 100) * TOTAL_SEGMENTS);

            // Remove all status classes first
            const statusClasses = ['status-pending', 'status-created', 'status-in-queue',
                'status-in-progress', 'status-processing', 'status-starting',
                'status-completed', 'status-succeeded', 'status-failed', 'status-canceled'];

            // Update ‡πÅ‡∏ï‡πà‡∏•‡∏∞ segment
            segmentElements.forEach((segment, i) => {
                if (i < activeCount) {
                    // Segment ‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡∏¥‡∏°‡πÅ‡∏•‡πâ‡∏ß
                    segment.classList.remove('inactive', ...statusClasses);
                    segment.classList.add('active');

                    // Add status-specific color class
                    if (statusClass) {
                        segment.classList.add(statusClass);
                    }

                    // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô segment ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡πÄ‡∏ï‡∏¥‡∏° ‚Üí ‡πÄ‡∏û‡∏¥‡πà‡∏° pulse animation
                    if (i === activeCount - 1) {
                        segment.classList.add('current');
                    } else {
                        segment.classList.remove('current');
                    }
                } else {
                    // Segment ‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ï‡∏¥‡∏°
                    segment.classList.remove('active', 'current', ...statusClasses);
                    segment.classList.add('inactive');
                }
            });

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠ progress ‡∏ñ‡∏∂‡∏á 100% ‚Üí trigger glitch effect
            if (progressPercent === 100) {
                segmentElements.forEach(segment => {
                    if (segment.classList.contains('active')) {
                        segment.classList.add('glitch');
                        setTimeout(() => segment.classList.remove('glitch'), 300);
                    }
                });
            }

            // ========== Sync Mini Progress Bar ==========
            if (segmentElementsMini.length > 0) {
                segmentElementsMini.forEach((segment, i) => {
                    if (i < activeCount) {
                        segment.classList.remove('inactive', ...statusClasses);
                        segment.classList.add('active');
                        if (statusClass) {
                            segment.classList.add(statusClass);
                        }
                        if (i === activeCount - 1) {
                            segment.classList.add('current');
                        } else {
                            segment.classList.remove('current');
                        }
                    } else {
                        segment.classList.remove('active', 'current', ...statusClasses);
                        segment.classList.add('inactive');
                    }
                });

                // Glitch effect for mini bar
                if (progressPercent === 100) {
                    segmentElementsMini.forEach(segment => {
                        if (segment.classList.contains('active')) {
                            segment.classList.add('glitch');
                            setTimeout(() => segment.classList.remove('glitch'), 300);
                        }
                    });
                }
            }
        }

        // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å init functions ‡∏ï‡∏≠‡∏ô‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤
        document.addEventListener('DOMContentLoaded', () => {
            initSegmentedProgressBar();
            initMiniProgressBar();
        });

        // ========== END: Top Button & Progress Elements ==========
        const videoHistory = document.getElementById('video-history');
        const videoModal = document.getElementById('video-modal');
        const modalVideoPlayer = document.getElementById('modal-video-player');
        const modalVideoInfo = document.getElementById('modal-video-info');
        const closeModalBtn = document.getElementById('close-modal');
        const imageModal = document.getElementById('image-modal');
        const modalImageFull = document.getElementById('modal-image-full');
        const closeImageModalBtn = document.getElementById('close-image-modal');
        const i2vCard = document.getElementById('i2v-card');
        const wavespeedCostSection = document.getElementById('wavespeed-cost-section');
        const wavespeedCost = document.getElementById('wavespeed-cost');

        // API Stats Elements
        const creditBalance = document.getElementById('credit_balance');

        // --- State ---
        // ========== ‚úÖ PERFORMANCE FIX: Centralized State Management ==========
        // Consolidates 20+ scattered variables into single object for easier debugging
        const AppState = {
            generation: {
                id: null,                    // currentGenerationId
                provider: 'wavespeed',       // currentProvider
                pollingUrl: null,            // currentPollingUrl
                pollingLoop: null,           // pollingLoop (consolidated interval)
                startTime: null,             // startTime
                isPolling: false,            // isPolling guard flag
                abortController: null        // ‚úÖ PERFORMANCE FIX: Request cancellation
            },
            media: {
                imageBase64: null,           // imageBase64Data (set later)
                lastImageBase64: null,       // lastImageBase64Data (set later)
                currentVideo: {
                    file: null,              // currentVideoFile (set later)
                    url: null,               // currentVideoUrl (set later)
                    base64: null             // currentVideoBase64 (set later)
                }
            },
            ui: {
                selectedAspectRatio: "16:9"  // selectedAspectRatio
            },
            history: {
                videos: [],                  // videoHistoryData
                currentData: null            // currentVideoData
            }
        };

        // Backwards compatibility aliases (will be migrated gradually)
        let currentGenerationId = null;      // ‚Üí AppState.generation.id
        let currentProvider = 'wavespeed';   // ‚Üí AppState.generation.provider
        let currentPollingUrl = null;        // ‚Üí AppState.generation.pollingUrl
        let pollingLoop = null;              // ‚Üí AppState.generation.pollingLoop
        let startTime = null;                // ‚Üí AppState.generation.startTime
        let videoHistoryData = [];           // ‚Üí AppState.history.videos
        let completedVideosData = [];        // ‚Üí Only completed videos (for modal index mapping)
        let renderingId = 0;                 // ‚Üí Counter for renderVideoHistory() call tracking (race condition prevention)
        let currentVideoData = null;         // ‚Üí AppState.history.currentData
        let selectedAspectRatio = "16:9";    // ‚Üí AppState.ui.selectedAspectRatio
        let isPolling = false;               // ‚Üí AppState.generation.isPolling

        // ========== Prompt Craft State Tracking ==========
        let lastCraftedPrompt = '';          // ‡πÄ‡∏Å‡πá‡∏ö prompt ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å craft
        let promptWasCrafted = false;        // Flag ‡∏ß‡πà‡∏≤ prompt ‡∏ñ‡∏π‡∏Å craft ‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
        let promptWasManuallyEdited = false; // Flag ‡∏ß‡πà‡∏≤ prompt ‡∏ñ‡∏π‡∏Å‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏î‡πâ‡∏ß‡∏¢‡∏°‡∏∑‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        let lastUsedPromptForGeneration = ''; // Track the exact prompt used in last video generation

        // Debug helper: Log entire app state (useful for debugging)
        window.debugAppState = () => {
            console.log('üìä VIDIST App State:', JSON.stringify(AppState, null, 2));
            console.log('Legacy aliases still active - use AppState directly for cleaner code');
        };
        console.log('‚úÖ Centralized state initialized. Run debugAppState() to inspect.');
        // ========== End of Centralized State ==========

        // ========== REMOVED: Old Task Input Map System ==========
        // Now using TaskPersistence with 'vidist_task_inputs_v2' storage key
        // Migration from old system happens automatically at line 3008
        // ==========================================================

        // ========== START: Smart Storage Management System ==========
        const STORAGE_LIMITS = {
            TASK_INPUT_MAP_MAX: 50,      // ‡∏•‡∏î‡∏à‡∏≤‡∏Å 200 ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 50 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î storage
            VIDEO_HISTORY_MAX: 30,        // ‡∏•‡∏î‡∏à‡∏≤‡∏Å 50 ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 30
            STORAGE_WARNING_THRESHOLD: 0.8 // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÑ‡∏õ 80%
        };

        // ========== ‚úÖ PERFORMANCE FIX: Cached localStorage size calculation ==========
        let cachedLocalStorageSize = null;

        // Calculate actual localStorage size (expensive operation)
        function calculateLocalStorageSize() {
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += localStorage[key].length + key.length;
                }
            }
            return total; // bytes
        }

        // Get localStorage size (returns cached value if available)
        function getLocalStorageSize() {
            if (cachedLocalStorageSize === null) {
                cachedLocalStorageSize = calculateLocalStorageSize();
            }
            return cachedLocalStorageSize;
        }

        // Invalidate cache when localStorage changes
        function invalidateLocalStorageCache() {
            cachedLocalStorageSize = null;
        }
        // ========== End of Cached localStorage ==========

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î localStorage ‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞
        function smartCleanupStorage() {
            console.log('üßπ Starting silent storage cleanup...');

            try {
                // 1. ‡∏•‡∏ö image cache ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
                localStorage.removeItem(IMAGE_CACHE_KEY);
                console.log('‚úÖ Removed image cache');

                // 2. ‡πÄ‡∏Å‡πá‡∏ö videoHistory ‡πÅ‡∏Ñ‡πà 10 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏•‡∏î‡∏à‡∏≤‡∏Å 15 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà)
                const storedHistory = localStorage.getItem('videoHistory');
                if (storedHistory) {
                    try {
                        const history = JSON.parse(storedHistory);
                        if (Array.isArray(history) && history.length > 10) {
                            const recentHistory = history.slice(0, 10);
                            localStorage.setItem('videoHistory', JSON.stringify(recentHistory));
                            videoHistoryData = recentHistory;
                            console.log(`‚úÖ Reduced videoHistory to ${recentHistory.length} items`);
                        }
                    } catch (e) {
                        localStorage.removeItem('videoHistory');
                        console.log('‚úÖ Removed corrupted videoHistory');
                    }
                }

                // 3. REMOVED: Old taskInputMap cleanup (now using TaskPersistence with 7-day retention)

                // 4. ‡∏•‡∏ö prompt cache ‡πÄ‡∏Å‡πà‡∏≤
                localStorage.removeItem('vidist_last_prompt');
                localStorage.removeItem('vidist_last_negative_prompt');
                console.log('‚úÖ Removed old prompt cache');

                // ‚úÖ PERFORMANCE FIX: Invalidate cache to force recalculation after cleanup
                invalidateLocalStorageCache();
                const sizeAfter = getLocalStorageSize();
                console.log(`‚úÖ Storage cleanup complete. Size: ${(sizeAfter / 1024).toFixed(2)}KB`);

                return true;
            } catch (error) {
                console.error('‚ùå Storage cleanup error:', error);
                return false;
            }
        }

        // ‚ú® NEW (v2.9.0): Proactive storage check and cleanup
        function checkStorageAndCleanup() {
            try {
                const currentSize = getLocalStorageSize();
                const maxSize = 5 * 1024 * 1024; // 5MB estimate
                const usagePercent = (currentSize / maxSize) * 100;

                console.log(`üìä Storage usage: ${(currentSize / 1024).toFixed(2)}KB (${usagePercent.toFixed(1)}%)`);

                // If over 80% full, do proactive cleanup
                if (usagePercent > 80) {
                    console.warn('‚ö†Ô∏è Storage over 80% full - performing proactive cleanup');

                    // üõ°Ô∏è v2.12.17: Protect Grok videos during proactive cleanup
                    if (videoHistoryData && videoHistoryData.length > 15) {
                        const grokVideos = videoHistoryData.filter(h => h.provider === 'grok' && h.status === 'completed');
                        const otherVideos = videoHistoryData.filter(h => h.provider !== 'grok');
                        const reducedHistory = [...grokVideos, ...otherVideos.slice(0, 15)];
                        videoHistoryData = reducedHistory;
                        try {
                            localStorage.setItem('videoHistory', JSON.stringify(reducedHistory));
                            console.log(`üõ°Ô∏è Protected ${grokVideos.length} Grok videos, reduced others to 15 items`);
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Proactive cleanup save failed (quota still exceeded)');
                        }
                    }

                    // Also run smart cleanup
                    smartCleanupStorage();
                    return true;
                }

                return false; // No cleanup needed
            } catch (e) {
                console.error('Error checking storage:', e);
                return false;
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (auto-cleanup SILENT - ‡πÑ‡∏°‡πà‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô)
        function safeSetLocalStorage(key, value) {
            // ‚ú® NEW (v2.9.0): Proactive check before saving
            if (key === 'videoHistory' && value.length > 100000) {
                // If saving large data (>100KB), check storage first
                checkStorageAndCleanup();
            }

            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
            const dataSizeKB = (value.length / 1024).toFixed(2);

            try {
                localStorage.setItem(key, value);
                invalidateLocalStorageCache(); // ‚úÖ PERFORMANCE FIX: Invalidate cache after write
                return true;
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.log(`üîÑ localStorage quota exceeded for key "${key}" (${dataSizeKB}KB), auto-cleaning silently...`);

                    // ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà (‡πÑ‡∏°‡πà‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô)
                    if (smartCleanupStorage()) {
                        invalidateLocalStorageCache(); // ‚úÖ Cache invalidated by cleanup
                        try {
                            localStorage.setItem(key, value);
                            invalidateLocalStorageCache(); // ‚úÖ Cache invalidated by write
                            console.log(`‚úÖ Saved after cleanup: ${key} (${dataSizeKB}KB)`);
                            return true;
                        } catch (retryError) {
                            // ‡∏•‡∏≠‡∏á‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÅ‡∏ö‡∏ö aggressive - ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡πà‡∏≤‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°
                            console.log('üîÑ First cleanup not enough, trying aggressive cleanup...');

                            // üõ°Ô∏è v2.12.14: NEVER delete Grok videos
                            const grokVideos = videoHistoryData.filter(h => h.provider === 'grok' && h.status === 'completed');
                            const otherVideos = videoHistoryData.filter(h => h.provider !== 'grok');
                            const keepRecent = [...grokVideos, ...otherVideos.slice(0, 5)];
                            localStorage.removeItem('videoHistory');
                            videoHistoryData = keepRecent;
                            console.log(`üìä Aggressive cleanup: protected ${grokVideos.length} Grok videos, kept ${otherVideos.slice(0, 5).length} others`);

                            // ‡∏•‡∏ö attached image/video ‡πÄ‡∏Å‡πà‡∏≤
                            localStorage.removeItem(ATTACHED_IMAGE_STORAGE_KEY);
                            localStorage.removeItem('vidist_attached_video');

                            // ‡∏•‡∏ö Keep prompts ‡πÄ‡∏Å‡πà‡∏≤
                            localStorage.removeItem('vidist_keep_prompts');

                            console.log('‚úÖ Aggressive cleanup completed');

                            try {
                                localStorage.setItem(key, value);
                                invalidateLocalStorageCache();
                                console.log(`‚úÖ Saved after aggressive cleanup: ${key} (${dataSizeKB}KB)`);
                                return true;
                            } catch (finalError) {
                                // ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡∏Å‡πá‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ ‡πÑ‡∏°‡πà‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÄ‡∏•‡∏¢ (SILENT MODE)
                                console.log(`‚ÑπÔ∏è Could not save ${key} - data too large, skipping silently`);
                                return false;
                            }
                        }
                    }
                }
                console.error('‚ùå localStorage.setItem error:', error);
                return false;
            }
        }
        // ========== END: Smart Storage Management System ==========

        // ========== KEEP: Prompt Collection System ==========
        const KEEP_STORAGE_KEY = 'vidist_keep_prompts';
        const KEEP_MAX_ITEMS = 50;
        let keepPrompts = [];

        // Load from localStorage
        function loadKeepPrompts() {
            try {
                const stored = localStorage.getItem(KEEP_STORAGE_KEY);
                keepPrompts = stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('‚ùå Failed to load keep prompts:', e);
                keepPrompts = [];
            }
            renderKeepList();
            updateKeepCount();
        }

        // Save to localStorage
        function saveKeepPrompts() {
            // Limit to max items (remove oldest)
            if (keepPrompts.length > KEEP_MAX_ITEMS) {
                keepPrompts = keepPrompts.slice(-KEEP_MAX_ITEMS);
            }
            safeSetLocalStorage(KEEP_STORAGE_KEY, JSON.stringify(keepPrompts));
            updateKeepCount();
        }

        // Normalize text for comparison (collapse whitespace)
        function normalizeTextForCompare(text) {
            return text
                .trim()
                .replace(/\s+/g, ' ')  // Collapse multiple spaces/tabs/newlines to single space
                .toLowerCase();         // Case-insensitive comparison
        }

        // Show duplicate notification
        function showKeepDuplicateNotice() {
            const container = document.getElementById('keep-section');
            if (!container) return;

            // Remove existing notice if any
            const existing = container.querySelector('.keep-duplicate-notice');
            if (existing) existing.remove();

            // Create notice element
            const notice = document.createElement('div');
            notice.className = 'keep-duplicate-notice text-xs text-yellow-400 bg-yellow-500/10 border border-yellow-500/30 rounded-lg px-3 py-2 mb-3 flex items-center gap-2';
            notice.innerHTML = `
                <svg class="w-4 h-4 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                <span>Prompt ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß</span>
            `;

            // Insert at top of section
            const firstChild = container.querySelector('.mb-3');
            if (firstChild) {
                firstChild.parentNode.insertBefore(notice, firstChild);
            }

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notice.style.opacity = '0';
                notice.style.transition = 'opacity 0.3s ease';
                setTimeout(() => notice.remove(), 300);
            }, 3000);
        }

        // Add new prompt
        function addKeepPrompt(promptText) {
            if (!promptText || !promptText.trim()) return;

            // Clear any copy state when adding new prompt
            clearKeepCopyState();

            const trimmedText = promptText.trim();
            const normalizedNew = normalizeTextForCompare(trimmedText);

            // Check for duplicates (normalized comparison)
            const isDuplicate = keepPrompts.some(p =>
                normalizeTextForCompare(p.text) === normalizedNew
            );

            if (isDuplicate) {
                console.log('‚ö†Ô∏è Keep: Duplicate prompt detected, skipping');
                showKeepDuplicateNotice();
                return;
            }

            keepPrompts.push({
                id: Date.now(),
                text: trimmedText,
                createdAt: new Date().toISOString()
            });
            saveKeepPrompts();
            renderKeepList();
            console.log('üíñ Keep: Added new prompt');
        }

        // Track currently copied card for visual feedback
        let keepCopiedCardId = null;

        // Clear copy state (restore opacity)
        function clearKeepCopyState() {
            if (keepCopiedCardId !== null) {
                const prevCard = document.querySelector(`.keep-card[data-id="${keepCopiedCardId}"]`);
                if (prevCard) {
                    const textEl = prevCard.querySelector('.keep-text');
                    if (textEl) textEl.style.opacity = '1';
                }
                keepCopiedCardId = null;
            }
        }

        // Delete prompt (no confirmation)
        function deleteKeepPrompt(id) {
            clearKeepCopyState();
            keepPrompts = keepPrompts.filter(p => p.id !== id);
            saveKeepPrompts();
            renderKeepList();
            console.log('üóëÔ∏è Keep: Deleted prompt');
        }

        // Copy to clipboard with visual feedback (dim the card text)
        async function copyKeepPrompt(id, buttonEl) {
            const prompt = keepPrompts.find(p => p.id === id);
            if (prompt) {
                try {
                    await navigator.clipboard.writeText(prompt.text);

                    // Clear previous copy state
                    clearKeepCopyState();

                    // Find the card and dim its text
                    const card = buttonEl.closest('.keep-card');
                    if (card) {
                        const textEl = card.querySelector('.keep-text');
                        if (textEl) {
                            textEl.style.opacity = '0.5';
                            keepCopiedCardId = id;
                        }
                    }

                    console.log('üìã Keep: Copied to clipboard');
                } catch (e) {
                    console.error('‚ùå Keep: Failed to copy:', e);
                }
            }
        }

        // Reuse: send to main prompt textarea
        function reuseKeepPrompt(id) {
            clearKeepCopyState();
            const prompt = keepPrompts.find(p => p.id === id);
            if (prompt) {
                const promptTextarea = document.getElementById('prompt');
                if (promptTextarea) {
                    promptTextarea.value = prompt.text;
                    promptTextarea.dispatchEvent(new Event('input'));
                    savePromptToStorage();
                    console.log('üîÑ Keep: Reused prompt');
                }
            }
        }

        // Toggle card expansion
        function toggleKeepCard(cardEl) {
            clearKeepCopyState();
            const textEl = cardEl.querySelector('.keep-text');
            if (textEl) {
                textEl.classList.toggle('line-clamp-3');
                textEl.classList.toggle('expanded');
            }
        }

        // HTML escape utility
        function escapeHtmlKeep(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Render keep list (3-column grid)
        function renderKeepList() {
            const container = document.getElementById('keep-list');
            if (!container) return;

            if (keepPrompts.length === 0) {
                container.classList.add('empty');
                container.innerHTML = '<p class="text-xs text-gray-500 text-center py-4 col-span-3">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ prompt ‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</p>';
                return;
            }

            container.classList.remove('empty');

            // Render in reverse order (newest first) - 3 column grid
            container.innerHTML = keepPrompts.slice().reverse().map(p => `
                <div class="keep-card group bg-gray-900/50 rounded-lg p-2 border border-gray-700/30 hover:border-pink-500/30 cursor-pointer"
                     data-id="${p.id}" onclick="toggleKeepCard(this)">
                    <p class="keep-text text-xs text-gray-300 line-clamp-3 leading-relaxed transition-opacity">${escapeHtmlKeep(p.text)}</p>
                    <div class="flex gap-1 mt-2 opacity-0 group-hover:opacity-100 transition-opacity">
                        <button onclick="event.stopPropagation(); copyKeepPrompt(${p.id}, this)"
                            class="text-xs px-1.5 py-0.5 rounded bg-cyan-500/20 text-cyan-400 hover:bg-cyan-500/30 transition-colors">Copy</button>
                        <button onclick="event.stopPropagation(); reuseKeepPrompt(${p.id})"
                            class="text-xs px-1.5 py-0.5 rounded bg-purple-500/20 text-purple-400 hover:bg-purple-500/30 transition-colors">Reuse</button>
                        <button onclick="event.stopPropagation(); deleteKeepPrompt(${p.id})"
                            class="text-xs px-1.5 py-0.5 rounded bg-red-500/20 text-red-400 hover:bg-red-500/30 transition-colors">Del</button>
                    </div>
                </div>
            `).join('');
        }

        // Update count badge
        function updateKeepCount() {
            const countEl = document.getElementById('keep-count');
            if (countEl) {
                countEl.textContent = `(${keepPrompts.length})`;
            }
        }

        // Initialize Keep section
        function initKeepSection() {
            const toggleBtn = document.getElementById('toggle-keep-section');
            const section = document.getElementById('keep-section');
            const chevron = document.getElementById('keep-chevron');
            const addBtn = document.getElementById('keep-add-btn');
            const newPromptInput = document.getElementById('keep-new-prompt');

            // Toggle section visibility
            if (toggleBtn && section && chevron) {
                toggleBtn.addEventListener('click', () => {
                    section.classList.toggle('hidden');
                    chevron.classList.toggle('rotate-180');
                });
            }

            // Add button click
            if (addBtn && newPromptInput) {
                addBtn.addEventListener('click', () => {
                    addKeepPrompt(newPromptInput.value);
                    newPromptInput.value = '';
                });
            }

            // Auto-save on blur (focus out)
            if (newPromptInput) {
                newPromptInput.addEventListener('blur', () => {
                    if (newPromptInput.value.trim()) {
                        addKeepPrompt(newPromptInput.value);
                        newPromptInput.value = '';
                    }
                });
            }

            // Clear copy state when clicking outside keep section
            document.addEventListener('click', (e) => {
                const keepSection = document.getElementById('keep-section');
                const keepToggle = document.getElementById('toggle-keep-section');
                if (keepSection && keepToggle) {
                    if (!keepSection.contains(e.target) && !keepToggle.contains(e.target)) {
                        clearKeepCopyState();
                    }
                }
            });

            // Load saved prompts
            loadKeepPrompts();
            console.log('üíñ Keep: System initialized');
        }
        // ========== END: KEEP System ==========

        // ========== DEPRECATED: Old saveTaskInput/getTaskInput removed ==========
        // Now using TaskPersistence system (see lines 2915-2962)
        // Old taskInputMap approach had 30-50 item limit causing prompt loss
        // ==========================================================================

        // ========== NEW: Capture Prompt Craft Data ==========
        /**
         * ‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Prompt Craft ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô history
         * @returns {Object} CraftData object
         */
        function captureCraftData() {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÉ‡∏ä‡πâ Prompt Craft ‡∏´‡∏£‡∏∑‡∏≠‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏≠‡∏á
            if (!promptWasCrafted) {
                // Manual prompt - ‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏Ñ‡πà flag
                return {
                    isManualPrompt: true,
                    craftInput: null,
                    intensityLevel: null,
                    redModeEnabled: null,
                    promptLanguage: null,
                    customDialogEnabled: false,
                    customDialogText: null,
                    muteAudioEnabled: false,
                    craftedAt: null
                };
            }

            // Prompt Craft - ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
            const craftInput = document.getElementById('prompt-craft-input')?.value || '';
            const intensityRadio = document.querySelector('input[name="intensity-level"]:checked');
            const intensityLevel = intensityRadio ? parseInt(intensityRadio.value) : 3;
            const redModeEnabled = localStorage.getItem('red_mode_enabled') === 'true';
            const promptLanguage = localStorage.getItem('prompt_language') || 'en';

            const customDialogCheckbox = document.getElementById('custom-dialog-checkbox');
            const customDialogInput = document.getElementById('custom-dialog-input');
            const customDialogEnabled = customDialogCheckbox?.checked || false;
            const customDialogText = customDialogEnabled ? (customDialogInput?.value || '') : null;

            const muteAudioCheckbox = document.getElementById('mute-audio-checkbox');
            const muteAudioEnabled = muteAudioCheckbox?.checked || false;

            return {
                isManualPrompt: false,
                craftInput: craftInput,
                intensityLevel: intensityLevel,
                redModeEnabled: redModeEnabled,
                promptLanguage: promptLanguage,
                customDialogEnabled: customDialogEnabled,
                customDialogText: customDialogText,
                muteAudioEnabled: muteAudioEnabled,
                craftedAt: new Date().toISOString()
            };
        }
        // ========== END: Capture Prompt Craft Data ==========

        // ========== END: Task Input Map System ==========

        // ========== START: Media State (Managed by AppState) ==========
        // ‚úÖ PERFORMANCE FIX: These are backwards compatibility aliases
        // Actual state is in AppState.media (defined above)
        let imageBase64Data = null;          // ‚Üí AppState.media.imageBase64
        let lastImageBase64Data = null;      // ‚Üí AppState.media.lastImageBase64
        let currentVideoFile = null;         // ‚Üí AppState.media.currentVideo.file
        let currentVideoUrl = null;          // ‚Üí AppState.media.currentVideo.url
        let currentVideoBase64 = null;       // ‚Üí AppState.media.currentVideo.base64
        // ========== END: Media State ==========

        // ========== START: LRU Cache System with 300MB Limit ==========
        class LRUCache {
            constructor(maxSize = 300 * 1024 * 1024) { // 300MB in bytes
                this.maxSize = maxSize;
                this.currentSize = 0;
                this.cache = new Map(); // Map<videoId, {blobUrl, size, timestamp}>
            }

            async get(key) {
                if (!key || !this.cache.has(key)) {
                    console.log('‚ö†Ô∏è Cache MISS:', key);
                    return null;
                }

                // Move to end (most recently used)
                const value = this.cache.get(key);
                this.cache.delete(key);
                this.cache.set(key, value);

                console.log('‚úÖ Cache HIT:', key);
                return value.blobUrl;
            }

            async set(key, blobUrl, size) {
                if (!key || !blobUrl) return;

                // Remove existing entry if present
                if (this.cache.has(key)) {
                    const oldValue = this.cache.get(key);
                    this.currentSize -= oldValue.size;
                    this.cache.delete(key);
                }

                // Evict oldest entries until space available
                while (this.currentSize + size > this.maxSize && this.cache.size > 0) {
                    const oldestKey = this.cache.keys().next().value;
                    const oldestValue = this.cache.get(oldestKey);

                    // Revoke blob URL to free memory
                    if (oldestValue.blobUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(oldestValue.blobUrl);
                    }

                    this.currentSize -= oldestValue.size;
                    this.cache.delete(oldestKey);

                    console.log(`üóëÔ∏è LRU Evicted: ${oldestKey} (${(oldestValue.size / 1024 / 1024).toFixed(2)}MB)`);
                }

                // Add new entry if it fits
                if (this.currentSize + size <= this.maxSize) {
                    this.cache.set(key, {
                        blobUrl,
                        size,
                        timestamp: Date.now()
                    });
                    this.currentSize += size;

                    const stats = this.getStats();
                    console.log(`üíæ Cached: ${key} (${(size / 1024 / 1024).toFixed(2)}MB) | Total: ${stats.currentSizeMB}MB / ${stats.maxSizeMB}MB (${stats.usagePercent}%)`);
                } else {
                    console.warn(`‚ö†Ô∏è Video too large to cache: ${key} (${(size / 1024 / 1024).toFixed(2)}MB exceeds ${(this.maxSize / 1024 / 1024).toFixed(2)}MB)`);
                }
            }

            clear() {
                // Revoke all blob URLs to prevent memory leaks
                for (const [key, value] of this.cache.entries()) {
                    if (value.blobUrl.startsWith('blob:')) {
                        URL.revokeObjectURL(value.blobUrl);
                    }
                }
                this.cache.clear();
                this.currentSize = 0;
                console.log('üßπ LRU Cache cleared');
            }

            getStats() {
                return {
                    count: this.cache.size,
                    currentSize: this.currentSize,
                    maxSize: this.maxSize,
                    currentSizeMB: (this.currentSize / 1024 / 1024).toFixed(2),
                    maxSizeMB: (this.maxSize / 1024 / 1024).toFixed(2),
                    usagePercent: ((this.currentSize / this.maxSize) * 100).toFixed(2)
                };
            }
        }

        const videoCache = new LRUCache(300 * 1024 * 1024); // 300MB limit

        // Legacy wrapper functions for backward compatibility
        async function getCachedVideo(videoId) {
            return await videoCache.get(videoId);
        }

        function cacheVideo(videoId, blobUrl, size = 0) {
            return videoCache.set(videoId, blobUrl, size);
        }

        function clearVideoCache() {
            videoCache.clear();
        }
        // ========== END: LRU Cache System ==========

        // ========== START: IndexedDB Persistent Cache ==========
        let videoDB = null;
        const DB_NAME = 'VIDISTCache';
        const DB_VERSION = 1;
        const STORE_NAME = 'videos';

        // Initialize IndexedDB
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('‚ùå IndexedDB error:', request.error);
                    reject(request.error);
                };

                request.onsuccess = (event) => {
                    videoDB = event.target.result;
                    console.log('‚úÖ IndexedDB initialized');
                    resolve(videoDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Create object store if doesn't exist
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                        objectStore.createIndex('provider', 'provider', { unique: false });
                        console.log('‚úÖ IndexedDB object store created');
                    }
                };
            });
        }

        // Save video to IndexedDB
        async function cacheToDB(id, blob, metadata = {}) {
            if (!videoDB) {
                console.warn('‚ö†Ô∏è IndexedDB not initialized');
                return;
            }

            try {
                const transaction = videoDB.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);

                const data = {
                    id,
                    blob,
                    size: blob.size,
                    timestamp: Date.now(),
                    provider: metadata.provider || 'unknown',
                    ...metadata
                };

                const request = objectStore.put(data);

                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        console.log(`üíæ IndexedDB: Saved ${id} (${(blob.size / 1024 / 1024).toFixed(2)}MB)`);
                        resolve();
                    };
                    request.onerror = () => {
                        console.error('‚ùå IndexedDB save error:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.warn('‚ö†Ô∏è IndexedDB quota exceeded, cleaning...');
                    await cleanExpiredCache();
                    // Retry once
                    try {
                        return await cacheToDB(id, blob, metadata);
                    } catch (retryError) {
                        console.error('‚ùå Failed to cache even after cleanup:', retryError);
                    }
                } else {
                    console.error('‚ùå IndexedDB error:', error);
                }
            }
        }

        // Get video from IndexedDB
        async function getFromDB(id) {
            if (!videoDB) {
                return null;
            }

            try {
                const transaction = videoDB.transaction([STORE_NAME], 'readonly');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.get(id);

                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        if (request.result) {
                            console.log(`‚úÖ IndexedDB: Retrieved ${id} (${(request.result.size / 1024 / 1024).toFixed(2)}MB)`);
                            resolve(request.result);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => {
                        console.error('‚ùå IndexedDB read error:', request.error);
                        resolve(null);
                    };
                });
            } catch (error) {
                console.error('‚ùå IndexedDB error:', error);
                return null;
            }
        }

        // Clean expired cache (older than 24 hours)
        async function cleanExpiredCache() {
            if (!videoDB) {
                return;
            }

            const MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
            const now = Date.now();
            let deletedCount = 0;
            let freedSpace = 0;

            try {
                const transaction = videoDB.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.openCursor();

                return new Promise((resolve) => {
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const data = cursor.value;
                            const age = now - data.timestamp;

                            if (age > MAX_AGE) {
                                cursor.delete();
                                deletedCount++;
                                freedSpace += data.size || 0;
                                console.log(`üóëÔ∏è Cleaned expired: ${data.id} (age: ${(age / 1000 / 60 / 60).toFixed(1)}h)`);
                            }
                            cursor.continue();
                        } else {
                            if (deletedCount > 0) {
                                console.log(`üßπ Auto-clean completed: ${deletedCount} videos, ${(freedSpace / 1024 / 1024).toFixed(2)}MB freed`);
                            } else {
                                console.log('‚úÖ No expired videos to clean');
                            }
                            resolve({ deletedCount, freedSpace });
                        }
                    };

                    request.onerror = () => {
                        console.error('‚ùå Clean cache error:', request.error);
                        resolve({ deletedCount: 0, freedSpace: 0 });
                    };
                });
            } catch (error) {
                console.error('‚ùå Clean cache error:', error);
                return { deletedCount: 0, freedSpace: 0 };
            }
        }

        // Clear all IndexedDB cache
        async function clearIndexedDBCache() {
            if (!videoDB) {
                return;
            }

            try {
                const transaction = videoDB.transaction([STORE_NAME], 'readwrite');
                const objectStore = transaction.objectStore(STORE_NAME);
                const request = objectStore.clear();

                return new Promise((resolve) => {
                    request.onsuccess = () => {
                        console.log('üßπ IndexedDB cache cleared');
                        resolve();
                    };
                    request.onerror = () => {
                        console.error('‚ùå Clear IndexedDB error:', request.error);
                        resolve();
                    };
                });
            } catch (error) {
                console.error('‚ùå Clear IndexedDB error:', error);
            }
        }
        // ========== END: IndexedDB Persistent Cache ==========

        // ========== GROK PERSISTENCE SYSTEM v2.12.14 ==========
        const GROK_DB_NAME = 'VIDISTGrokPersistence';
        const GROK_STORE_NAME = 'grok-videos';
        const GROK_METADATA_STORE = 'grok-metadata';
        let grokDB = null;

        async function initGrokDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(GROK_DB_NAME, 1);

                request.onerror = () => reject(request.error);

                request.onsuccess = () => {
                    grokDB = request.result;
                    console.log('‚úÖ Grok IndexedDB initialized');
                    resolve(grokDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    // Store 1: Completed videos
                    if (!db.objectStoreNames.contains(GROK_STORE_NAME)) {
                        const videoStore = db.createObjectStore(GROK_STORE_NAME, { keyPath: 'id' });
                        videoStore.createIndex('createdAt', 'createdAt', { unique: false });
                        videoStore.createIndex('status', 'status', { unique: false });
                    }

                    // Store 2: Metadata for recovery
                    if (!db.objectStoreNames.contains(GROK_METADATA_STORE)) {
                        const metaStore = db.createObjectStore(GROK_METADATA_STORE, { keyPath: 'requestId' });
                        metaStore.createIndex('createdAt', 'createdAt', { unique: false });
                    }
                };
            });
        }

        async function saveGrokVideoToIDB(videoData) {
            if (!grokDB) await initGrokDB();

            return new Promise((resolve) => {
                try {
                    const transaction = grokDB.transaction([GROK_STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(GROK_STORE_NAME);

                    const grokVideo = {
                        id: videoData.id,
                        url: videoData.url,
                        prompt: videoData.prompt,
                        duration: videoData.duration,
                        resolution: videoData.resolution,
                        model: videoData.model,
                        createdAt: videoData.createdAt || new Date().toISOString(),
                        status: 'completed',
                        protected: true
                    };

                    const request = store.put(grokVideo);

                    request.onsuccess = () => {
                        console.log('üíæ Saved to Grok IDB:', videoData.id);
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error('‚ùå Grok IDB save failed:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('‚ùå Grok IDB error:', error);
                    resolve(false);
                }
            });
        }

        async function getAllGrokVideos() {
            if (!grokDB) await initGrokDB();

            return new Promise((resolve) => {
                try {
                    const transaction = grokDB.transaction([GROK_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(GROK_STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => {
                        console.error('‚ùå Get all Grok videos failed:', request.error);
                        resolve([]);
                    };
                } catch (error) {
                    console.error('‚ùå Get all Grok error:', error);
                    resolve([]);
                }
            });
        }

        async function saveGrokMetadata(requestId, metadata) {
            if (!grokDB) await initGrokDB();

            return new Promise((resolve) => {
                try {
                    const transaction = grokDB.transaction([GROK_METADATA_STORE], 'readwrite');
                    const store = transaction.objectStore(GROK_METADATA_STORE);

                    const meta = {
                        requestId,
                        ...metadata,
                        savedAt: new Date().toISOString()
                    };

                    const request = store.put(meta);

                    request.onsuccess = () => {
                        console.log('üìù Metadata saved:', requestId);
                        resolve(true);
                    };

                    request.onerror = () => {
                        console.error('‚ùå Metadata save failed:', request.error);
                        resolve(false);
                    };
                } catch (error) {
                    console.error('‚ùå Metadata error:', error);
                    resolve(false);
                }
            });
        }

        async function saveGrokVideoAtomic(videoData) {
            const results = {
                indexedDB: false,
                metadata: false,
                localStorage: false
            };

            try {
                // 1. Save to IndexedDB first (largest capacity)
                results.indexedDB = await saveGrokVideoToIDB(videoData);

                // 2. Save metadata separately
                results.metadata = await saveGrokMetadata(videoData.id, {
                    requestId: videoData.id,
                    prompt: videoData.prompt,
                    videoUrl: videoData.url,
                    config: {
                        duration: videoData.duration,
                        resolution: videoData.resolution
                    },
                    createdAt: videoData.createdAt || new Date().toISOString()
                });

                // 3. Update in-memory videoHistoryData
                const existingIndex = videoHistoryData.findIndex(
                    v => v.id === videoData.id && v.provider === videoData.provider
                );

                if (existingIndex !== -1) {
                    videoHistoryData[existingIndex] = {
                        ...videoHistoryData[existingIndex],
                        ...videoData,
                        status: 'completed'
                    };
                    console.log('‚ú® Updated placeholder with completed video:', videoData.id);
                } else {
                    // Fallback: Add new entry
                    videoHistoryData.unshift(videoData);
                    videoHistoryData = videoHistoryData.slice(0, 50);
                    console.log('‚ûï Added new Grok video to history:', videoData.id);
                }

                // 4. Save to localStorage (best effort)
                try {
                    results.localStorage = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                } catch (e) {
                    console.warn('‚ö†Ô∏è localStorage save failed, but IDB succeeded');
                }

                // 5. Validate at least 2 layers succeeded
                const successCount = Object.values(results).filter(Boolean).length;
                if (successCount < 2) {
                    throw new Error(`Save failed: Only ${successCount}/3 layers succeeded`);
                }

                // 6. Re-render history
                renderVideoHistory();

                // 7. Log success
                console.log('üíæ GROK SAVE SUCCESS:', {
                    id: videoData.id,
                    layers: results,
                    timestamp: new Date().toISOString()
                });

                return true;
            } catch (error) {
                // CRITICAL: Log failure with full data for manual recovery
                console.error('üö® GROK SAVE FAILED:', {
                    error: error.message,
                    results,
                    videoData: {
                        id: videoData.id,
                        url: videoData.url,
                        prompt: videoData.prompt.substring(0, 100)
                    },
                    timestamp: new Date().toISOString()
                });

                // Store in emergency log
                const failures = JSON.parse(localStorage.getItem('vidist_grok_failures') || '[]');
                failures.push({
                    timestamp: new Date().toISOString(),
                    videoData,
                    error: error.message,
                    results
                });
                localStorage.setItem('vidist_grok_failures', JSON.stringify(failures.slice(-20)));

                return false;
            }
        }

        async function recoverGrokVideos() {
            console.log('üîÑ Starting Grok video recovery...');

            const recovered = [];

            // 1. Load from IndexedDB
            const idbVideos = await getAllGrokVideos();
            recovered.push(...idbVideos.map(v => ({ ...v, provider: 'grok', recoveredFrom: 'IndexedDB' })));
            console.log(`üì¶ Recovered ${idbVideos.length} videos from IndexedDB`);

            // 2. Merge with existing localStorage (deduplicate)
            const localVideos = videoHistoryData.filter(v => v.provider === 'grok');
            for (const local of localVideos) {
                if (!recovered.find(v => v.id === local.id)) {
                    recovered.push({ ...local, recoveredFrom: 'localStorage' });
                }
            }

            console.log(`‚úÖ Recovery complete: ${recovered.length} total Grok videos`);
            return recovered;
        }

        async function migrateExistingGrokVideos() {
            if (localStorage.getItem('grok_migration_v12.14_done')) return;

            const existing = videoHistoryData.filter(v => v.provider === 'grok' && v.status === 'completed');
            if (existing.length === 0) {
                localStorage.setItem('grok_migration_v12.14_done', 'true');
                return;
            }

            console.log(`üîÑ Migrating ${existing.length} existing Grok videos to IndexedDB...`);

            for (const video of existing) {
                await saveGrokVideoToIDB(video);
                await saveGrokMetadata(video.id, {
                    requestId: video.id,
                    prompt: video.prompt,
                    videoUrl: video.url,
                    config: {
                        duration: video.duration,
                        resolution: video.resolution
                    },
                    createdAt: video.createdAt || new Date().toISOString()
                });
            }

            localStorage.setItem('grok_migration_v12.14_done', 'true');
            console.log('‚úÖ Migration complete');
        }
        // ========== END GROK PERSISTENCE SYSTEM ==========

        // Pre-load video to cache - UPDATED WITH LRU + IndexedDB
        async function preloadVideoToCache(videoId, videoUrl, provider) {
            if (!videoId || !videoUrl) {
                console.warn('‚ö†Ô∏è preloadVideoToCache: Missing videoId or videoUrl');
                return null;
            }

            // üîß v2.12.13: Skip preload for Grok (no CORS headers - can't fetch)
            // Grok videos will be loaded directly in modal when clicked
            if (provider === 'grok') {
                console.log('‚è≠Ô∏è Skipping preload for Grok video (no CORS support):', videoId);
                return null;
            }

            // Check LRU cache first
            const cached = await getCachedVideo(videoId);
            if (cached) {
                return cached;
            }

            // Check IndexedDB
            const dbEntry = await getFromDB(videoId);
            if (dbEntry && dbEntry.blob) {
                console.log('üì¶ Restored from IndexedDB:', videoId);
                const blobUrl = URL.createObjectURL(dbEntry.blob);
                // Add back to LRU cache
                await videoCache.set(videoId, blobUrl, dbEntry.size);
                return blobUrl;
            }

            console.log('üì• Pre-loading video:', videoId, 'from', provider);

            try {
                // Wavespeed returns direct URLs, no auth needed
                // Fetch to create blob for caching
                const response = await fetch(videoUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const blob = await response.blob();
                const blobUrl = URL.createObjectURL(blob);

                // Cache to LRU and IndexedDB
                await videoCache.set(videoId, blobUrl, blob.size);
                await cacheToDB(videoId, blob, { provider });
                console.log('‚úÖ Wavespeed video pre-loaded:', videoId);
                return blobUrl;
            } catch (error) {
                console.error('‚ùå Error pre-loading video:', videoId, error.message);
                return null;
            }
        }
        // ========== END: Simple In-Memory Video Cache ==========

        // ========== START: Touch Interaction System for History Cards ==========
        // v2.8.0: Two-tap progressive disclosure for mobile history cards
        let activeTouchCard = null;
        let touchStartTime = 0;

        function initHistoryTouchHandlers() {
            const historyContainer = document.getElementById('video-history');
            if (!historyContainer) return;

            // Event delegation for performance
            historyContainer.addEventListener('touchstart', handleHistoryTouchStart, { passive: true });
            historyContainer.addEventListener('click', handleHistoryClick);

            // Close buttons when tapping outside
            document.addEventListener('touchstart', (e) => {
                if (activeTouchCard && !activeTouchCard.contains(e.target)) {
                    deactivateCard(activeTouchCard);
                }
            }, { passive: true });
        }

        function handleHistoryTouchStart(e) {
            touchStartTime = Date.now();
        }

        function handleHistoryClick(e) {
            const card = e.target.closest('.video-thumbnail, .image-thumbnail');
            if (!card) return;

            // Ignore if clicking on a button directly
            if (e.target.closest('button')) return;

            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (!isMobile) return; // Desktop: normal hover behavior

            const touchDuration = Date.now() - touchStartTime;
            if (touchDuration > 500) return; // Ignore long press/scroll

            // First tap: Show buttons
            if (activeTouchCard !== card) {
                if (activeTouchCard) deactivateCard(activeTouchCard);
                activateCard(card);
                e.preventDefault();
                e.stopPropagation();
            }
            // Second tap: Open modal (default onclick handler will fire)
        }

        function activateCard(card) {
            activeTouchCard = card;
            card.classList.add('touch-active');

            // Show buttons with staggered animation
            const buttons = card.querySelectorAll('.action-button');
            buttons.forEach((btn, index) => {
                setTimeout(() => {
                    btn.classList.remove('opacity-0');
                    btn.classList.add('opacity-100', 'scale-in');
                }, index * 50); // 50ms stagger
            });
        }

        function deactivateCard(card) {
            card.classList.remove('touch-active');
            const buttons = card.querySelectorAll('.action-button');
            buttons.forEach(btn => {
                btn.classList.remove('opacity-100', 'scale-in');
                btn.classList.add('opacity-0');
            });
            activeTouchCard = null;
        }
        // ========== END: Touch Interaction System ==========

        // ========== START: Custom Dialog System (Cyberpunk Theme) ==========
        // v2.8.0: Replace browser alert/confirm with custom styled dialogs

        function showCustomAlert(message, title = '‚ö†Ô∏è ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô') {
            return new Promise((resolve) => {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.className = 'fixed inset-0 z-[10000] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 animate-fadeIn';
                overlay.style.animation = 'fadeIn 0.2s ease-out';

                // Create dialog
                overlay.innerHTML = `
                    <div class="bg-[#1a1a2e] border-2 border-cyan-500/50 rounded-xl p-6 max-w-md w-full shadow-2xl shadow-cyan-500/20 transform animate-scaleIn" style="animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)">
                        <div class="flex items-start gap-3 mb-4">
                            <div class="text-3xl">${title.split(' ')[0]}</div>
                            <h3 class="text-lg font-medium text-cyan-400 flex-1">${title.split(' ').slice(1).join(' ')}</h3>
                        </div>
                        <div class="text-gray-300 whitespace-pre-wrap mb-6 text-sm leading-relaxed">${message}</div>
                        <button class="w-full py-3 px-4 bg-gradient-to-r from-cyan-500 to-blue-500 hover:from-cyan-400 hover:to-blue-400 text-white font-medium rounded-lg transition-all shadow-lg shadow-cyan-500/30 hover:shadow-cyan-500/50 hover:scale-[1.02]">
                            ‡∏ï‡∏Å‡∏•‡∏á
                        </button>
                    </div>
                `;

                document.body.appendChild(overlay);

                // Add animations to head if not exists
                if (!document.querySelector('#custom-dialog-animations')) {
                    const style = document.createElement('style');
                    style.id = 'custom-dialog-animations';
                    style.textContent = `
                        @keyframes fadeIn {
                            from { opacity: 0; }
                            to { opacity: 1; }
                        }
                        @keyframes scaleIn {
                            from { transform: scale(0.9); opacity: 0; }
                            to { transform: scale(1); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                // Close on button click
                const button = overlay.querySelector('button');
                button.onclick = () => {
                    overlay.style.animation = 'fadeIn 0.15s ease-in reverse';
                    setTimeout(() => {
                        overlay.remove();
                        resolve(true);
                    }, 150);
                };

                // Focus button for keyboard accessibility
                button.focus();
            });
        }

        function showCustomConfirm(message, title = '‚ùì ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô') {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'fixed inset-0 z-[10000] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4 animate-fadeIn';
                overlay.style.animation = 'fadeIn 0.2s ease-out';

                overlay.innerHTML = `
                    <div class="bg-[#1a1a2e] border-2 border-purple-500/50 rounded-xl p-6 max-w-md w-full shadow-2xl shadow-purple-500/20 transform animate-scaleIn" style="animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)">
                        <div class="flex items-start gap-3 mb-4">
                            <div class="text-3xl">${title.split(' ')[0]}</div>
                            <h3 class="text-lg font-medium text-purple-400 flex-1">${title.split(' ').slice(1).join(' ')}</h3>
                        </div>
                        <div class="text-gray-300 whitespace-pre-wrap mb-6 text-sm leading-relaxed">${message}</div>
                        <div class="flex gap-3">
                            <button data-action="cancel" class="flex-1 py-3 px-4 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg transition-all">
                                ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å
                            </button>
                            <button data-action="confirm" class="flex-1 py-3 px-4 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-400 hover:to-pink-400 text-white font-medium rounded-lg transition-all shadow-lg shadow-purple-500/30 hover:shadow-purple-500/50 hover:scale-[1.02]">
                                ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
                            </button>
                        </div>
                    </div>
                `;

                document.body.appendChild(overlay);

                const closeDialog = (result) => {
                    overlay.style.animation = 'fadeIn 0.15s ease-in reverse';
                    setTimeout(() => {
                        overlay.remove();
                        resolve(result);
                    }, 150);
                };

                overlay.querySelector('[data-action="cancel"]').onclick = () => closeDialog(false);
                overlay.querySelector('[data-action="confirm"]').onclick = () => closeDialog(true);

                // Focus confirm button
                overlay.querySelector('[data-action="confirm"]').focus();
            });
        }

        // Override global alert and confirm
        window.alert = showCustomAlert;
        window.confirm = showCustomConfirm;
        // ========== END: Custom Dialog System ==========

        // ========== START: Prompt Persistence System ==========
        const PROMPT_STORAGE_KEY = 'vidist_last_prompt';
        const NEGATIVE_PROMPT_STORAGE_KEY = 'vidist_last_negative_prompt';

        // ========== Refresh Persistence Keys (v1.10.0) ==========
        const CRAFT_INPUT_STORAGE_KEY = 'vidist_craft_input';
        const ATTACHED_IMAGE_STORAGE_KEY = 'vidist_attached_image';
        const ATTACHED_VIDEO_URL_KEY = 'vidist_attached_video_url';
        const ATTACHED_VIDEO_BASE64_KEY = 'vidist_attached_video_base64';

        // ========== Generation State Persistence Keys (v1.11.0) ==========
        const GENERATION_STATE_KEY = 'vidist_generation_state';
        const PROCESSING_THUMBNAIL_KEY = 'vidist_processing_thumbnail';

        // ========== Prompt Expansion Persistence (v2.2.4) ==========
        const PROMPT_EXPANSION_KEY = 'vidist_prompt_expansion';

        // Save prompt to localStorage (debounced)
        let promptSaveTimeout;
        function savePromptToStorage() {
            clearTimeout(promptSaveTimeout);
            promptSaveTimeout = setTimeout(() => {
                const prompt = promptTextarea.value;
                const negativePrompt = negativePromptInput.value;

                localStorage.setItem(PROMPT_STORAGE_KEY, prompt);
                localStorage.setItem(NEGATIVE_PROMPT_STORAGE_KEY, negativePrompt);

                console.log('üíæ Prompts saved:', {
                    prompt: prompt.substring(0, 50) + (prompt.length > 50 ? '...' : ''),
                    negativePrompt: negativePrompt.substring(0, 30) + (negativePrompt.length > 30 ? '...' : '')
                });
            }, 500); // Debounce 500ms
        }

        // Load prompts from localStorage
        function loadPromptsFromStorage() {
            console.log('üîç Loading prompts from storage...');
            const savedPrompt = localStorage.getItem(PROMPT_STORAGE_KEY);
            const savedNegativePrompt = localStorage.getItem(NEGATIVE_PROMPT_STORAGE_KEY);

            console.log('üíæ Saved prompt:', savedPrompt ? savedPrompt.substring(0, 50) + '...' : 'null');
            console.log('üíæ Saved negative:', savedNegativePrompt ? savedNegativePrompt.substring(0, 30) + '...' : 'null');

            if (savedPrompt) {
                promptTextarea.value = savedPrompt;
                console.log('‚úÖ Prompt restored:', promptTextarea.value.substring(0, 50) + '...');
            } else {
                console.log('‚ö†Ô∏è No saved prompt found');
            }

            if (savedNegativePrompt) {
                negativePromptInput.value = savedNegativePrompt;
                console.log('‚úÖ Negative prompt restored:', negativePromptInput.value.substring(0, 30) + '...');
            } else {
                console.log('‚ö†Ô∏è No saved negative prompt found');
            }
        }

        // ========== NEW: Refresh Persistence Functions (v1.10.0) ==========

        // Save Craft Input to localStorage (debounced)
        let craftInputSaveTimeout;
        function saveCraftInputToStorage() {
            clearTimeout(craftInputSaveTimeout);
            craftInputSaveTimeout = setTimeout(() => {
                const craftInput = document.getElementById('prompt-craft-input');
                if (craftInput) {
                    const value = craftInput.value;
                    try {
                        localStorage.setItem(CRAFT_INPUT_STORAGE_KEY, value);
                        console.log('üíæ Craft input saved:', value.substring(0, 30) + (value.length > 30 ? '...' : ''));
                    } catch (e) {
                        console.warn('Could not save craft input:', e);
                    }
                }
            }, 500);
        }

        // Compress image for localStorage (max 400KB, 800px max dimension)
        async function compressImageForStorage(base64Data) {
            return new Promise((resolve) => {
                // If already small enough (< 300KB), don't compress
                if (base64Data.length < 300 * 1024) {
                    resolve(base64Data);
                    return;
                }

                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    // Scale down if too large (max 800px on longest side)
                    const maxDimension = 800;
                    if (width > maxDimension || height > maxDimension) {
                        if (width > height) {
                            height = (height / width) * maxDimension;
                            width = maxDimension;
                        } else {
                            width = (width / height) * maxDimension;
                            height = maxDimension;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Try different quality levels to get under 400KB
                    let quality = 0.7;
                    let compressed = canvas.toDataURL('image/jpeg', quality);

                    while (compressed.length > 400 * 1024 && quality > 0.1) {
                        quality -= 0.1;
                        compressed = canvas.toDataURL('image/jpeg', quality);
                    }

                    console.log(`üóúÔ∏è Image compressed: ${(base64Data.length / 1024).toFixed(1)}KB ‚Üí ${(compressed.length / 1024).toFixed(1)}KB (quality: ${quality.toFixed(1)})`);
                    resolve(compressed);
                };
                img.onerror = () => resolve(base64Data); // Fallback to original if error
                img.src = base64Data;
            });
        }

        // Save Image Attachment to localStorage
        async function saveImageToStorage(base64Data) {
            if (!base64Data) {
                // Clear if null
                try {
                    localStorage.removeItem(ATTACHED_IMAGE_STORAGE_KEY);
                    console.log('üßπ Image attachment cleared from storage');
                } catch (e) {
                    console.warn('Could not clear image from storage:', e);
                }
                return;
            }

            try {
                // Compress image before saving to avoid quota errors
                const compressed = await compressImageForStorage(base64Data);

                // Use safe storage wrapper to handle quota
                const success = safeSetLocalStorage(ATTACHED_IMAGE_STORAGE_KEY, compressed);
                if (success) {
                    console.log('üíæ Image attachment saved (compressed size:', (compressed.length / 1024).toFixed(1), 'KB)');
                } else {
                    console.warn('‚ö†Ô∏è Could not save image - too large or quota exceeded');
                }
            } catch (e) {
                console.error('‚ùå Error saving image:', e);
            }
        }

        // Save Video Attachment to localStorage
        function saveVideoToStorage(url, base64Data) {
            try {
                if (url) {
                    localStorage.setItem(ATTACHED_VIDEO_URL_KEY, url);
                    console.log('üíæ Video URL saved:', url.substring(0, 50) + '...');
                } else {
                    localStorage.removeItem(ATTACHED_VIDEO_URL_KEY);
                }

                if (base64Data) {
                    const success = safeSetLocalStorage(ATTACHED_VIDEO_BASE64_KEY, base64Data);
                    if (success) {
                        console.log('üíæ Video base64 saved (size:', (base64Data.length / 1024).toFixed(1), 'KB)');
                    } else {
                        console.warn('‚ö†Ô∏è Could not save video base64 - too large or quota exceeded');
                    }
                } else {
                    localStorage.removeItem(ATTACHED_VIDEO_BASE64_KEY);
                }

                if (!url && !base64Data) {
                    console.log('üßπ Video attachment cleared from storage');
                }
            } catch (e) {
                console.error('‚ùå Error saving video:', e);
            }
        }

        // Load all state from localStorage (prompts + craft input + attachments)
        function loadAllStateFromStorage() {
            console.log('üîç Loading all state from storage...');

            // 1. Load prompts (existing function)
            loadPromptsFromStorage();

            // 2. Load craft input
            try {
                const savedCraftInput = localStorage.getItem(CRAFT_INPUT_STORAGE_KEY);
                const craftInputElement = document.getElementById('prompt-craft-input');
                if (savedCraftInput && craftInputElement) {
                    craftInputElement.value = savedCraftInput;
                    console.log('‚úÖ Craft input restored:', savedCraftInput.substring(0, 30) + '...');
                }
            } catch (e) {
                console.warn('Could not load craft input:', e);
            }

            // 3. Load image attachment
            try {
                const savedImage = localStorage.getItem(ATTACHED_IMAGE_STORAGE_KEY);
                if (savedImage) {
                    imageBase64Data = savedImage;
                    console.log('‚úÖ Image attachment restored (size:', (savedImage.length / 1024).toFixed(1), 'KB)');

                    // Update UI to show image preview
                    restoreImagePreview(savedImage);
                }
            } catch (e) {
                console.warn('Could not load image attachment:', e);
            }

            // 4. Load video attachment
            try {
                const savedVideoUrl = localStorage.getItem(ATTACHED_VIDEO_URL_KEY);
                const savedVideoBase64 = localStorage.getItem(ATTACHED_VIDEO_BASE64_KEY);

                if (savedVideoUrl || savedVideoBase64) {
                    currentVideoUrl = savedVideoUrl;
                    currentVideoBase64 = savedVideoBase64;
                    console.log('‚úÖ Video attachment restored');

                    // Update UI to show video preview
                    restoreVideoPreview(savedVideoUrl, savedVideoBase64);
                }
            } catch (e) {
                console.warn('Could not load video attachment:', e);
            }

            // 5. Load Prompt Expansion state (v2.2.4)
            try {
                const savedExpansion = localStorage.getItem(PROMPT_EXPANSION_KEY);
                const promptExpansionCheckbox = document.getElementById('prompt-expansion');
                if (promptExpansionCheckbox) {
                    promptExpansionCheckbox.checked = savedExpansion === 'true';
                    console.log('‚úÖ Prompt Expansion restored:', promptExpansionCheckbox.checked);
                }
            } catch (e) {
                console.warn('Could not load Prompt Expansion state:', e);
            }

            console.log('‚úÖ State restoration complete');
        }

        // Restore image preview in UI
        function restoreImagePreview(base64Data) {
            if (!base64Data) return;

            // 1. Update global variable for immediate use
            imageBase64Data = base64Data;
            window.imageBase64Data = base64Data; // ‚ú® NEW: Sync to window for history navigation

            // 2. Update UI - Left Sidebar (New Layout)
            const imagePreviewLeft = document.getElementById('image-preview-left');
            const imagePreviewContainerLeft = document.getElementById('image-preview-container-left');
            const dragDropAreaLeft = document.getElementById('drag-drop-area-left');
            const modalImageFull = document.getElementById('modal-image-full');

            if (imagePreviewLeft && imagePreviewContainerLeft && dragDropAreaLeft) {
                imagePreviewLeft.src = base64Data;
                imagePreviewContainerLeft.classList.remove('hidden'); // Show preview
                dragDropAreaLeft.classList.add('hidden'); // Hide drop area

                // Update modal preview
                if (modalImageFull) modalImageFull.src = base64Data;

                // Show image edit controls when image is restored
                const imageEditControls = document.getElementById('image-edit-controls');
                if (imageEditControls) {
                    imageEditControls.classList.remove('hidden');
                    console.log('‚úÖ Image edit controls shown');
                }

                // If history is empty but image exists, add to history
                if (typeof window.imageEditHistory !== 'undefined') {
                    const historyState = window.imageEditHistory.getState();
                    if (historyState.length === 0) {
                        window.imageEditHistory.add(base64Data);
                        console.log('üì∏ Restored image added to empty history');
                    }
                }

                console.log('üñºÔ∏è Image preview restored (left sidebar)');
            }

            // 3. Update UI - Old Layout (Fallback compatibility)
            const imagePreview = document.getElementById('image-preview');
            const imagePreviewContainer = document.getElementById('image-preview-container');
            const dragDropArea = document.getElementById('drag-drop-area');

            if (imagePreview && imagePreviewContainer && dragDropArea) {
                imagePreview.src = base64Data;
                imagePreviewContainer.classList.remove('hidden');
                dragDropArea.classList.add('hidden');

                console.log('üñºÔ∏è Image preview restored (old layout fallback)');
            }
        }

        // Restore video preview in UI
        function restoreVideoPreview(url, base64Data) {
            // Find video preview container
            const videoPreview = document.getElementById('video-preview');
            const uploadedVideo = document.getElementById('uploaded-video');
            const removeVideoBtn = document.getElementById('remove-video-btn');

            if (videoPreview && uploadedVideo) {
                uploadedVideo.src = url || base64Data;
                videoPreview.classList.remove('hidden');
                if (removeVideoBtn) {
                    removeVideoBtn.classList.remove('hidden');
                }
                console.log('üé¨ Video preview restored');
            }
        }

        // ========== END: Refresh Persistence Functions ==========

        // ========== Generation State Persistence Functions (v1.11.0) ==========
        // Save current generation state (for resuming after refresh)
        function saveGenerationState() {
            if (!currentGenerationId || !currentPollingUrl) {
                console.log('üîç No active generation to save');
                return;
            }

            const generationState = {
                taskId: currentGenerationId,
                pollingUrl: currentPollingUrl,
                provider: currentProvider,
                apiKey: apiKeyInput_ws?.value || null,
                status: statusBadge?.textContent || 'PENDING',
                startTime: Date.now(), // Save current timestamp
                // Save from DOM elements with null checks
                prompt: promptTextarea?.value || '',
                model: modelSelect?.value || 'unknown',
                // Save thumbnail from videoHistoryData
                processingThumbnailIndex: videoHistoryData.findIndex(v => v.id === currentGenerationId)
            };

            try {
                const success = safeSetLocalStorage(GENERATION_STATE_KEY, JSON.stringify(generationState));
                if (success) {
                    console.log('üíæ Generation state saved:', {
                        taskId: generationState.taskId,
                        status: generationState.status,
                        provider: generationState.provider
                    });
                } else {
                    console.warn('‚ö†Ô∏è Could not save generation state (quota exceeded)');
                }
            } catch (e) {
                console.error('‚ùå Error saving generation state:', e);
                console.error('Stack trace:', e.stack);
            }
        }

        // Load generation state (returns null if no saved state)
        function loadGenerationState() {
            try {
                const savedState = localStorage.getItem(GENERATION_STATE_KEY);
                if (!savedState) {
                    console.log('üîç No saved generation state found');
                    return null;
                }

                const state = JSON.parse(savedState);

                // Validate required fields
                if (!state.taskId || !state.pollingUrl || !state.apiKey) {
                    console.warn('‚ö†Ô∏è Invalid saved generation state, clearing');
                    clearGenerationState();
                    return null;
                }

                // Check if state is too old (> 2 hours)
                const age = Date.now() - (state.startTime || 0);
                const maxAge = 2 * 60 * 60 * 1000; // 2 hours
                if (age > maxAge) {
                    console.log('üïí Saved generation state too old, clearing');
                    clearGenerationState();
                    return null;
                }

                console.log('‚úÖ Generation state loaded:', {
                    taskId: state.taskId,
                    status: state.status,
                    provider: state.provider,
                    age: Math.round(age / 1000) + 's ago'
                });

                return state;
            } catch (e) {
                console.error('‚ùå Error loading generation state:', e);
                clearGenerationState();
                return null;
            }
        }

        // Clear generation state from localStorage
        function clearGenerationState() {
            try {
                localStorage.removeItem(GENERATION_STATE_KEY);
                console.log('üßπ Generation state cleared');
            } catch (e) {
                console.warn('Could not clear generation state:', e);
            }
        }

        // Resume generation after page refresh
        function resumeGenerationIfNeeded() {
            const savedState = loadGenerationState();
            if (!savedState) {
                return; // No saved state, nothing to resume
            }

            console.log('üîÑ Resuming generation after refresh...');

            // Restore global state variables
            currentGenerationId = savedState.taskId;
            currentPollingUrl = savedState.pollingUrl;
            currentProvider = savedState.provider;

            // Update UI to show we're resuming
            if (statusBadge) {
                statusBadge.className = 'status-badge status-processing';
                statusBadge.textContent = 'RESUMING';
            }
            if (statusText) {
                statusText.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà...';
            }

            // Disable generate button, show cancel button
            if (generateBtn) {
                generateBtn.disabled = true;
            }
            if (generateSpinner) {
                generateSpinner.classList.remove('hidden');
            }
            if (cancelGenerationBtn) {
                cancelGenerationBtn.classList.remove('hidden');
            }

            // Find the processing thumbnail in history (if exists)
            if (savedState.processingThumbnailIndex !== -1 && videoHistoryData[savedState.processingThumbnailIndex]) {
                console.log('‚úÖ Found processing thumbnail in history at index:', savedState.processingThumbnailIndex);
                // History already loaded, just re-render to show it
                renderVideoHistory();
            }

            // Start polling with saved credentials
            console.log('‚ñ∂Ô∏è Restarting polling with saved state');
            startPolling(savedState.apiKey, savedState.pollingUrl);
        }
        // ========== END: Generation State Persistence Functions ==========

        // ========== ‚ú® NEW: HTML Escape Helper Function (v2.4.2) ==========
        // Prevent XSS attacks when rendering user content
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        // ========== END: HTML Escape ==========

        // ========== ‚ú® NEW: Task Input Persistence System (v2.4.2) ==========
        // Fixes "No prompt available" issue by ensuring metadata survives page refresh
        const TASK_INPUT_STORAGE_KEY = 'vidist_task_inputs_v2';

        const TaskPersistence = {
            // Maximum items: 300 (supports ~7 days of history at 40-50 gens/day)
            MAX_ITEMS: 300,
            // Maximum age: 7 days (matches Wavespeed API retention)
            MAX_AGE_DAYS: 7,

            save: function (id, data) {
                try {
                    const inputs = this.getAll();

                    // Add timestamp
                    inputs[id] = {
                        ...data,
                        timestamp: new Date().toISOString()
                    };

                    // Cleanup old items
                    this.cleanup(inputs);

                    localStorage.setItem(TASK_INPUT_STORAGE_KEY, JSON.stringify(inputs));
                    console.log('üíæ Task Persistence: Saved input for', id);
                } catch (e) { console.error('TaskPersistence Save Error:', e); }
            },

            get: function (id) {
                try {
                    const inputs = this.getAll();
                    return inputs[id] || null;
                } catch (e) { return null; }
            },

            getAll: function () {
                try {
                    return JSON.parse(localStorage.getItem(TASK_INPUT_STORAGE_KEY) || '{}');
                } catch (e) { return {}; }
            },

            cleanup: function (inputs) {
                const now = new Date();
                const maxAge = this.MAX_AGE_DAYS * 24 * 60 * 60 * 1000; // 7 days in ms
                const entries = Object.entries(inputs);

                // Remove items older than 7 days
                let removedByAge = 0;
                entries.forEach(([id, data]) => {
                    if (data.timestamp) {
                        const age = now - new Date(data.timestamp);
                        if (age > maxAge) {
                            delete inputs[id];
                            removedByAge++;
                        }
                    }
                });

                // If still over limit, remove oldest entries
                const remainingKeys = Object.keys(inputs);
                if (remainingKeys.length > this.MAX_ITEMS) {
                    const sorted = remainingKeys
                        .map(id => ({ id, timestamp: inputs[id].timestamp || '1970-01-01' }))
                        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                    const toRemove = sorted.slice(0, remainingKeys.length - this.MAX_ITEMS);
                    toRemove.forEach(item => delete inputs[item.id]);

                    console.log(`üßπ TaskPersistence: Removed ${removedByAge} old items, ${toRemove.length} excess items`);
                } else if (removedByAge > 0) {
                    console.log(`üßπ TaskPersistence: Removed ${removedByAge} items older than ${this.MAX_AGE_DAYS} days`);
                }
            },

            // Migrate data from old taskInputMap
            migrateFromOld: function () {
                try {
                    const oldData = localStorage.getItem('taskInputMap');
                    if (!oldData) return;

                    const oldMap = new Map(JSON.parse(oldData));
                    const inputs = this.getAll();
                    let migrated = 0;

                    oldMap.forEach((data, id) => {
                        if (!inputs[id]) {
                            inputs[id] = {
                                ...data,
                                timestamp: new Date().toISOString() // Assume recent
                            };
                            migrated++;
                        }
                    });

                    if (migrated > 0) {
                        localStorage.setItem(TASK_INPUT_STORAGE_KEY, JSON.stringify(inputs));
                        console.log(`‚úÖ Migrated ${migrated} items from old taskInputMap`);
                    }
                } catch (e) {
                    console.error('Migration error:', e);
                }
            }
        };

        // Global functions for backward compatibility / easy access
        // CRITICAL: Define as regular functions (not just window properties)
        // because code calls saveTaskInput() directly at lines 5484, 6263
        function saveTaskInput(id, data) {
            return TaskPersistence.save(id, data);
        }

        function getTaskInput(id) {
            return TaskPersistence.get(id);
        }

        // Also expose on window for explicit access
        window.saveTaskInput = saveTaskInput;
        window.getTaskInput = getTaskInput;

        // Run migration on startup
        TaskPersistence.migrateFromOld();
        // ========== END: Task Persistence ==========

        // ========== ‚ú® NEW: History Migration System ==========
        // Ensures legacy history items have all required fields

        /**
         * Guess modelKey from model name by matching against MODEL_CONFIG
         * @param {string} modelName - The display name (e.g., "Wan 2.5 I2V")
         * @returns {string|null} - The matched key or null
         */
        function guessModelKey(modelName) {
            if (!modelName) return null;

            // Direct match with MODEL_CONFIG names
            for (const [key, config] of Object.entries(MODEL_CONFIG)) {
                if (config.name === modelName) {
                    return key;
                }
            }

            // Fallback: partial match (case insensitive)
            const lowerName = modelName.toLowerCase();
            if (lowerName.includes('2.5') && lowerName.includes('extend')) return 'ws-wan-25-extend';
            if (lowerName.includes('2.5') && lowerName.includes('i2v')) return 'ws-wan-25-i2v';
            if (lowerName.includes('2.6') && lowerName.includes('edit')) return 'ws-wan-26-image-edit';
            if (lowerName.includes('2.6') && lowerName.includes('i2v')) return 'ws-wan-26-i2v';
            if (lowerName.includes('kling')) return 'ws-kling-o1-i2v';

            return null; // No match found
        }

        /**
         * Migrate legacy history data by adding missing fields
         * Run once on app init to ensure all items have required properties
         */
        function migrateHistoryData() {
            let migrated = 0;

            videoHistoryData.forEach(item => {
                let itemModified = false;

                // Add missing fields with defaults
                if (item.craftData === undefined) {
                    item.craftData = null;
                    itemModified = true;
                }

                if (!item.modelKey && item.model) {
                    item.modelKey = guessModelKey(item.model);
                    itemModified = true;
                }

                if (!item.outputType) {
                    // Guess from model or default to 'video'
                    if (item.modelKey === 'ws-wan-26-image-edit') {
                        item.outputType = 'image';
                    } else {
                        item.outputType = 'video';
                    }
                    itemModified = true;
                }

                if (item.negativePrompt === undefined) {
                    item.negativePrompt = '';
                    itemModified = true;
                }

                if (itemModified) {
                    migrated++;
                }
            });

            if (migrated > 0) {
                console.log(`‚úÖ History Migration: Updated ${migrated} legacy items with missing fields`);
                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
            }
        }
        // ========== END: History Migration ==========


        // Clear all prompts (only when user clicks clear button)
        // Make function globally accessible for onclick handler
        window.clearPrompts = function () {
            // Query DOM elements directly to ensure they're accessible
            const promptTextarea = document.getElementById('prompt');
            const negativePromptInput = document.getElementById('negative-prompt');

            // Save current prompt to undo stack before clearing (if not empty)
            if (promptTextarea && promptTextarea.value.trim()) {
                try {
                    if (promptCraftController && promptCraftController.state) {
                        promptCraftController.state.pushPromptUndo(promptTextarea.value);
                        console.log('üíæ Saved current prompt to undo stack before clearing');
                    }
                } catch (e) {
                    console.warn('Could not save to undo stack:', e);
                }
            }

            // Clear the text areas
            if (promptTextarea) {
                promptTextarea.value = '';
            }

            if (negativePromptInput) {
                negativePromptInput.value = '';
            }

            // ========== NEW: Clear craft input and attachments (v1.10.0) ==========
            const craftInput = document.getElementById('prompt-craft-input');
            if (craftInput) {
                craftInput.value = '';
                try {
                    localStorage.setItem(CRAFT_INPUT_STORAGE_KEY, '');
                } catch (e) {
                    console.warn('Could not clear craft input from storage:', e);
                }
            }

            // Clear image attachment
            if (typeof clearUploadedImage === 'function') {
                clearUploadedImage();
            }

            // Clear video attachment
            if (typeof clearUploadedVideo === 'function') {
                clearUploadedVideo();
            }
            // ========== END: Clear craft input and attachments ==========

            // Save the cleared state to localStorage (not remove, just update to empty)
            try {
                localStorage.setItem('vidist_last_prompt', '');
                localStorage.setItem('vidist_last_negative_prompt', '');
            } catch (e) {
                console.warn('Could not update localStorage:', e);
            }

            // ========== Reset Craft Flags ==========
            promptWasCrafted = false;
            promptWasManuallyEdited = false;
            lastCraftedPrompt = '';
            console.log('üîÑ Craft flags reset');
            // ========== END ==========

            console.log('üßπ Prompts cleared (saved to undo stack - press Ctrl+Z to restore)');
        };

        // Auto-save on input
        promptTextarea.addEventListener('input', savePromptToStorage);
        negativePromptInput.addEventListener('input', savePromptToStorage);

        // ========== NEW: Auto-save craft input on input (v1.10.0) ==========
        const craftInputElement = document.getElementById('prompt-craft-input');
        if (craftInputElement) {
            craftInputElement.addEventListener('input', saveCraftInputToStorage);
            console.log('‚úÖ Craft input auto-save listener added');
        }

        // Save immediately on blur (when user clicks away)
        promptTextarea.addEventListener('blur', () => {
            clearTimeout(promptSaveTimeout);
            const prompt = promptTextarea.value;
            const negativePrompt = negativePromptInput.value;
            localStorage.setItem(PROMPT_STORAGE_KEY, prompt);
            localStorage.setItem(NEGATIVE_PROMPT_STORAGE_KEY, negativePrompt);
            console.log('üíæ Prompts saved immediately (blur)');
        });

        negativePromptInput.addEventListener('blur', () => {
            clearTimeout(promptSaveTimeout);
            const prompt = promptTextarea.value;
            const negativePrompt = negativePromptInput.value;
            localStorage.setItem(PROMPT_STORAGE_KEY, prompt);
            localStorage.setItem(NEGATIVE_PROMPT_STORAGE_KEY, negativePrompt);
            console.log('üíæ Prompts saved immediately (blur)');
        });

        // Save immediately before page unload and cleanup intervals
        window.addEventListener('beforeunload', () => {
            // Force save prompts immediately
            clearTimeout(promptSaveTimeout);
            const prompt = promptTextarea.value;
            const negativePrompt = negativePromptInput.value;
            localStorage.setItem(PROMPT_STORAGE_KEY, prompt);
            localStorage.setItem(NEGATIVE_PROMPT_STORAGE_KEY, negativePrompt);
            console.log('üíæ Prompts saved immediately (beforeunload)');

            // Cleanup polling intervals to prevent memory leaks
            if (typeof clearPollingAndTimer === 'function') {
                clearPollingAndTimer();
            }
        });
        // ========== END: Prompt Persistence System ==========

        // --- Helper: Update Toggle Label ---
        function updateToggleLabel(toggleElement) {
            const labelSpan = toggleElement.parentElement.querySelector('span.text-xs');
            if (labelSpan) {
                labelSpan.textContent = toggleElement.checked ? 'Enabled' : 'Disabled';
            }
        }

        // --- Helper: Clear Cache for Disabled Provider ---
        async function clearProviderCache(provider) {
            console.log(`Clearing cache for provider: ${provider}`);

            // 1. Clear from videoHistoryData (in-memory)
            videoHistoryData = videoHistoryData.filter(item => item.provider !== provider);

            // 2. Save updated history to localStorage
            try {
                localStorage.setItem('videoHistory', JSON.stringify(videoHistoryData));
                console.log(`Removed ${provider} videos from localStorage`);
            } catch (e) {
                console.error('Error saving history to localStorage:', e);
            }

            // 3. Clear from IndexedDB cache (if video-cache.js is being used)
            try {
                // Open IndexedDB
                const dbName = 'vidist-cache';
                const request = indexedDB.open(dbName, 1);

                request.onsuccess = (event) => {
                    const db = event.target.result;

                    // Check if stores exist
                    if (!db.objectStoreNames.contains('videos') || !db.objectStoreNames.contains('metadata')) {
                        console.log('IndexedDB stores not found, skipping cache clear');
                        db.close();
                        return;
                    }

                    const transaction = db.transaction(['videos', 'metadata'], 'readwrite');
                    const videosStore = transaction.objectStore('videos');
                    const metadataStore = transaction.objectStore('metadata');

                    // Get all metadata to find videos from this provider
                    const metadataRequest = metadataStore.getAll();

                    metadataRequest.onsuccess = () => {
                        const allMetadata = metadataRequest.result;
                        const keysToDelete = allMetadata
                            .filter(meta => meta.provider === provider)
                            .map(meta => meta.id);

                        console.log(`Found ${keysToDelete.length} ${provider} videos in IndexedDB cache`);

                        // Delete from both stores
                        keysToDelete.forEach(key => {
                            videosStore.delete(key);
                            metadataStore.delete(key);
                        });

                        console.log(`Cleared ${provider} videos from IndexedDB cache`);
                    };

                    transaction.oncomplete = () => {
                        db.close();
                        // Refresh history display
                        renderVideoHistory();
                    };

                    transaction.onerror = () => {
                        console.error('Error clearing IndexedDB cache:', transaction.error);
                        db.close();
                    };
                };

                request.onerror = () => {
                    console.error('Error opening IndexedDB:', request.error);
                };
            } catch (e) {
                console.error('Error accessing IndexedDB:', e);
            }
        }

        // --- Populate Model Dropdown from CONFIG ---
        const SELECTED_MODEL_KEY = 'vidist_selected_model';  // üíæ localStorage key for model persistence

        function populateModelDropdown() {
            const modelSelect = document.getElementById('model-select');
            const dropdownList = document.getElementById('model-dropdown-list');
            const dropdownBtn = document.getElementById('model-dropdown-btn');
            const selectedIcon = document.getElementById('model-selected-icon');
            const selectedText = document.getElementById('model-selected-text');
            const chevron = document.getElementById('model-dropdown-chevron');

            if (!modelSelect || !dropdownList) {
                console.error('Model select elements not found');
                return;
            }

            modelSelect.innerHTML = '';
            dropdownList.innerHTML = '';

            // Helper: Get icon path based on model key
            function getModelIcon(key) {
                if (key.includes('kling')) {
                    return 'assets/kling.png';
                }
                if (key.includes('grok')) {
                    return 'assets/grok.png';
                }
                return 'assets/wan.png';
            }

            // Helper: Format display text
            function getDisplayText(config) {
                let durationText;
                if (config.allowedDurations) {
                    durationText = `(${config.allowedDurations.join('/')}s)`;
                } else if (config.minDuration && config.maxDuration) {
                    durationText = `(${config.minDuration}-${config.maxDuration}s)`;
                } else {
                    durationText = '';  // No duration for image models
                }

                let suffix = '';
                if (config.requiresStartVideo) {
                    suffix = ' [Extend]';
                } else if (config.supportsShotType) {
                    suffix = ' [Pro]';
                } else if (config.provider === 'grok') {
                    suffix = ' [Grok]';
                }

                return `${config.name} ${durationText}${suffix}`.trim();
            }

            // üíæ Restore last selected model from localStorage
            const savedModel = localStorage.getItem(SELECTED_MODEL_KEY);
            let defaultKey = 'ws-wan-25-i2v';

            if (savedModel && MODEL_CONFIG[savedModel]) {
                defaultKey = savedModel;
                console.log('üíæ Restored model from localStorage:', savedModel);
            } else {
                console.log('üìã Using default model:', defaultKey);
            }

            Object.entries(MODEL_CONFIG).forEach(([key, config]) => {
                // ‚ú® NEW: Skip image edit models (they're for background use only)
                if (config.outputType === 'image' || config.features?.includes('image-edit')) {
                    console.log(`‚è≠Ô∏è Skipping image edit model: ${key}`);
                    return; // Skip this model
                }

                // Populate hidden select
                const option = document.createElement('option');
                option.value = key;
                option.textContent = getDisplayText(config);
                if (key === defaultKey) {
                    option.selected = true;
                }
                modelSelect.appendChild(option);

                // Populate custom dropdown list
                const iconPath = getModelIcon(key);
                const displayText = getDisplayText(config);

                const item = document.createElement('div');
                item.className = 'model-dropdown-item flex items-center gap-2 px-4 py-3 hover:bg-cyan-500/10 cursor-pointer transition-colors';
                item.dataset.value = key;
                item.innerHTML = `
                    <img src="${iconPath}" alt="" class="w-5 h-5">
                    <span class="text-gray-200">${displayText}</span>
                `;

                // Click handler
                item.addEventListener('click', () => {
                    selectModel(key, iconPath, displayText);
                    closeModelDropdown();
                });

                dropdownList.appendChild(item);
            });

            // Set initial selected state
            const defaultConfig = MODEL_CONFIG[defaultKey];
            if (defaultConfig) {
                selectedIcon.src = getModelIcon(defaultKey);
                selectedText.textContent = getDisplayText(defaultConfig);
            }

            // Toggle dropdown
            dropdownBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const isOpen = !dropdownList.classList.contains('hidden');
                if (isOpen) {
                    closeModelDropdown();
                } else {
                    openModelDropdown();
                }
            });

            // Close on outside click
            document.addEventListener('click', (e) => {
                if (!dropdownBtn.contains(e.target) && !dropdownList.contains(e.target)) {
                    closeModelDropdown();
                }
            });

            function openModelDropdown() {
                dropdownList.classList.remove('hidden');
                chevron.classList.add('rotate-180');
            }

            function closeModelDropdown() {
                dropdownList.classList.add('hidden');
                chevron.classList.remove('rotate-180');
            }

            function selectModel(key, iconPath, displayText) {
                modelSelect.value = key;
                selectedIcon.src = iconPath;
                selectedText.textContent = displayText;

                // üíæ Save selected model to localStorage
                localStorage.setItem(SELECTED_MODEL_KEY, key);
                console.log('üíæ Model selection saved:', key);

                // Trigger change event on hidden select
                modelSelect.dispatchEvent(new Event('change'));
            }

            // Expose selectModel globally for programmatic use
            window.selectModelByKey = function (key) {
                const config = MODEL_CONFIG[key];
                if (config) {
                    const iconPath = getModelIcon(key);
                    const displayText = getDisplayText(config);
                    selectModel(key, iconPath, displayText);
                }
            };

            console.log(`‚úÖ Populated ${Object.keys(MODEL_CONFIG).length} models in dropdown`);
        }

        // --- Load API Keys & Initialize ---
        // ========== STEP COMPLEXITY SELECTOR ==========
        const STEP_COMPLEXITY_KEY = 'vidist_step_complexity';

        function initStepComplexitySelector() {
            const container = document.getElementById('step-complexity-container');
            const buttons = document.querySelectorAll('.step-complexity-btn');

            if (!container || buttons.length === 0) {
                console.error('‚ö†Ô∏è Step complexity elements not found');
                return;
            }

            // Load saved complexity or default to 12 (Detailed)
            const savedComplexity = localStorage.getItem(STEP_COMPLEXITY_KEY) || '12';

            // Set active button
            buttons.forEach(btn => {
                const steps = btn.dataset.steps;
                if (steps === savedComplexity) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }

                // Click handler
                btn.addEventListener('click', () => {
                    // Remove active from all
                    buttons.forEach(b => b.classList.remove('active'));
                    // Add active to clicked
                    btn.classList.add('active');
                    // Save to localStorage
                    localStorage.setItem(STEP_COMPLEXITY_KEY, steps);
                    console.log(`üìä Step complexity set to: ${steps} steps`);
                });
            });

            console.log(`‚úÖ Step complexity initialized: ${savedComplexity} steps`);
        }

        function updateStepComplexityVisibility() {
            const container = document.getElementById('step-complexity-container');
            if (!container) return;

            const redModeEnabled = localStorage.getItem('red_mode_enabled') === 'true';
            const intensityLevel = parseInt(localStorage.getItem('intensity_level') || '3');

            // Show only for Red Mode Level 3 (Hardcore)
            if (redModeEnabled && intensityLevel === 3) {
                container.style.display = 'block';
                setTimeout(() => container.classList.add('visible'), 10);
            } else {
                container.classList.remove('visible');
                setTimeout(() => container.style.display = 'none', 300);
            }
        }

        function getStepComplexity() {
            return parseInt(localStorage.getItem(STEP_COMPLEXITY_KEY) || '12');
        }

        async function initializeApp() {
            // Initialize IndexedDB cache system
            try {
                await initIndexedDB();
                console.log('‚úÖ IndexedDB ready');

                // üíæ v2.12.14: Initialize Grok persistence system
                await initGrokDB();
                console.log('‚úÖ Grok IndexedDB ready');

                // üîÑ v2.12.14: Migrate existing Grok videos
                await migrateExistingGrokVideos();

                // üîÑ v2.12.14: Recover Grok videos from IndexedDB
                const recovered = await recoverGrokVideos();
                if (recovered.length > 0) {
                    console.log(`üîÑ Recovered ${recovered.length} Grok videos`);

                    // Merge recovered with videoHistoryData (deduplicate)
                    const existingIds = new Set(videoHistoryData.map(v => v.id));
                    const newRecovered = recovered.filter(v => !existingIds.has(v.id));

                    if (newRecovered.length > 0) {
                        videoHistoryData = [...newRecovered, ...videoHistoryData];
                        renderVideoHistory();
                        console.log(`‚ûï Added ${newRecovered.length} recovered videos to history`);
                    }
                }

                // Run auto-clean on startup
                await cleanExpiredCache();

                // Log cache stats
                const stats = videoCache.getStats();
                console.log(`üìä LRU Cache: ${stats.count} videos, ${stats.currentSizeMB}MB / ${stats.maxSizeMB}MB (${stats.usagePercent}%)`);
            } catch (error) {
                console.error('‚ùå IndexedDB initialization failed:', error);
                console.warn('‚ö†Ô∏è App will work without persistent cache');
            }

            // Setup periodic cleanup (every hour)
            setInterval(async () => {
                console.log('üîÑ Running periodic cache cleanup...');
                await cleanExpiredCache();
            }, 60 * 60 * 1000); // 1 hour

            // ========== START: Storage Monitoring on Startup ==========
            try {
                const storageSize = getLocalStorageSize();
                const storageSizeKB = (storageSize / 1024).toFixed(2);
                console.log(`üìä localStorage usage: ${storageSizeKB}KB`);

                // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞ key
                const breakdown = {};
                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        const size = localStorage[key].length;
                        breakdown[key] = `${(size / 1024).toFixed(2)}KB`;
                    }
                }
                console.log('üìä Storage breakdown:', breakdown);

                // ‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 4MB (‡πÉ‡∏Å‡∏•‡πâ‡∏ñ‡∏∂‡∏á 5-10MB limit)
                if (storageSize > 4 * 1024 * 1024) {
                    console.warn(`‚ö†Ô∏è localStorage usage is high (${storageSizeKB}KB). Auto-cleaning...`);
                    smartCleanupStorage();

                    const newSize = getLocalStorageSize();
                    console.log(`‚úÖ Cleaned up. New size: ${(newSize / 1024).toFixed(2)}KB`);
                }
            } catch (error) {
                console.error('‚ùå Storage monitoring error:', error);
            }
            // ========== END: Storage Monitoring on Startup ==========

            const savedApiKey_ws = localStorage.getItem('wavespeed_api_key');
            if (savedApiKey_ws) {
                apiKeyInput_ws.value = savedApiKey_ws;
            }
            // ‚ö†Ô∏è SECURITY: Never hardcode API keys - users must enter their own

            // Load Gemini API key from localStorage
            const savedApiKey_gemini = localStorage.getItem('gemini_api_key');
            if (savedApiKey_gemini) {
                const apiKeyInput_gemini = document.getElementById('api-key-gemini');
                apiKeyInput_gemini.value = savedApiKey_gemini;
            }

            // Load Grok API key from localStorage
            const savedApiKey_grok = localStorage.getItem('grok_api_key');
            if (savedApiKey_grok) {
                const apiKeyInput_grok = document.getElementById('api-key-grok');
                apiKeyInput_grok.value = savedApiKey_grok;
            }

            // Load imgbb API key from localStorage
            const savedApiKey_imgbb = localStorage.getItem('imgbb_api_key');
            if (savedApiKey_imgbb) {
                const apiKeyInput_imgbb = document.getElementById('api-key-imgbb');
                apiKeyInput_imgbb.value = savedApiKey_imgbb;
            }

            fetchUsageStats_Wavespeed(); // ‡πÇ‡∏´‡∏•‡∏î Wavespeed balance ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤

            // Load API toggle states
            const wavespeedEnabled = localStorage.getItem('wavespeed_api_enabled');
            toggleWavespeedApi.checked = wavespeedEnabled !== 'false'; // Default to true
            updateToggleLabel(toggleWavespeedApi);

            // Cleanup old VideoGen data from localStorage
            localStorage.removeItem('videogen_api_key');
            localStorage.removeItem('videogen_api_enabled');

            // Populate model dropdown from MODEL_CONFIG
            try {
                populateModelDropdown();
            } catch (e) {
                console.error("‚ùå Error populating model dropdown:", e);
            }

            try {
                updateUIForModel(); // Setup UI based on default model first
            } catch (e) {
                console.error("‚ùå Error updating UI for model:", e);
            }

            try {
                loadHistoryFromLocalStorage(); // Load history from local storage
            } catch (e) {
                console.error("‚ùå Error loading history:", e);
            }

            try {
                migrateHistoryData(); // Migrate legacy history items
            } catch (e) {
                console.error("‚ùå Error migrating history:", e);
            }

            try {
                resumePendingPolling(); // Resume polling for pending items
            } catch (e) {
                console.error("‚ùå Error resuming pending polling:", e);
            }

            try {
                initHistoryVisibility(); // Initialize history visibility state
            } catch (e) {
                console.error("‚ùå Error initializing history visibility:", e);
            }

            try {
                initHistoryFilter(); // ‚ú® NEW: Initialize history filter state
            } catch (e) {
                console.error("‚ùå Error initializing history filter:", e);
            }

            try {
                initGridView(); // Initialize grid/list view mode
            } catch (e) {
                console.error("‚ùå Error initializing grid view:", e);
            }

            try {
                initKeepSection(); // Initialize Keep: Prompt Collection
            } catch (e) {
                console.error("‚ùå Error initializing Keep section:", e);
            }

            try {
                initPromptCraft(); // Initialize Prompt Craft (load API key & undo stack)
            } catch (e) {
                console.error("‚ùå Error initializing Prompt Craft:", e);
            }
            // updateImagePreview(); // Don't call this directly, updateUIForModel/updateUIVisibility handles it

            // Phase 5: Restore image from cache on page load
            try {
                restoreImageFromCache();
            } catch (e) {
                console.error("‚ùå Error restoring image from cache:", e);
            }

            // Phase 6: Restore all state from localStorage (v1.10.0 - prompts + craft input + attachments)
            try {
                loadAllStateFromStorage();
            } catch (e) {
                console.error("‚ùå Error loading state:", e);
            }

            // Phase 7: Resume generation if it was in progress before refresh (v1.11.0)
            try {
                resumeGenerationIfNeeded();
            } catch (e) {
                console.error("‚ùå Error resuming generation:", e);
            }

            try {
                setupEventListeners(); // Setup all event listeners
            } catch (e) {
                console.error("‚ùå Error setting up event listeners:", e);
            }

            try {
                initStepComplexitySelector(); // Initialize step complexity selector
                updateStepComplexityVisibility(); // Set initial visibility

                // Wire up intensity level radios to update step complexity visibility
                const intensityRadios = document.querySelectorAll('input[name="intensity-level"]');
                intensityRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        updateStepComplexityVisibility();
                    });
                });
            } catch (e) {
                console.error("‚ùå Error initializing step complexity:", e);
            }

            try {
                initImageEditSystem(); // Initialize Image Edit system for Wan 2.6

                // Initialize Image Edit History system
                if (typeof window.imageEditHistory !== 'undefined') {
                    window.imageEditHistory.init();
                }

                // Initialize Auto-save Toggle (load from localStorage)
                const autoSaveToggle = document.getElementById('auto-save-toggle');
                if (autoSaveToggle) {
                    // Load saved state (default: true/checked)
                    const savedState = localStorage.getItem('imageEditAutoSave');
                    autoSaveToggle.checked = savedState === null ? true : savedState === 'true';

                    // Save state on change
                    autoSaveToggle.addEventListener('change', () => {
                        localStorage.setItem('imageEditAutoSave', autoSaveToggle.checked);
                        console.log('üíæ Auto-save:', autoSaveToggle.checked ? 'ON' : 'OFF');
                    });
                    console.log('‚úÖ Auto-save toggle initialized:', autoSaveToggle.checked ? 'ON' : 'OFF');
                }
            } catch (e) {
                console.error("‚ùå Error initializing Image Edit system:", e);
            }

            // Ensure correct initial state for Wavespeed if it's the default
            // This is now handled within updateUIForModel/updateUIVisibility
        }

        // --- Setup Event Listeners ---
        function setupEventListeners() {
            toggleApiKeyBtn.addEventListener('click', () => {
                const isHidden = apiKeySection.classList.contains('hidden');
                apiKeySection.classList.toggle('hidden');
                apiKeyChevron.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
            });

            // Wavespeed API Key Save Button
            const saveWavespeedBtn = document.getElementById('save-wavespeed-key');
            saveWavespeedBtn.addEventListener('click', () => {
                const key = apiKeyInput_ws.value.trim();
                localStorage.setItem('wavespeed_api_key', key);

                // Visual feedback
                const originalHTML = saveWavespeedBtn.innerHTML;
                saveWavespeedBtn.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Saved!</span>
                `;
                saveWavespeedBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                saveWavespeedBtn.classList.remove('bg-cyan-600', 'hover:bg-cyan-700');

                setTimeout(() => {
                    saveWavespeedBtn.innerHTML = originalHTML;
                    saveWavespeedBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    saveWavespeedBtn.classList.add('bg-cyan-600', 'hover:bg-cyan-700');
                }, 2000);

                if (key) fetchUsageStats_Wavespeed();
                console.log('‚úÖ Wavespeed API key saved to localStorage');
            });

            // Gemini API Key Save Button
            const saveGeminiBtn = document.getElementById('save-gemini-key');
            const apiKeyInput_gemini = document.getElementById('api-key-gemini');
            saveGeminiBtn.addEventListener('click', () => {
                const key = apiKeyInput_gemini.value.trim();
                localStorage.setItem('gemini_api_key', key);

                // Visual feedback
                const originalHTML = saveGeminiBtn.innerHTML;
                saveGeminiBtn.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Saved!</span>
                `;
                saveGeminiBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                saveGeminiBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');

                setTimeout(() => {
                    saveGeminiBtn.innerHTML = originalHTML;
                    saveGeminiBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                    saveGeminiBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                }, 2000);

                console.log('‚úÖ Gemini API key saved to localStorage');
            });

            // Grok API Key Save Button (x.ai)
            const saveGrokBtn = document.getElementById('save-grok-key');
            const apiKeyInput_grok = document.getElementById('api-key-grok');
            saveGrokBtn.addEventListener('click', () => {
                const key = apiKeyInput_grok.value.trim();
                localStorage.setItem('grok_api_key', key);

                // Visual feedback
                const originalHTML = saveGrokBtn.innerHTML;
                saveGrokBtn.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Saved!</span>
                `;
                saveGrokBtn.classList.add('bg-emerald-600', 'hover:bg-emerald-700');
                saveGrokBtn.classList.remove('bg-green-600', 'hover:bg-green-700');

                setTimeout(() => {
                    saveGrokBtn.innerHTML = originalHTML;
                    saveGrokBtn.classList.remove('bg-emerald-600', 'hover:bg-emerald-700');
                    saveGrokBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                }, 2000);

                console.log('‚úÖ Grok API key saved to localStorage');
            });

            // imgbb API Key Save Button (for Grok video generation)
            const saveImgbbBtn = document.getElementById('save-imgbb-key');
            const apiKeyInput_imgbb = document.getElementById('api-key-imgbb');
            saveImgbbBtn.addEventListener('click', () => {
                const key = apiKeyInput_imgbb.value.trim();
                localStorage.setItem('imgbb_api_key', key);

                // Visual feedback
                const originalHTML = saveImgbbBtn.innerHTML;
                saveImgbbBtn.innerHTML = `
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Saved!</span>
                `;
                saveImgbbBtn.classList.add('bg-emerald-600', 'hover:bg-emerald-700');
                saveImgbbBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');

                setTimeout(() => {
                    saveImgbbBtn.innerHTML = originalHTML;
                    saveImgbbBtn.classList.remove('bg-emerald-600', 'hover:bg-emerald-700');
                    saveImgbbBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                }, 2000);

                console.log('‚úÖ imgbb API key saved to localStorage');
            });

            // API Toggle Event Listeners
            toggleWavespeedApi.addEventListener('change', async () => {
                const isEnabled = toggleWavespeedApi.checked;
                localStorage.setItem('wavespeed_api_enabled', isEnabled.toString());
                updateToggleLabel(toggleWavespeedApi);

                if (!isEnabled) {
                    // Ask for confirmation before clearing cache
                    const confirmed = confirm(
                        '‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Wavespeed API ‡∏à‡∏∞‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡πÅ‡∏Ñ‡∏ä‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å Wavespeed ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß\n\n' +
                        '‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?'
                    );

                    if (confirmed) {
                        await clearProviderCache('wavespeed');
                        console.log('Wavespeed API disabled and cache cleared');
                    } else {
                        // Revert toggle if user cancels
                        toggleWavespeedApi.checked = true;
                        localStorage.setItem('wavespeed_api_enabled', 'true');
                        updateToggleLabel(toggleWavespeedApi);
                    }
                } else {
                    console.log('Wavespeed API enabled');
                }
            });

            // Gemini API Toggle Event Listener
            toggleGeminiApi.addEventListener('change', () => {
                const isEnabled = toggleGeminiApi.checked;
                localStorage.setItem('gemini_api_enabled', isEnabled.toString());

                if (!isEnabled) {
                    console.log('Gemini API disabled');
                } else {
                    console.log('Gemini API enabled');
                }
            });

            // Prompt Craft event listeners are now handled by prompt_craft.js module

            // Prompt Expansion checkbox listener (v2.2.4)
            const promptExpansionCheckbox = document.getElementById('prompt-expansion');
            if (promptExpansionCheckbox) {
                promptExpansionCheckbox.addEventListener('change', () => {
                    localStorage.setItem(PROMPT_EXPANSION_KEY, promptExpansionCheckbox.checked.toString());
                    console.log('üíæ Prompt Expansion saved:', promptExpansionCheckbox.checked);
                });
            }

            modelSelect.addEventListener('change', updateUIForModel);

            genTypeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    document.querySelectorAll('.gen-type-icon').forEach(icon => icon.classList.remove('selected'));
                    e.target.closest('label').classList.add('selected');
                    updateUIVisibilityBasedOnGenType();
                });
            });

            // Listen for URL input changes
            imageUrl.addEventListener('input', updateImagePreview);

            aspectCards.forEach(card => {
                card.addEventListener('click', () => {
                    aspectCards.forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedAspectRatio = card.dataset.aspect;
                });
            });

            // Duration Listeners
            durationSelectWavespeed.addEventListener('change', calculateWavespeedCost); // Cost recalculates on change

            resolutionSelect.addEventListener('change', calculateWavespeedCost); // Cost recalculates on change

            generateBtn.addEventListener('click', handleGenerateSubmit);
            cancelGenerationBtn.addEventListener('click', cancelGeneration);

            // ========== Track Manual Prompt Edits & Clear Dimming ==========
            if (promptTextarea) {
                promptTextarea.addEventListener('input', function () {
                    const currentPrompt = promptTextarea.value;

                    // Only flag as manually edited if content changed from crafted version
                    if (promptWasCrafted && currentPrompt !== lastCraftedPrompt) {
                        promptWasManuallyEdited = true;
                        promptWasCrafted = false; // Reset craft flag ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏î‡πâ‡∏ß‡∏¢‡∏°‡∏∑‡∏≠
                        console.log('‚úèÔ∏è Prompt manually edited after craft');
                    }

                    // NEW: Clear dimming effect when prompt text changes from last used prompt
                    if (currentPrompt !== lastUsedPromptForGeneration) {
                        localStorage.setItem('vidist_prompt_copied_state', 'false');
                        if (typeof applyPromptCopiedState === 'function') {
                            applyPromptCopiedState();
                        }
                        console.log('üí° Prompt changed - dimming cleared');
                    }
                });
            }
            // ========== END: Track Manual Edits & Clear Dimming ==========

            closeModalBtn.addEventListener('click', closeVideoModal);
            closeImageModalBtn.addEventListener('click', closeImageModalFunction);
            imageModal.addEventListener('click', closeImageModalOnBackdrop);
            videoModal.addEventListener('click', closeVideoModalOnBackdrop);

            // Use event.code for Thai keyboard support
            document.addEventListener('keydown', function (event) {
                if (event.code === 'Escape') {
                    if (videoModal.classList.contains('flex')) closeVideoModal();
                    if (imageModal.classList.contains('flex')) closeImageModalFunction();
                }
            });

            // ========== START: ‡πÄ‡∏û‡∏¥‡πà‡∏° Listener ‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ==========
            // NEW: Drag and Drop Listeners for Preview Thumbnail (Replace Image)
            if (previewWrapper) {
                previewWrapper.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (imageBase64Data) { // Only if image already uploaded
                        previewDragOverlay.classList.remove('opacity-0', 'group-hover:opacity-0');
                        previewDragOverlay.classList.add('opacity-100');
                        previewWrapper.classList.add('border-2', 'border-cyan-400');
                    }
                });

                previewWrapper.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Check if leaving the wrapper entirely (not just entering a child)
                    if (!previewWrapper.contains(e.relatedTarget)) {
                        previewDragOverlay.classList.remove('opacity-100');
                        previewDragOverlay.classList.add('opacity-0', 'group-hover:opacity-0');
                        previewWrapper.classList.remove('border-2', 'border-cyan-400');
                    }
                });

                previewWrapper.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });

                previewWrapper.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    previewDragOverlay.classList.remove('opacity-100');
                    previewDragOverlay.classList.add('opacity-0', 'group-hover:opacity-0');
                    previewWrapper.classList.remove('border-2', 'border-cyan-400');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        console.log('Replacing image via drag-drop on thumbnail');
                        handleFiles(files); // Replace current image
                    }
                });
            }

            // ========== NEW: Left Sidebar Image Upload Listeners ==========

            // Drag and Drop Listeners for Left Sidebar
            if (dragDropAreaLeft) {
                dragDropAreaLeft.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropAreaLeft.classList.add('bg-cyan-500/20', 'border-cyan-400');
                });

                dragDropAreaLeft.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropAreaLeft.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                });

                dragDropAreaLeft.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropAreaLeft.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFiles(files);
                    }
                });

                // Allow clicking the area to trigger file input
                dragDropAreaLeft.addEventListener('click', (e) => {
                    if (e.target !== browseButtonLeft && !browseButtonLeft.contains(e.target)) {
                        fileInputLeft.click();
                    }
                });
            }

            // Browse Button Listener (Left)
            if (browseButtonLeft) {
                browseButtonLeft.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileInputLeft.click();
                });
            }

            // File Input Listener (Left)
            if (fileInputLeft) {
                fileInputLeft.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleFiles(e.target.files);
                    }
                });
            }

            // ========== NEW: Ctrl+V Paste Image from Clipboard ==========
            document.addEventListener('paste', async (e) => {
                // Only handle paste when not in input/textarea
                const activeElement = document.activeElement;
                const isEditableElement = activeElement.tagName === 'INPUT' ||
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable;

                // Skip if user is typing in an input field (unless it's the image URL input)
                if (isEditableElement && activeElement.id !== 'image-url-left') {
                    return;
                }

                // Check if clipboard has image data
                const items = e.clipboardData?.items;
                if (!items) return;

                // Find image item in clipboard
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();

                        // Get image as blob
                        const blob = item.getAsFile();
                        if (blob) {
                            console.log('üìã Image pasted from clipboard:', blob.type, blob.size);

                            // Create a FileList-like object
                            const files = [blob];
                            handleFiles(files);

                            // Show visual feedback
                            if (dragDropAreaLeft) {
                                dragDropAreaLeft.classList.add('bg-cyan-500/20', 'border-cyan-400');
                                setTimeout(() => {
                                    dragDropAreaLeft.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                                }, 500);
                            }
                        }
                        break;
                    }
                }
            });
            console.log('‚úÖ Ctrl+V paste image handler registered (works with Thai keyboard)');

            // Preview Wrapper Click to Open Modal (Left)
            if (previewWrapperLeft) {
                previewWrapperLeft.addEventListener('click', (e) => {
                    if (!e.target.closest('#delete-image-btn-left')) {
                        // Use global imageBase64Data for edited images, fallback to DOM src
                        const imgSrc = window.imageBase64Data || imagePreviewLeft.src;
                        if (imgSrc && imgSrc !== '#' && imgSrc !== '') {
                            openImageModal(imgSrc);
                        }
                    }
                });
            }

            // Delete Button Listener (Left)
            if (deleteImageBtnLeft) {
                deleteImageBtnLeft.addEventListener('click', (e) => {
                    e.stopPropagation();
                    clearUploadedImage();
                });
            }

            // Image URL Input Listener (Left) - with debounce
            let imageUrlDebounceTimer = null;
            if (imageUrlLeft) {
                imageUrlLeft.addEventListener('input', (e) => {
                    const url = e.target.value.trim();

                    // Clear previous timer
                    if (imageUrlDebounceTimer) {
                        clearTimeout(imageUrlDebounceTimer);
                    }

                    // If URL is empty, clear the image
                    if (!url) {
                        clearUploadedImage();
                        return;
                    }

                    // Debounce: wait 800ms after user stops typing
                    imageUrlDebounceTimer = setTimeout(async () => {
                        try {
                            await handleImageUrl(url);
                        } catch (error) {
                            console.error('Error loading image from URL:', error);
                        }
                    }, 800);
                });
            }

            // Preview Drag & Drop (Replace Image) - Left
            if (previewWrapperLeft) {
                previewWrapperLeft.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (previewDragOverlayLeft) {
                        previewDragOverlayLeft.style.opacity = '1';
                    }
                });

                previewWrapperLeft.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (previewDragOverlayLeft) {
                        previewDragOverlayLeft.style.opacity = '0';
                    }
                });

                previewWrapperLeft.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (previewDragOverlayLeft) {
                        previewDragOverlayLeft.style.opacity = '0';
                    }
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFiles(files);
                    }
                });
            }

            // ========== END: Left Sidebar Listeners ==========

            // ========== NEW: Last Image Upload Listeners (Kling O1) ==========
            const lastImageDropArea = document.getElementById('last-image-drop-area');
            const lastImageFileInput = document.getElementById('last-image-file-input');

            if (lastImageDropArea) {
                lastImageDropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    lastImageDropArea.classList.add('bg-cyan-500/20', 'border-cyan-400');
                });

                lastImageDropArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    lastImageDropArea.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                });

                lastImageDropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    lastImageDropArea.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleLastImageFile(files[0]);
                    }
                });

                // Allow clicking the area to trigger file input
                lastImageDropArea.addEventListener('click', (e) => {
                    const browseBtn = e.target.closest('button');
                    if (!browseBtn) {
                        lastImageFileInput.click();
                    }
                });
            }

            // File Input Listener for Last Image
            if (lastImageFileInput) {
                lastImageFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleLastImageFile(e.target.files[0]);
                    }
                });
            }
            // ========== END: Last Image Listeners ==========

            // OLD: Drag and Drop Listeners for Initial Drag-Drop Area (HIDDEN - Kept for compatibility)
            if (dragDropArea) {
                dragDropArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropArea.classList.add('bg-cyan-500/20', 'border-cyan-400'); // Highlight effect
                });

                dragDropArea.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropArea.classList.remove('bg-cyan-500/20', 'border-cyan-400'); // Remove highlight
                });

                dragDropArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    dragDropArea.classList.remove('bg-cyan-500/20', 'border-cyan-400');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        handleFiles(files);
                    }
                });

                // Allow clicking the area to trigger file input, EXCEPT the button inside
                dragDropArea.addEventListener('click', (e) => {
                    if (e.target !== browseButton && !browseButton.contains(e.target)) { // Check if click is not on button
                        fileInputFallback.click();
                    }
                });
            }
            // Browse Button Listener
            if (browseButton) {
                browseButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering dragDropArea click
                    fileInputFallback.click();
                });
            }

            // Preview Wrapper Click to Open Modal (Enlarge Image)
            if (previewWrapper) {
                previewWrapper.addEventListener('click', (e) => {
                    // Only open modal if clicking on wrapper/image, not delete button
                    if (!e.target.closest('#delete-image-btn')) {
                        const imgSrc = imagePreview.src;
                        if (imgSrc && imgSrc !== '#' && imgSrc !== '') {
                            openImageModal(imgSrc);
                        }
                    }
                });
            }

            // Delete Button Listener
            const deleteImageBtn = document.getElementById('delete-image-btn');
            if (deleteImageBtn) {
                deleteImageBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent opening modal
                    clearUploadedImage();
                });
            }

            // Fallback File Input Listener
            if (fileInputFallback) {
                fileInputFallback.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleFiles(e.target.files);
                    }
                });
            }
            // ========== END: ‡πÄ‡∏û‡∏¥‡πà‡∏° Listener ‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ ==========
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VIDEO UPLOAD HANDLING (for WAN 2.5 Extend)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Video file input handler
        if (videoFileInput) {
            videoFileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await handleVideoFile(file);
                }
            });
        }

        // Video drop zone click handler
        if (videoDropZone) {
            videoDropZone.addEventListener('click', () => {
                videoFileInput.click();
            });

            // Drag over
            videoDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                videoDropZone.classList.add('border-cyan-500');
            });

            // Drag leave
            videoDropZone.addEventListener('dragleave', () => {
                videoDropZone.classList.remove('border-cyan-500');
            });

            // Drop
            videoDropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                videoDropZone.classList.remove('border-cyan-500');

                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('video/')) {
                    await handleVideoFile(file);
                } else {
                    showStatus('Please upload a valid video file', 'error');
                }
            });
        }

        // Video URL input handler
        if (videoUrlInput) {
            videoUrlInput.addEventListener('input', async (e) => {
                const url = e.target.value.trim();
                if (url) {
                    currentVideoUrl = url;
                    currentVideoFile = null;
                    currentVideoBase64 = null;

                    // ========== NEW: Save video URL to localStorage (v1.10.0) ==========
                    saveVideoToStorage(currentVideoUrl, currentVideoBase64);
                    // ========== END ==========

                    // Show preview using URL
                    if (videoPreview && videoPreviewContainer) {
                        videoPreview.src = url;
                        videoPreviewContainer.style.display = 'block';
                    }

                    // Hide drag & drop area once video URL is set
                    if (videoDropZone) {
                        videoDropZone.style.display = 'none';
                    }

                    if (videoInfoSpan) {
                        videoInfoSpan.textContent = 'Using video URL';
                    }

                    console.log('üìπ Video URL set:', url);
                }
            });
        }

        // Remove video button handler
        if (removeVideoBtn) {
            removeVideoBtn.addEventListener('click', () => {
                clearUploadedVideo();
            });
        }

        // Video preview drag & drop (Replace Video)
        if (videoPreviewContainer && videoDragOverlay) {
            videoPreviewContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (videoDragOverlay) {
                    videoDragOverlay.style.opacity = '1';
                }
            });

            videoPreviewContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Only hide if leaving the container entirely (not entering a child element)
                if (!videoPreviewContainer.contains(e.relatedTarget)) {
                    if (videoDragOverlay) {
                        videoDragOverlay.style.opacity = '0';
                    }
                }
            });

            videoPreviewContainer.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Hide overlay
                if (videoDragOverlay) {
                    videoDragOverlay.style.opacity = '0';
                }

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];

                    // Validate it's a video file
                    if (file.type.startsWith('video/')) {
                        console.log('üîÑ Replacing video via drag-drop on preview');

                        // Clear current video first
                        clearUploadedVideo();

                        // Handle new video file
                        await handleVideoFile(file);
                    } else {
                        showStatus('Please drop a video file (MP4, WebM, or MOV)', 'error');
                    }
                }
            });
        }

        // Handle video file upload
        async function handleVideoFile(file) {
            // Validate file type
            const validTypes = ['video/mp4', 'video/webm', 'video/quicktime'];
            if (!validTypes.includes(file.type)) {
                showStatus('Invalid video format. Please use MP4, WebM, or MOV', 'error');
                return;
            }

            // Validate file size (100MB limit)
            const maxSize = 100 * 1024 * 1024; // 100MB
            if (file.size > maxSize) {
                showStatus('Video file too large. Maximum size is 100MB', 'error');
                return;
            }

            currentVideoFile = file;
            currentVideoUrl = null;

            // Show preview
            if (videoPreview && videoPreviewContainer) {
                const objectUrl = URL.createObjectURL(file);
                videoPreview.src = objectUrl;
                videoPreviewContainer.style.display = 'block';
            }

            // Hide drag & drop area once video is uploaded
            if (videoDropZone) {
                videoDropZone.style.display = 'none';
            }

            const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
            if (videoInfoSpan) {
                videoInfoSpan.textContent = `${file.name} ‚Ä¢ ${sizeMB}MB`;
            }

            // Convert to base64 for API (optional - might use direct upload instead)
            try {
                currentVideoBase64 = await fileToBase64(file);
                console.log('üìπ Video file loaded:', file.name, `(${sizeMB}MB)`);

                // ========== NEW: Save video to localStorage (v1.10.0) ==========
                saveVideoToStorage(currentVideoUrl, currentVideoBase64);
                // ========== END ==========
            } catch (error) {
                console.error('Error converting video to base64:', error);
                showStatus('Error processing video file', 'error');
            }
        }

        // Clear uploaded video
        function clearUploadedVideo() {
            currentVideoFile = null;
            currentVideoUrl = null;
            currentVideoBase64 = null;

            // ========== NEW: Clear video from localStorage (v1.10.0) ==========
            saveVideoToStorage(null, null);
            // ========== END ==========

            if (videoPreviewContainer) {
                videoPreviewContainer.style.display = 'none';
            }
            if (videoPreview) {
                videoPreview.src = '';
            }
            if (videoFileInput) {
                videoFileInput.value = '';
            }
            if (videoUrlInput) {
                videoUrlInput.value = '';
            }

            // Restore drag & drop area
            if (videoDropZone) {
                videoDropZone.style.display = '';
            }

            console.log('üìπ Video removed');
        }

        // Helper: Convert file to base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // END: VIDEO UPLOAD HANDLING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // --- Fetch Usage Statistics (Wavespeed) ---
        async function fetchUsageStats_Wavespeed() {
            const apiKey = apiKeyInput_ws.value.trim();
            if (!apiKey) {
                creditBalance.textContent = '$-.---';
                return;
            }
            creditBalance.textContent = '$...'; // ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î

            const WAVESPEED_API_BASE_URL = "https://api.wavespeed.ai/api/v3"; // Ensure base URL is defined

            try {
                // 1. Try new usage_stats endpoint (POST)
                const response = await fetch(`${WAVESPEED_API_BASE_URL}/user/usage_stats`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.code === 200 && data.data && data.data.balance !== undefined) {
                        const balance = data.data.balance;
                        creditBalance.textContent = `$${parseFloat(balance).toFixed(3)}`;
                        return; // Success
                    }
                }

                // 2. Fallback to legacy balance endpoint (GET) if usage_stats fails
                console.warn('Usage stats failed/deprecated, falling back to legacy /balance...');
                const legacyResponse = await fetch(`${WAVESPEED_API_BASE_URL}/balance`, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });

                if (legacyResponse.ok) {
                    const data = await legacyResponse.json();
                    if (data.code === 200 && data.data && data.data.balance !== undefined) {
                        const balance = data.data.balance;
                        creditBalance.textContent = `$${parseFloat(balance).toFixed(3)}`;
                        return; // Success
                    }
                }

                throw new Error('Could not fetch balance from any endpoint');

            } catch (error) {
                console.error('Error fetching Wavespeed balance:', error);
                creditBalance.textContent = '$ERR';
            }
        }

        // --- UI Update Functions ---
        // Update Aspect Ratio Options based on model
        function updateAspectRatioOptions(modelValue) {
            const config = MODEL_CONFIG[modelValue];
            const supportedRatios = config.supportedAspectRatios || ["16:9", "1:1", "9:16"];

            // Get all aspect ratio cards
            const allCards = document.querySelectorAll('.aspect-ratio-card[data-aspect]');
            let firstVisibleCard = null;
            let currentSelectedVisible = false;

            allCards.forEach(card => {
                const aspectValue = card.dataset.aspect;
                const isSupported = supportedRatios.includes(aspectValue);

                // Show/hide based on support
                if (isSupported) {
                    card.style.display = '';
                    if (!firstVisibleCard) firstVisibleCard = card;
                    if (card.classList.contains('selected')) currentSelectedVisible = true;
                } else {
                    card.style.display = 'none';
                    card.classList.remove('selected');
                }
            });

            // If current selection is now hidden, select first visible
            if (!currentSelectedVisible && firstVisibleCard) {
                firstVisibleCard.classList.add('selected');
            }
        }

        function updateUIForModel() {
            const selectedModelValue = modelSelect.value;
            const config = MODEL_CONFIG[selectedModelValue];

            // Guard: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö config ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
            if (!config) {
                console.warn('‚ö†Ô∏è updateUIForModel: No config found for model:', selectedModelValue);
                return;
            }

            currentProvider = config.provider;

            // Update Resolution Options based on model (wan2.5 vs wan2.6)
            const supportedResolutions = config.supportedResolutions || ["480p", "720p", "1080p"];
            const currentRes = resolutionSelect.value;
            resolutionSelect.innerHTML = supportedResolutions.map(res => `<option value="${res}">${res}</option>`).join('');
            // Try to keep selection, default to 480p if available (most cost-effective), else first
            resolutionSelect.value = supportedResolutions.includes(currentRes) ? currentRes : (supportedResolutions.includes('480p') ? '480p' : supportedResolutions[0]);

            // Update Duration Options (wan2.5: 3-10s range, wan2.6: 5,10,15s fixed)
            const savedDuration = parseInt(durationSelectWavespeed.value); // Save before clearing
            durationSelectWavespeed.innerHTML = '';
            if (config.allowedDurations) {
                // wan2.6: Fixed durations
                config.allowedDurations.forEach(d => {
                    durationSelectWavespeed.add(new Option(`${d} seconds`, d));
                });
                durationSelectWavespeed.value = config.allowedDurations[0]; // Default to first
            } else {
                // wan2.5: Range - default to minDuration (most cost-effective)
                for (let i = config.minDuration; i <= config.maxDuration; i++) {
                    durationSelectWavespeed.add(new Option(`${i} seconds`, i));
                }
                const targetDuration = savedDuration || config.minDuration;
                durationSelectWavespeed.value = Math.min(config.maxDuration, Math.max(config.minDuration, targetDuration));
            }
            // Update duration text (if element exists - removed in new layout)
            if (maxDurationText) {
                maxDurationText.textContent = config.allowedDurations ? `Options: ${config.allowedDurations.join(', ')}s` : `Range: ${config.minDuration}-${config.maxDuration}s`;
            }

            // Phase 6: Restore image from cache after model change (don't clear!)
            restoreImageFromCache();

            // Update Generation Type UI (Enable/Disable options)
            const t2vRadio = document.querySelector('input[value="text-to-video"]');
            const i2vRadio = document.querySelector('input[value="image-to-video"]');
            const t2vLabel = t2vRadio?.closest('label');
            const i2vLabel = i2vRadio?.closest('label');

            // Disable T2V for Extend models OR models without t2v feature
            if (t2vRadio) t2vRadio.disabled = config.requiresStartVideo === true || !config.features.includes('t2v');
            if (i2vRadio) i2vRadio.disabled = !config.features.includes('i2v');

            // Update labels only if they exist (removed in new layout)
            if (t2vLabel) {
                t2vLabel.style.opacity = t2vRadio.disabled ? '0.5' : '1';
                t2vLabel.style.pointerEvents = t2vRadio.disabled ? 'none' : 'auto';
            }
            if (i2vLabel) {
                i2vLabel.style.opacity = i2vRadio.disabled ? '0.5' : '1';
                i2vLabel.style.pointerEvents = i2vRadio.disabled ? 'none' : 'auto';
            }

            // Force I2V for models that require start video (Extend models)
            if (config.requiresStartVideo === true) {
                if (i2vRadio) i2vRadio.checked = true;
                if (t2vRadio) t2vRadio.checked = false;
                if (i2vLabel) i2vLabel.classList.add('selected');
                if (t2vLabel) t2vLabel.classList.remove('selected');
            }

            // Force I2V for Wavespeed or if T2V is disabled and checked
            if (config.features.length === 1 && config.features[0] === 'i2v') {
                if (i2vRadio) i2vRadio.checked = true;
                if (t2vRadio) t2vRadio.checked = false;
                if (i2vLabel) i2vLabel.classList.add('selected');
                if (t2vLabel) t2vLabel.classList.remove('selected');
            } else if (t2vRadio?.checked && t2vRadio?.disabled) {
                if (i2vRadio) i2vRadio.checked = true;
                if (i2vLabel) i2vLabel.classList.add('selected');
                if (t2vLabel) t2vLabel.classList.remove('selected');
            } else if (i2vRadio?.checked && i2vRadio?.disabled) {
                if (t2vRadio) t2vRadio.checked = true;
                if (t2vLabel) t2vLabel.classList.add('selected');
                if (i2vLabel) i2vLabel.classList.remove('selected');
            }
            // Ensure at least one is selected if both enabled
            if (t2vRadio && i2vRadio && !t2vRadio.disabled && !i2vRadio.disabled && !t2vRadio.checked && !i2vRadio.checked) {
                t2vRadio.checked = true; // Default to T2V if available
                if (t2vLabel) t2vLabel.classList.add('selected');
                if (i2vLabel) i2vLabel.classList.remove('selected');
            }

            // Call this AFTER setting gen type to ensure correct visibility
            updateUIVisibilityBasedOnGenType();

            // Update aspect ratio options based on model support
            updateAspectRatioOptions(selectedModelValue);

            // Show/Hide Wavespeed Options (always Wavespeed now)
            wavespeedCostSection.classList.remove('hidden');
            negativePromptSection.classList.toggle('hidden', !config.supportsNegativePrompt);
            audioUrlSection.classList.toggle('hidden', !config.supportsAudio);

            // Show/Hide AI Prompt Enhancer (Wan 2.5 + 2.6)
            const promptExpansionSection = document.getElementById('prompt-expansion-section');
            if (promptExpansionSection) {
                promptExpansionSection.classList.toggle('hidden', !config.supportsExpansion);
            }

            // Show/Hide Shot Type (Wan 2.6 Only)
            const shotTypeSection = document.getElementById('shot-type-section');
            if (shotTypeSection) {
                shotTypeSection.classList.toggle('hidden', !config.supportsShotType);
            }

            // Show/Hide Last Image Upload (Kling O1 Only)
            const lastImageSection = document.getElementById('last-image-section');
            if (lastImageSection) {
                lastImageSection.classList.toggle('hidden', !config.supportsLastImage);
            }

            calculateWavespeedCost(); // Recalculate cost
        }
        // ========== END: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ ==========

        // ========== START: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ ==========
        // Helper to update UI visibility based on Generation Type and Provider
        function updateUIVisibilityBasedOnGenType() {
            const selectedType = document.querySelector('input[name="gen-type"]:checked').value;
            const config = MODEL_CONFIG[modelSelect.value];
            const isWavespeed = config.provider === 'wavespeed';

            // Show/Hide Image Upload Section (always show for I2V, including Extend models)
            const showImageSection = selectedType === 'image-to-video' && config.features.includes('i2v');
            imageUploadSection.classList.toggle('hidden', !showImageSection);

            // Show/Hide Video Upload Section (only for models that require start video)
            const showVideoSection = config.requiresStartVideo === true;
            console.log('üé¨ Video Upload Section:', {
                requiresStartVideo: config.requiresStartVideo,
                showVideoSection: showVideoSection,
                elementExists: !!videoUploadSection
            });
            if (videoUploadSection) {
                videoUploadSection.classList.toggle('hidden', !showVideoSection);
                console.log('‚úÖ Video section visibility updated:', !showVideoSection ? 'HIDDEN' : 'VISIBLE');
            } else {
                console.error('‚ùå videoUploadSection element NOT FOUND!');
            }

            if (showImageSection) {
                // Restore image from cache when switching back to I2V
                restoreImageFromCache();

                // Inside Image Upload Section: Show DragDrop for Wavespeed, URL input otherwise
                imageUrlInputGroup.classList.toggle('hidden', isWavespeed); // Hide URL input for Wavespeed I2V

                // Wavespeed: Use drag-drop for image upload
                imageUrl.required = false; // URL not required if using drag/drop
                // Show drag-drop ONLY if no image uploaded yet
                // Show preview ONLY if base64 data exists
                const hasImage = !!imageBase64Data;
                dragDropArea.classList.toggle('hidden', hasImage);
                imagePreviewContainer.classList.toggle('hidden', !hasImage);
            } else {
                // Hide everything related to image input if not I2V
                dragDropArea.classList.add('hidden');
                imageUrlInputGroup.classList.add('hidden');
                imagePreviewContainer.classList.add('hidden');
                // Don't clear cache - let persistence handle it
            }

            // Aspect ratio visibility (hide for I2V AND Extend models)
            const hideAspectRatio = selectedType === 'image-to-video' || config.requiresStartVideo === true;
            aspectRatioSection.classList.toggle('hidden', hideAspectRatio);
        }
        // ========== END: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ ==========

        // Image preview for Wavespeed (base64) is handled by handleFiles function
        function updateImagePreview() {
            // Wavespeed uses base64 upload, not URL input
            // Preview is handled by drag-and-drop file handler
        }

        function calculateWavespeedCost() {
            const config = MODEL_CONFIG[modelSelect.value];
            if (config.provider !== 'wavespeed' || !config.pricing) {
                wavespeedCost.textContent = '$0.00';
                wavespeedCostSection.classList.add('hidden'); // Hide if not applicable
                return;
            }
            wavespeedCostSection.classList.remove('hidden'); // Show if applicable
            const duration = parseInt(durationSelectWavespeed.value);
            const resolution = resolutionSelect.value;
            const rate = config.pricing[resolution];
            if (rate && duration) { wavespeedCost.textContent = `$${(rate * duration).toFixed(2)}`; }
            else { wavespeedCost.textContent = '$?.??'; }
        }

        // ========== START: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏µ‡πâ ==========
        // --- Clear Uploaded Image Function ---
        function clearUploadedImage() {
            imageBase64Data = null;
            window.imageBase64Data = null; // ‚ú® NEW: Clear window sync

            // ========== NEW: Clear image from localStorage (v1.10.0) ==========
            saveImageToStorage(null);
            // ========== END ==========

            // Update left sidebar elements
            if (imagePreviewLeft) imagePreviewLeft.src = '#';
            if (modalImageFull) modalImageFull.src = '#';
            if (imagePreviewContainerLeft) imagePreviewContainerLeft.classList.add('hidden');
            if (dragDropAreaLeft) dragDropAreaLeft.classList.remove('hidden');
            if (fileInputLeft) fileInputLeft.value = null;
            if (imageUrlLeft) imageUrlLeft.value = '';

            // Update old elements (for compatibility)
            if (imagePreview) imagePreview.src = '#';
            if (imagePreviewContainer) imagePreviewContainer.classList.add('hidden');
            if (dragDropArea) dragDropArea.classList.remove('hidden');
            if (fileInputFallback) fileInputFallback.value = null;
            if (imageUrl) imageUrl.value = '';

            clearImageCache(); // Clear from localStorage
            console.log('‚úÖ Image cleared from left sidebar');

            // Update Image Edit Controls visibility
            updateImageEditControls();
        }

        // --- Handle Image URL Function ---
        async function handleImageUrl(url) {
            // 1. Validate URL format
            try {
                new URL(url);
            } catch (e) {
                console.warn('‚ö†Ô∏è Invalid URL format:', url);
                return;
            }

            console.log('üì• Loading image from URL:', url);

            // 2. Use <img> element to load image (bypasses CORS for display)
            // Then try to draw to canvas to get base64
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Try with CORS first for canvas access

                img.onload = () => {
                    try {
                        // Try to draw image to canvas to extract base64
                        const canvas = document.createElement('canvas');
                        canvas.width = img.naturalWidth;
                        canvas.height = img.naturalHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        // Get base64 data (this will throw if CORS blocked)
                        imageBase64Data = canvas.toDataURL('image/png');
                        window.imageBase64Data = imageBase64Data; // ‚ú® NEW: Sync to window for history navigation

                        // ========== NEW: Save image to localStorage (v1.11.0) ==========
                        saveImageToStorage(imageBase64Data);
                        // ========== END ==========

                        // Update preview elements (LEFT SIDEBAR)
                        if (imagePreviewLeft) imagePreviewLeft.src = imageBase64Data;
                        if (modalImageFull) modalImageFull.src = imageBase64Data;
                        if (imagePreviewContainerLeft) imagePreviewContainerLeft.classList.remove('hidden');
                        if (dragDropAreaLeft) dragDropAreaLeft.classList.add('hidden');

                        // Update old elements (compatibility)
                        if (imagePreview) imagePreview.src = imageBase64Data;
                        if (imagePreviewContainer) imagePreviewContainer.classList.remove('hidden');
                        if (dragDropArea) dragDropArea.classList.add('hidden');

                        // Add to history
                        if (typeof window.imageEditHistory !== 'undefined') {
                            window.imageEditHistory.add(imageBase64Data);
                        }

                        console.log('‚úÖ Image loaded from URL (base64 mode):', url);
                        resolve();
                    } catch (canvasError) {
                        // Canvas tainted by CORS - fallback to URL mode
                        console.warn('‚ö†Ô∏è Canvas tainted by CORS, trying URL mode...');
                        handleImageUrlFallback(url, resolve, reject);
                    }
                };

                img.onerror = () => {
                    // crossOrigin failed, try without it
                    console.log('üîÑ Retrying without crossOrigin attribute...');
                    handleImageUrlFallback(url, resolve, reject);
                };

                img.src = url;
            });
        }

        // Fallback: Load image without crossOrigin (for display + send URL to API)
        function handleImageUrlFallback(url, resolve, reject) {
            const img2 = new Image();
            // No crossOrigin - allows display but not canvas extraction

            img2.onload = () => {
                // Store URL directly - Wavespeed API supports image URLs!
                imageBase64Data = url;
                window.imageBase64Data = url; // ‚ú® NEW: Sync to window for history navigation

                // ========== NEW: Save image URL to localStorage (v1.11.0) ==========
                saveImageToStorage(url);
                // ========== END ==========

                // Update preview with the image element's src
                if (imagePreviewLeft) imagePreviewLeft.src = url;
                if (modalImageFull) modalImageFull.src = url;
                if (imagePreviewContainerLeft) imagePreviewContainerLeft.classList.remove('hidden');
                if (dragDropAreaLeft) dragDropAreaLeft.classList.add('hidden');

                if (imagePreview) imagePreview.src = url;
                if (imagePreviewContainer) imagePreviewContainer.classList.remove('hidden');
                if (dragDropArea) dragDropArea.classList.add('hidden');

                // Add to history
                if (typeof window.imageEditHistory !== 'undefined') {
                    window.imageEditHistory.add(url);
                }

                console.log('‚úÖ Image loaded from URL (URL mode):', url);
                console.log('‚ÑπÔ∏è Image will be sent as URL to API (not base64)');
                resolve();
            };

            img2.onerror = () => {
                console.error('‚ùå Failed to load image from URL');
                alert('‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡∏à‡∏≤‡∏Å URL ‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ\n\nüí° ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ URL ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞');
                reject(new Error('Failed to load image'));
            };

            img2.src = url;
        }

        // ========== START: Last Image Functions (Kling O1) ==========
        function clearLastImage() {
            lastImageBase64Data = null;

            const lastImagePreview = document.getElementById('last-image-preview');
            const lastImagePreviewContainer = document.getElementById('last-image-preview-container');
            const lastImageDropArea = document.getElementById('last-image-drop-area');
            const lastImageFileInput = document.getElementById('last-image-file-input');

            if (lastImagePreview) lastImagePreview.src = '#';
            if (lastImagePreviewContainer) lastImagePreviewContainer.classList.add('hidden');
            if (lastImageDropArea) lastImageDropArea.classList.remove('hidden');
            if (lastImageFileInput) lastImageFileInput.value = null;

            console.log('‚úÖ Last image cleared');
        }

        async function handleLastImageFile(file) {
            // Validate file type
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
            if (!allowedTypes.includes(file.type)) {
                alert('Invalid file type. Please use JPG, PNG, or WEBP.');
                return;
            }

            // Validate size (max 25MB)
            const maxSizeMB = 25;
            const recommendedMaxMB = 5;
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);

            // üö´ Block files > 25MB
            if (file.size > maxSizeMB * 1024 * 1024) {
                alert(`‚ùå ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ!\n\n‡∏Ç‡∏ô‡∏≤‡∏î: ${fileSizeMB}MB\n‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: ${maxSizeMB}MB\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤`);
                return;
            }

            // ‚ö†Ô∏è Warning for files > 5MB (recommended max for performance)
            if (file.size > recommendedMaxMB * 1024 * 1024) {
                const userConfirmed = confirm(
                    `‚ö†Ô∏è ‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà! (Last Image)\n\n` +
                    `‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå: ${fileSizeMB}MB\n` +
                    `‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô ${recommendedMaxMB}MB\n\n` +
                    `‡∏£‡∏π‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡∏≠‡∏≤‡∏à‡∏ó‡∏≥‡πÉ‡∏´‡πâ:\n` +
                    `‚Ä¢ ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡πâ‡∏≤\n` +
                    `‚Ä¢ ‡πÄ‡∏Å‡∏¥‡∏î Error ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°\n` +
                    `‚Ä¢ ‡πÉ‡∏ä‡πâ RAM ‡∏°‡∏≤‡∏Å\n\n` +
                    `‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î\n\n` +
                    `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`
                );

                if (!userConfirmed) {
                    console.log('‚ÑπÔ∏è User cancelled large last image upload');
                    return;
                }

                console.warn(`‚ö†Ô∏è Large last image: ${fileSizeMB}MB (recommended max: ${recommendedMaxMB}MB)`);
            }

            // Read file as Data URL
            const reader = new FileReader();
            reader.onload = function (e) {
                lastImageBase64Data = e.target.result;

                const lastImagePreview = document.getElementById('last-image-preview');
                const lastImagePreviewContainer = document.getElementById('last-image-preview-container');
                const lastImageDropArea = document.getElementById('last-image-drop-area');

                if (lastImagePreview) lastImagePreview.src = lastImageBase64Data;
                if (lastImagePreviewContainer) lastImagePreviewContainer.classList.remove('hidden');
                if (lastImageDropArea) lastImageDropArea.classList.add('hidden');

                console.log('‚úÖ Last image uploaded');
            };
            reader.onerror = function (e) {
                console.error("FileReader error:", e);
                alert("Error reading file.");
            };
            reader.readAsDataURL(file);
        }
        // ========== END: Last Image Functions ==========

        // ========== START: Image Persistence Cache Functions (Phase 1) ==========
        const IMAGE_CACHE_KEY = 'vidist_i2v_image_cache';
        const CACHE_EXPIRY_DAYS = 7;
        const MAX_THUMBNAIL_SIZE_KB = 100;
        const THUMBNAIL_MAX_DIMENSION = 200;

        // Check if cache is expired
        function isCacheExpired(timestamp) {
            const now = Date.now();
            const expiryMs = CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000;
            return (now - timestamp) > expiryMs;
        }

        // Save image to localStorage cache (‡πÉ‡∏ä‡πâ Smart Storage Management)
        // ‚ö†Ô∏è CRITICAL FIX: ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡πá‡∏ö base64 ‡πÉ‡∏ô localStorage ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ!
        function saveImageToCache(data) {
            // üö´ ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡πá‡∏ö base64 images ‡πÉ‡∏ô localStorage (‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ 1-5MB+)
            // ‡πÄ‡∏Å‡πá‡∏ö‡πÅ‡∏Ñ‡πà URL ‡πÅ‡∏•‡∏∞ thumbnail ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å
            const cacheData = {
                imageType: data.imageType, // 'url' or 'base64'
                imageUrl: data.imageUrl || null, // ‡πÄ‡∏Å‡πá‡∏ö URL ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                imageBase64: null, // ‚ùå ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡πá‡∏ö base64 (‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
                thumbnailPreview: data.thumbnailPreview || null, // ‡πÄ‡∏Å‡πá‡∏ö thumbnail (‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å)
                timestamp: Date.now(),
                provider: currentProvider,
                fileName: data.fileName || null,
                fileSize: data.fileSize || null,
                mimeType: data.mimeType || null
            };

            // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
            const dataString = JSON.stringify(cacheData);
            const dataSizeKB = (dataString.length / 1024).toFixed(2);

            // ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤ 100KB ‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
            if (dataString.length > 100 * 1024) {
                console.warn(`‚ö†Ô∏è Image cache data too large (${dataSizeKB}KB), skipping save`);
                console.log('üí° Large images should be re-fetched from URL, not cached in localStorage');
                return false;
            }

            // ‡πÉ‡∏ä‡πâ safe version ‡∏ó‡∏µ‡πà‡∏°‡∏µ auto-cleanup
            const success = safeSetLocalStorage(IMAGE_CACHE_KEY, dataString);

            if (success) {
                console.log('‚úÖ Image metadata saved to cache (URL only, no base64):', {
                    type: cacheData.imageType,
                    provider: cacheData.provider,
                    hasUrl: !!cacheData.imageUrl,
                    hasThumbnail: !!cacheData.thumbnailPreview,
                    size: `${dataSizeKB}KB`
                });
            } else {
                console.warn('‚ö†Ô∏è Failed to save image cache (storage quota exceeded)');
            }

            return success;
        }

        // Load image from localStorage cache
        function loadImageFromCache() {
            try {
                const cached = localStorage.getItem(IMAGE_CACHE_KEY);
                if (!cached) {
                    console.log('üì≠ No image cache found');
                    return null;
                }

                const cacheData = JSON.parse(cached);

                // Check expiry
                if (isCacheExpired(cacheData.timestamp)) {
                    console.log('‚è∞ Cache expired, clearing...');
                    clearImageCache();
                    return null;
                }

                console.log('‚úÖ Image loaded from cache:', {
                    type: cacheData.imageType,
                    provider: cacheData.provider,
                    age: Math.floor((Date.now() - cacheData.timestamp) / 1000 / 60) + ' minutes'
                });

                return cacheData;
            } catch (error) {
                console.error('‚ùå Error loading cache:', error);
                clearImageCache(); // Clear corrupted cache
                return null;
            }
        }

        // Clear image cache from localStorage
        function clearImageCache() {
            try {
                localStorage.removeItem(IMAGE_CACHE_KEY);
                console.log('üóëÔ∏è Image cache cleared');
            } catch (error) {
                console.error('‚ùå Error clearing cache:', error);
            }
        }

        // Create thumbnail from base64 image (for large images)
        async function createThumbnail(base64Data, maxSizeKB = MAX_THUMBNAIL_SIZE_KB) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = function () {
                    // Calculate new dimensions
                    let width = img.width;
                    let height = img.height;
                    if (width > THUMBNAIL_MAX_DIMENSION || height > THUMBNAIL_MAX_DIMENSION) {
                        if (width > height) {
                            height = Math.round(height * THUMBNAIL_MAX_DIMENSION / width);
                            width = THUMBNAIL_MAX_DIMENSION;
                        } else {
                            width = Math.round(width * THUMBNAIL_MAX_DIMENSION / height);
                            height = THUMBNAIL_MAX_DIMENSION;
                        }
                    }

                    // Create canvas and draw
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Try different quality levels to meet size requirement
                    let quality = 0.7;
                    let thumbnailData = canvas.toDataURL('image/jpeg', quality);

                    // Check size and reduce quality if needed
                    while (thumbnailData.length > maxSizeKB * 1024 && quality > 0.1) {
                        quality -= 0.1;
                        thumbnailData = canvas.toDataURL('image/jpeg', quality);
                    }

                    console.log('üñºÔ∏è Thumbnail created:', {
                        originalSize: Math.round(base64Data.length / 1024) + 'KB',
                        thumbnailSize: Math.round(thumbnailData.length / 1024) + 'KB',
                        dimensions: `${width}x${height}`,
                        quality: quality
                    });

                    resolve(thumbnailData);
                };
                img.onerror = reject;
                img.src = base64Data;
            });
        }

        // Restore image from cache on page load/model change
        async function restoreImageFromCache() {
            const genType = document.querySelector('input[name="gen-type"]:checked').value;

            // Only restore if in I2V mode
            if (genType !== 'image-to-video') {
                console.log('‚è≠Ô∏è Not in I2V mode, skipping cache restore');
                return;
            }

            const cached = loadImageFromCache();
            if (!cached) return;

            // Provider-specific restore
            if (cached.imageType === 'url' && cached.imageUrl) {
                // URL-based
                imageUrl.value = cached.imageUrl;
                imagePreview.src = cached.thumbnailPreview || cached.imageUrl;
                modalImageFull.src = cached.imageUrl;
                imagePreviewContainer.classList.remove('hidden');
                dragDropArea.classList.add('hidden');
                console.log('‚úÖ URL restored from cache:', cached.imageUrl);
            } else if (cached.imageType === 'base64' && cached.imageBase64) {
                // Base64 upload (Wavespeed)
                imageBase64Data = cached.imageBase64;
                window.imageBase64Data = cached.imageBase64; // ‚ú® NEW: Sync to window for history navigation
                imagePreview.src = cached.thumbnailPreview || cached.imageBase64;
                modalImageFull.src = cached.imageBase64;
                imagePreviewContainer.classList.remove('hidden');
                dragDropArea.classList.add('hidden');
                console.log('‚úÖ Base64 image restored from cache');
            }

            // Update Image Edit Controls visibility
            updateImageEditControls();
        }
        // ========== END: Image Persistence Cache Functions (Phase 1) ==========

        // --- Add New File Handling Function ---
        function handleFiles(files) {
            const file = files[0]; // Handle only the first file
            if (!file) return;

            // 1. Validate Type
            const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
            if (!allowedTypes.includes(file.type)) {
                alert('Invalid file type. Please use JPG, PNG, or WEBP.');
                return;
            }

            // 2. Validate Size (Max 25MB based on Fal.ai/Wavespeed docs)
            const maxSizeMB = 25;
            const recommendedMaxMB = 5;
            const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);

            // üö´ Block files > 25MB
            if (file.size > maxSizeMB * 1024 * 1024) {
                alert(`‚ùå ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ!\n\n‡∏Ç‡∏ô‡∏≤‡∏î: ${fileSizeMB}MB\n‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: ${maxSizeMB}MB\n\n‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤`);
                return;
            }

            // ‚ö†Ô∏è Warning for files > 5MB (recommended max for performance)
            if (file.size > recommendedMaxMB * 1024 * 1024) {
                const userConfirmed = confirm(
                    `‚ö†Ô∏è ‡∏Ñ‡∏≥‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà!\n\n` +
                    `‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå: ${fileSizeMB}MB\n` +
                    `‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥: ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô ${recommendedMaxMB}MB\n\n` +
                    `‡∏£‡∏π‡∏õ‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡∏≠‡∏≤‡∏à‡∏ó‡∏≥‡πÉ‡∏´‡πâ:\n` +
                    `‚Ä¢ ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡πâ‡∏≤\n` +
                    `‚Ä¢ ‡πÄ‡∏Å‡∏¥‡∏î Error ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°\n` +
                    `‚Ä¢ ‡πÉ‡∏ä‡πâ RAM ‡∏°‡∏≤‡∏Å\n\n` +
                    `‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î\n\n` +
                    `‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡∏ô‡∏µ‡πâ‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`
                );

                if (!userConfirmed) {
                    console.log('‚ÑπÔ∏è User cancelled large image upload');
                    return;
                }

                console.warn(`‚ö†Ô∏è Large image: ${fileSizeMB}MB (recommended max: ${recommendedMaxMB}MB)`);
            }

            // 3. Read File as Data URL (Base64)
            const reader = new FileReader();
            reader.onload = async function (e) {
                imageBase64Data = e.target.result; // Store the full Data URL
                window.imageBase64Data = e.target.result; // ‚ú® NEW: Sync to window for history navigation

                // ========== NEW: Save image to localStorage for refresh persistence (v1.10.0) ==========
                saveImageToStorage(imageBase64Data);
                // ========== END ==========

                // 4. Update Preview - LEFT SIDEBAR
                if (imagePreviewLeft) imagePreviewLeft.src = imageBase64Data;
                if (modalImageFull) modalImageFull.src = imageBase64Data;
                if (imagePreviewContainerLeft) imagePreviewContainerLeft.classList.remove('hidden');
                if (dragDropAreaLeft) dragDropAreaLeft.classList.add('hidden');
                if (imageUrlLeft) imageUrlLeft.value = '';

                // 4b. Update old elements (for compatibility)
                if (imagePreview) imagePreview.src = imageBase64Data;
                if (imagePreviewContainer) imagePreviewContainer.classList.remove('hidden');
                if (dragDropArea) dragDropArea.classList.add('hidden');
                if (imageUrl) imageUrl.value = '';

                console.log('‚úÖ Image uploaded to left sidebar, preview shown');

                // Update Image Edit Controls visibility
                updateImageEditControls();

                // Add uploaded image to history as position 1/N
                if (typeof window.imageEditHistory !== 'undefined') {
                    window.imageEditHistory.add(imageBase64Data);
                    console.log('üì∏ Initial image added to history');
                }

                // 5. Save to cache (Phase 2)
                try {
                    // Create thumbnail for large images (>2MB)
                    const fileSizeKB = file.size / 1024;
                    let thumbnailPreview = null;

                    if (fileSizeKB > 2048) { // >2MB
                        console.log('üì¶ Large image detected, creating thumbnail...');
                        thumbnailPreview = await createThumbnail(imageBase64Data);
                    }

                    // Save to localStorage
                    saveImageToCache({
                        imageType: 'base64',
                        imageBase64: imageBase64Data,
                        thumbnailPreview: thumbnailPreview,
                        fileName: file.name,
                        fileSize: file.size,
                        mimeType: file.type
                    });
                } catch (error) {
                    console.error('‚ùå Error saving image to cache:', error);
                }
            }
            reader.onerror = function (e) {
                console.error("FileReader error:", e);
                alert("Error reading file.");
                imageBase64Data = null;
                window.imageBase64Data = null; // ‚ú® NEW: Clear window sync
                imagePreviewContainer.classList.add('hidden');
            }
            reader.readAsDataURL(file);

            // Reset file input value to allow selecting the same file again if needed
            fileInputFallback.value = null;
        }
        // ========== END: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏µ‡πâ ==========

        // --- Sync UI Helper Function (for single UI set) ---
        function syncBothUIs(action, data = {}) {
            switch (action) {
                case 'updateStatusBadge':
                    statusBadge.className = `status-badge ${data.className}`;
                    statusBadge.textContent = data.text;
                    break;
                case 'updateStatusText':
                    statusText.textContent = data.text;
                    break;
                case 'updateProgress':
                    // OLD: progressBar.style.width = data.width;
                    // NEW: Convert width string to percentage number
                    const percentMatch = data.width.match(/(\d+)/);
                    if (percentMatch) {
                        const percent = parseInt(percentMatch[1], 10);
                        updateSegmentedProgress(percent);
                    }
                    break;
                case 'updateGenerationDetails':
                    const detailsDiv = document.getElementById('generation-details-top');
                    if (data.id) {
                        generationId.textContent = data.id;
                        detailsDiv.classList.remove('hidden');
                    }
                    if (data.elapsed) {
                        elapsedTime.textContent = data.elapsed;
                    }
                    break;
                case 'enableButtons':
                    generateBtn.disabled = false;
                    break;
                case 'disableButtons':
                    generateBtn.disabled = true;
                    break;
                case 'showCancelButton':
                    cancelGenerationBtn.classList.remove('hidden');
                    break;
                case 'hideCancelButton':
                    cancelGenerationBtn.classList.add('hidden');
                    break;
            }
        }

        // --- API Call Functions ---
        async function handleGenerateSubmit() {
            // Null checks for critical DOM elements
            if (!modelSelect || !apiKeyInput_ws || !promptTextarea || !durationSelectWavespeed || !resolutionSelect) {
                console.error('‚ùå Critical DOM elements not found');
                alert('‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏á‡∏Ñ‡πå‡∏õ‡∏£‡∏∞‡∏Å‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏´‡∏ô‡πâ‡∏≤');
                return;
            }

            const selectedModelValue = modelSelect.value;
            const config = MODEL_CONFIG[selectedModelValue];
            currentProvider = config.provider; // Set provider for this run

            // Get API key based on provider
            let apiKey;
            if (config.provider === 'grok') {
                // Get Grok API key
                apiKey = getGrokApiKey();
                if (!apiKey) {
                    alert('‚ùå Please enter your Grok API Key in Settings.\n\nGet one at: https://console.x.ai/');
                    return;
                }

                // Check imgbb API key for video generation (required for public URL upload)
                const imgbbKey = localStorage.getItem('imgbb_api_key');
                if (!imgbbKey) {
                    alert('‚ùå Please enter your imgbb API Key in Settings.\n\nRequired for Grok video generation (image hosting).\nGet one at: https://api.imgbb.com/');
                    return;
                }
            } else {
                // Get Wavespeed API key
                apiKey = apiKeyInput_ws.value.trim();
                if (!apiKey) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Wavespeed API key');
                    apiKeySection.classList.remove('hidden');
                    apiKeyChevron.style.transform = 'rotate(180deg)';
                    return;
                }
            }

            const prompt = promptTextarea.value.trim();
            if (!prompt) { alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Prompt'); return; }

            // ========== Smart Duplicate Detection ==========
            // Only warn if prompt is EXACTLY the same as the last one used for video generation
            const currentPrompt = promptTextarea.value.trim();

            if (currentPrompt && currentPrompt === lastUsedPromptForGeneration) {
                // Prompt is identical to the last one used for video generation
                const promptPreview = currentPrompt.substring(0, 100) + (currentPrompt.length > 100 ? '...' : '');
                const confirmMessage = `üîÅ ‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß

‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå: "${promptPreview}"

‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÄ‡∏î‡∏¥‡∏°‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?

‚Ä¢ ‡∏Å‡∏î "‡∏ï‡∏Å‡∏•‡∏á" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏î‡πâ‡∏ß‡∏¢‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå‡πÄ‡∏î‡∏¥‡∏°
‚Ä¢ ‡∏Å‡∏î "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡πå`;

                if (!confirm(confirmMessage)) {
                    console.log('üõë Video generation cancelled - user wants to modify prompt');
                    return; // Cancel video generation
                } else {
                    console.log('‚úÖ User confirmed to reuse same prompt');
                }
            } else {
                // Prompt is different (or first generation) - proceed without warning
                console.log('‚úÖ Prompt is new or modified - proceeding with generation');
            }
            // ========== END: Smart Duplicate Detection ==========

            const genTypeElement = document.querySelector('input[name="gen-type"]:checked');
            if (!genTypeElement) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á');
                return;
            }
            const genType = genTypeElement.value;

            // Check for image (Wavespeed uses base64 upload)
            if (genType === 'image-to-video' && !imageBase64Data) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≤‡∏Å‡∏ß‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Prompt Craft)');
                return;
            }

            // Check for start video (Video Extend models only)
            if (config.requiresStartVideo === true) {
                if (!currentVideoUrl && !currentVideoBase64) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î Start Video ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà Video URL');
                    return;
                }
            }

            // Get Duration from Wavespeed dropdown
            const duration = parseInt(durationSelectWavespeed.value);
            // Validate duration
            if (!duration || duration < config.minDuration || duration > config.maxDuration) {
                alert(`Duration ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ${selectedModelValue} ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á ${config.minDuration}s ‡∏ñ‡∏∂‡∏á ${config.maxDuration}s.`);
                return;
            }

            const resolution = resolutionSelect.value;
            const selectedAspectCard = document.querySelector('.aspect-ratio-card.selected[data-aspect]');
            if (!selectedAspectCard) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Aspect Ratio');
                return;
            }
            const aspectRatio = selectedAspectCard.dataset.aspect;
            const negativePrompt = negativePromptInput.value.trim();
            const audioUrlValue = audioUrlInput.value.trim();

            // Get Shot Type and Prompt Expansion (Wan 2.6 only)
            const shotTypeSelect = document.getElementById('shot-type');
            const promptExpansionCheckbox = document.getElementById('prompt-expansion');
            const shotType = shotTypeSelect?.value || 'single';
            const promptExpansion = promptExpansionCheckbox?.checked || false;

            console.log('üìã Generation parameters:', {
                model: selectedModelValue,
                shotType,
                promptExpansion,
                duration,
                resolution
            });

            // --- Start UI Loading State ---
            generateBtn.disabled = true;
            generateSpinner.classList.remove('hidden');
            statusBadge.className = 'status-badge status-pending';
            statusBadge.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠';
            statusText.textContent = `üì§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÑ‡∏õ‡∏¢‡∏±‡∏á ${currentProvider.toUpperCase()} API...`;
            // OLD: progressBar.style.width = '0%';
            // NEW: Reset segmented progress bar
            updateSegmentedProgress(0);
            generationProvider.textContent = currentProvider.toUpperCase();
            generationId.textContent = '-';
            elapsedTime.textContent = '0s';
            startTime = Date.now();
            if (pollingLoop) clearInterval(pollingLoop); // ‚úÖ Clear old consolidated loop before starting new generation

            // ========== ‚ú® Show hologram overlay on source image during generation ==========
            if (genType === 'image-to-video' && imageBase64Data) {
                showVideoGenerationOverlay('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠...');
            }
            // ========== END: Hologram Overlay ==========

            // ========== ‚úÖ PERFORMANCE FIX: Cancel Previous Request ==========
            if (AppState.generation.abortController) {
                AppState.generation.abortController.abort();
                console.log('üõë Previous generation request cancelled');
            }
            // Create new AbortController for this generation
            AppState.generation.abortController = new AbortController();
            // ========== End of Request Cancellation ==========

            cancelGenerationBtn.classList.remove('hidden');
            currentGenerationId = null; // Reset generation ID
            currentPollingUrl = null; // Reset polling URL

            // ========== ‚ú® NEW: Create Placeholder Video in History ==========
            // Generate temporary ID for placeholder
            const tempPlaceholderId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Create placeholder video object
            const placeholderVideo = {
                id: tempPlaceholderId,
                provider: currentProvider,
                model: config.name || selectedModelValue,
                prompt: prompt,
                negativePrompt: negativePrompt || '',
                duration: duration,
                resolution: resolution,
                status: 'starting', // Processing status
                url: null, // No URL yet
                createdAt: new Date().toISOString(),
                isPlaceholder: true, // Flag to identify placeholder
                initialImage: imageBase64Data || null // NEW: Capture initial image for hologram effect
            };

            // Add placeholder to history (at the beginning)
            videoHistoryData.unshift(placeholderVideo);
            videoHistoryData = videoHistoryData.slice(0, STORAGE_LIMITS.VIDEO_HISTORY_MAX);

            // Render history to show processing thumbnail immediately
            renderVideoHistory();
            console.log('‚ú® Added placeholder video to history:', tempPlaceholderId);
            // ========== END: Placeholder Video ==========

            // --- Call Provider API (Wavespeed or Grok) ---
            try {
                let success;

                if (config.provider === 'grok') {
                    // --- Call Grok API ---
                    console.log('üöÄ Using Grok provider');

                    // üìê For I2V mode: Don't pass aspect ratio ‚Üí Grok auto-detects from source image
                    // For T2V mode: Would read from UI selection (not implemented yet)
                    const aspectRatio = null;  // Let Grok auto-detect from image

                    success = await generateVideo_Grok(
                        apiKey,
                        config,
                        prompt,
                        imageBase64Data,
                        duration,
                        resolution,
                        aspectRatio,
                        AppState.generation.abortController
                    );
                } else {
                    // --- Call Wavespeed API ---
                    console.log('üöÄ Using Wavespeed provider');

                    // Prepare start video data for Video Extend models
                    let startVideoData = null;
                    if (config.requiresStartVideo === true) {
                        if (currentVideoUrl) {
                            startVideoData = currentVideoUrl;
                        } else if (currentVideoBase64) {
                            startVideoData = `data:video/mp4;base64,${currentVideoBase64}`;
                        }
                    }

                    success = await generateVideo_Wavespeed(
                        apiKey,
                        config,
                        prompt,
                        imageBase64Data,
                        duration,
                        resolution,
                        negativePrompt,
                        audioUrlValue,
                        shotType,
                        promptExpansion,
                        startVideoData,
                        lastImageBase64Data,
                        AppState.generation.abortController
                    );
                }

                // Start polling after successful POST request
                if (success && currentGenerationId && currentPollingUrl) {
                    syncBothUIs('updateStatusText', { text: '‚úÖ ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞...' });
                    syncBothUIs('updateProgress', { width: '10%' });
                    startPolling(apiKey, currentPollingUrl, config.provider); // Pass provider info
                } else if (!success) {
                    if (success) {
                        console.error("Generate function succeeded but polling info is missing.");
                        handleGenerationError(new Error("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Polling ‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô"));
                    }
                    syncBothUIs('enableButtons');
                    generateSpinner.classList.add('hidden');
                    syncBothUIs('hideCancelButton');
                }
            } catch (error) {
                handleGenerationError(error);
            }
        }

        // --- Wavespeed API Call ---
        // Accepts base64Data (for images/Prompt Craft), startVideoData (for video extend), and abortController (for cancellation)
        async function generateVideo_Wavespeed(apiKey, config, prompt, base64Data, duration, resolution, negativePrompt, audioUrlValue, shotType = 'single', promptExpansion = false, startVideoData = null, lastImageData = null, abortController = null) {
            // Build payload object
            const payload = {
                prompt: prompt,
                resolution: resolution,
                duration: duration,
                seed: -1
            };

            // Image input (for all I2V models, including Extend)
            if (base64Data) {
                // Strip data URI prefix if present
                payload.image = base64Data.includes(',')
                    ? base64Data.split(',')[1]
                    : base64Data;
                console.log("Using Base64 image data for Wavespeed.");
            } else {
                handleGenerationError(new Error("No image provided (Base64) for Wavespeed Image-to-Video"));
                return false;
            }

            // Start video input (only for Extend models - controlled by config.requiresStartVideo)
            if (config.requiresStartVideo) {
                if (startVideoData) {
                    // Strip data URI prefix if present
                    payload.video = startVideoData.includes(',')
                        ? startVideoData.split(',')[1]
                        : startVideoData;
                    console.log("Using start video data for Wavespeed Video Extend.");
                } else {
                    handleGenerationError(new Error("No start video provided for Wavespeed Video Extend"));
                    return false;
                }
            }

            // Last image input (optional - for Kling O1)
            if (config.supportsLastImage && lastImageData) {
                // Strip data URI prefix if present
                payload.lastImage = lastImageData.includes(',')
                    ? lastImageData.split(',')[1]
                    : lastImageData;
                console.log("Using last image data for Kling O1.");
            }

            // Optional parameters (controlled by config flags)
            if (negativePrompt) payload.negativePrompt = negativePrompt;
            if (audioUrlValue) payload.audioUrl = audioUrlValue;
            if (config.supportsShotType && shotType) payload.shotType = shotType;
            if (config.supportsExpansion) payload.promptExpansion = promptExpansion;

            // Convert to API format before sending
            const body = {
                prompt: payload.prompt,
                duration: payload.duration,
                resolution: payload.resolution,
                seed: payload.seed
            };

            if (payload.image) body.image = payload.image;
            if (payload.video) body.video = payload.video;
            if (payload.lastImage) body.last_image = payload.lastImage;
            if (payload.negativePrompt) body.negative_prompt = payload.negativePrompt;
            if (payload.audioUrl) body.audio = payload.audioUrl;
            if (payload.shotType) body.shot_type = payload.shotType;
            if (payload.promptExpansion !== undefined) body.enable_prompt_expansion = !!payload.promptExpansion;

            const WAVESPEED_GENERATE_ENDPOINT = `${WAVESPEED_API_BASE_URL}/${config.internal_id}`;

            try {
                // ========== ‚úÖ PERFORMANCE FIX: AbortController with 120s timeout ==========
                let timeoutId = null;
                if (abortController) {
                    // Set 120-second timeout for initial generation request (long enough for base64 image upload)
                    timeoutId = setTimeout(() => {
                        abortController.abort();
                        console.log('‚è±Ô∏è Request timeout (120s) - aborted');
                    }, 120000);
                }

                const response = await fetch(WAVESPEED_GENERATE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),  // ‚úÖ Fixed: Send 'body' with correct API format, not 'payload'
                    signal: abortController?.signal  // ‚úÖ Add abort signal
                });

                // Clear timeout if request succeeded
                if (timeoutId) clearTimeout(timeoutId);
                // ========== End of AbortController ==========

                const data = await response.json();
                console.log('Wavespeed Response:', data);
                // Check specifically for Wavespeed error structure if available
                if (!response.ok || (data.code && data.code !== 200)) {
                    throw new Error(data.message || data.error || `HTTP ${response.status}`);
                }
                // Check Wavespeed specific success structure
                if (data.code === 200 && data.data && data.data.id && data.data.urls && data.data.urls.get) {
                    currentGenerationId = data.data.id;
                    currentPollingUrl = data.data.urls.get; // Set polling URL
                    syncBothUIs('updateGenerationDetails', { id: data.data.id }); // Update both UIs

                    // ‚ú® ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å input parameters ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠ workaround API ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤
                    const taskId = currentGenerationId;
                    saveTaskInput(taskId, {
                        prompt: prompt,
                        negativePrompt: negativePrompt || '',
                        duration: duration,
                        resolution: resolution,
                        model: config?.name || config?.internal_id || 'unknown',
                        modelKey: modelSelect?.value || null, // ‚ú® ‡πÄ‡∏Å‡πá‡∏ö model key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö reuse
                        shotType: shotType || null,
                        promptExpansion: promptExpansion || false,
                        timestamp: new Date().toISOString(),
                        craftData: captureCraftData() // ‚ú® ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Prompt Craft
                    });
                    console.log('üìù Saved task input for:', taskId);

                    // ========== ‚ú® NEW: Update Placeholder with Real Generation ID ==========
                    // Find placeholder video (should be first item since we just added it)
                    const placeholderIndex = videoHistoryData.findIndex(v => v.isPlaceholder === true);
                    if (placeholderIndex !== -1) {
                        // Update placeholder with real generation ID
                        videoHistoryData[placeholderIndex].id = data.data.id;
                        videoHistoryData[placeholderIndex].status = 'pending'; // Update status
                        delete videoHistoryData[placeholderIndex].isPlaceholder; // Remove placeholder flag
                        console.log('‚ú® Updated placeholder with real ID:', data.data.id);

                        // Re-render history to show updated status
                        renderVideoHistory();
                    }
                    // ========== END: Update Placeholder ==========

                    // ========== ‚ú® NEW: Save generation state for resume after refresh (v1.11.0) ==========
                    saveGenerationState();
                    // ========== END: Save Generation State ==========

                    // statusText updated and startPolling called by handleGenerateSubmit
                    return true; // Indicate success
                } else {
                    throw new Error(data.message || "Invalid API response structure");
                }
            } catch (error) {
                // ========== ‚úÖ PERFORMANCE FIX: Handle AbortError ==========
                if (error.name === 'AbortError') {
                    console.log('‚èπÔ∏è Generation request aborted (user cancelled or timeout)');
                    // Reset AbortController
                    AppState.generation.abortController = null;
                    return false; // Silently fail (user intended to cancel)
                }
                // ========== End of AbortError handling ==========

                handleGenerationError(error);
                return false; // Indicate failure
            }
        }
        // ========== END: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ ==========

        // --- Unified Polling Function (Wavespeed & Grok) ---
        function startPolling(providerApiKey, pollingUrl, provider = 'wavespeed') {
            clearPollingAndTimer(); // Clear previous intervals first

            // Log arguments for debugging
            console.log("startPolling called with:", { providerApiKey: providerApiKey ? '***' : 'MISSING', pollingUrl, provider });

            // CRITICAL CHECK: Use arguments directly
            if (!pollingUrl || !providerApiKey) {
                console.error("startPolling FAILED check:", { pollingUrl, providerApiKey });
                handleGenerationError(new Error("Missing Polling URL or API Key"));
                generateBtn.disabled = false; // Re-enable button
                generateSpinner.classList.add('hidden');
                cancelGenerationBtn.classList.add('hidden');
                return; // Stop execution
            }
            console.log("Polling check passed, proceeding.");

            let pollCount = 0;
            let elapsedSeconds = 0;
            const MAX_POLL_COUNT = 360; // ~30 minutes (for wan 2.6 long generation)
            const MAX_TIMEOUT = 1800; // 1800 seconds (30 minutes) 

            // Store pollingUrl globally ONLY for cancellation logic
            currentPollingUrl = pollingUrl;

            // ========== ‚úÖ PERFORMANCE FIX: Consolidated Polling Loop ==========
            // Replaces separate timerInterval (1s) and pollingInterval (5s) with single loop
            // This reduces CPU usage by ~50% and simplifies state management

            // Helper function: Check API status (extracted from old pollingInterval)
            async function performAPIStatusCheck() {
                if (!currentPollingUrl) { // Check if cancelled
                    clearPollingAndTimer();
                    return;
                }

                // Prevent overlapping polls
                if (isPolling) {
                    console.log('‚ö†Ô∏è Previous poll still in progress, skipping...');
                    return;
                }

                if (++pollCount > MAX_POLL_COUNT) return handlePollingMaxAttempts(MAX_POLL_COUNT);

                isPolling = true; // Set guard flag
                try {
                    console.log(`Polling ${currentProvider}: ${pollingUrl}`);
                    const response = await fetch(pollingUrl, {
                        method: 'GET',
                        headers: { 'Authorization': `Bearer ${providerApiKey}` }
                    });

                    if (response.status === 404) throw new Error(`Task ID ${currentGenerationId} ‡πÑ‡∏°‡πà‡∏û‡∏ö (‡∏≠‡∏≤‡∏à‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏π‡∏Å‡∏•‡∏ö)`);
                    if (!response.ok) {
                        let errorBody = null; try { errorBody = await response.json(); } catch (e) { }
                        throw new Error(errorBody?.message || errorBody?.error || `HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    console.log(`${currentProvider} Status:`, data);

                    // Debug: Log all keys in the response
                    if (data) {
                        console.log('üîç Response keys:', Object.keys(data));
                    }

                    let status = 'failed'; let isSuccess = false; let videoUrl = null; let errorMessage = "Unknown error"; let completedData = null;

                    // Parse response based on provider
                    if (provider === 'grok') {
                        // üö® GROK API DOESN'T RETURN STATUS FIELD!
                        // Actual response: { video: { url, duration, respect_moderation }, model: "..." }
                        // Docs say: { url, duration } (flat) but actual is nested
                        // We infer status from presence of url or error
                        const videoData = data.video || data;  // Support both nested and flat structure
                        videoUrl = videoData.url;
                        errorMessage = videoData.error || videoData.error_message;

                        // Infer status based on what fields exist
                        if (videoUrl) {
                            // Video ready!
                            status = 'completed';
                            isSuccess = true;
                        } else if (errorMessage) {
                            // Generation failed
                            status = 'failed';
                            isSuccess = true;  // isSuccess means we got a valid response
                        } else {
                            // Still processing
                            status = 'processing';
                            isSuccess = true;
                        }

                        completedData = videoData;

                        console.log(`ü§ñ Grok inferred status: ${status} (has_url=${!!videoUrl}, has_error=${!!errorMessage})`);
                        console.log(`ü§ñ Grok video data:`, videoData);
                    } else {
                        // Wavespeed response format
                        isSuccess = data.code === 200 && data.data;
                        if (isSuccess) {
                            status = data.data.status;
                            videoUrl = (status === 'completed' || status === 'succeeded') && data.data.outputs && data.data.outputs.length > 0 ? data.data.outputs[0] : null;
                            errorMessage = data.data.error;
                            completedData = data.data;
                        } else {
                            errorMessage = data.message || "Wavespeed API Error";
                        }
                    }

                    if (isSuccess) {
                        updateStatusUI(status, elapsedSeconds);

                        // ========== ‚ú® NEW: Save generation state during polling (v1.11.0) ==========
                        saveGenerationState();
                        // ========== END: Save Generation State ==========

                        // ========== ‚ú® NEW: Update placeholder status during polling ==========
                        if (currentGenerationId && status) {
                            const placeholderIndex = videoHistoryData.findIndex(v => v.id === currentGenerationId);
                            if (placeholderIndex !== -1) {
                                // Update status if it changed
                                if (videoHistoryData[placeholderIndex].status !== status) {
                                    videoHistoryData[placeholderIndex].status = status;
                                    console.log(`‚ú® Updated placeholder status: ${status}`);

                                    // Re-render history to show updated status (throttled to avoid excessive renders)
                                    // Only render on status changes, not every poll
                                    renderVideoHistory();
                                }
                            }
                        }
                        // ========== END: Update Placeholder Status ==========

                        if (status === 'completed' || status === 'succeeded') {
                            if (videoUrl) {
                                // Null check for promptTextarea
                                const currentPrompt = promptTextarea ? promptTextarea.value.trim() : '';

                                // Extract model name from completedData (can be object or string)
                                let modelName = 'Unknown';
                                if (completedData?.model) {
                                    if (typeof completedData.model === 'object') {
                                        console.log('üì¶ Model object from API:', completedData.model);
                                        modelName = completedData.model.name || completedData.model.key || completedData.model.internal_id || 'Unknown';
                                        console.log('‚úÖ Extracted model name:', modelName);
                                    } else if (typeof completedData.model === 'string') {
                                        modelName = completedData.model;
                                        console.log('‚úÖ Model name (string):', modelName);
                                    }
                                } else {
                                    // Fallback to selected model config (with null checks)
                                    if (modelSelect && modelSelect.value) {
                                        const selectedConfig = MODEL_CONFIG[modelSelect.value];
                                        modelName = selectedConfig?.name || selectedConfig?.internal_id || 'Unknown';
                                        console.log('‚ö†Ô∏è Using fallback model name:', modelName);
                                    }
                                }

                                console.log('üé¨ Video URL from API:', videoUrl);

                                // ========== üöÄ GROK FIX: Download as blob to avoid CORS issues ==========
                                // IMPORTANT: Keep original URL for history storage (blob URLs expire)
                                // Only download blob for immediate playback preview
                                let finalVideoUrl = videoUrl;
                                if (provider === 'grok') {
                                    console.log('üîÑ Grok video detected - downloading as blob for preview...');
                                    statusText.textContent = 'üì• ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠...';
                                    try {
                                        finalVideoUrl = await downloadGrokVideoAsBlob(videoUrl);
                                        console.log('‚úÖ Downloaded blob for preview (original URL will be saved to history)');
                                    } catch (blobError) {
                                        console.error('‚ùå Failed to download blob:', blobError);
                                        // Use original URL as fallback
                                        finalVideoUrl = videoUrl;
                                    }
                                }
                                // ========== END: Grok Blob Download ==========

                                const finalData = {
                                    video_url: videoUrl,  // üö® CRITICAL: Always save ORIGINAL URL (not blob) for history
                                    prompt: currentPrompt,
                                    model: modelName,
                                    duration: completedData?.duration || (durationSelectWavespeed ? parseInt(durationSelectWavespeed.value) : 0) || 0,
                                    resolution: completedData?.resolution || (resolutionSelect ? resolutionSelect.value : '1080p'),
                                    completed_at: completedData?.completed_at || completedData?.updated_at || new Date().toISOString(),
                                    processing_time: completedData?.timings?.inference || (completedData?.processing_time) || (elapsedSeconds * 1000)
                                };
                                handleGenerationSuccess(finalData, elapsedSeconds);
                            } else { throw new Error(`‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ${status} ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏û‡∏ö Video URL`); }
                        } else if (status === 'failed' || status === 'canceled') {
                            // üö® CRITICAL: Check for Grok content moderation (stop immediately to save tokens/money)
                            if (provider === 'grok' && errorMessage) {
                                const isContentFilter =
                                    errorMessage.toLowerCase().includes('content moderation') ||
                                    errorMessage.toLowerCase().includes('content filter') ||
                                    errorMessage.toLowerCase().includes('content policy') ||
                                    errorMessage.toLowerCase().includes('rejected by');

                                if (isContentFilter) {
                                    throw new Error(`üö´ GROK CONTENT FILTER: ${errorMessage}\n\n‚ö†Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏á‡∏¥‡∏ô - Grok ‡∏Ñ‡∏¥‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏°‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!`);
                                }
                            }

                            throw new Error(errorMessage || `‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß/‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å (Status: ${status})`);
                        } // Else: continue polling
                    } else { throw new Error(errorMessage); }
                } catch (error) {
                    // Stop polling on critical errors
                    const errorMsg = error.message || String(error);

                    // Critical errors that should stop polling immediately
                    const shouldStopPolling =
                        errorMsg.includes("‡πÑ‡∏°‡πà‡∏û‡∏ö") ||                    // 404 - Task not found
                        errorMsg.includes("‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß") ||                  // Failed status
                        errorMsg.includes("‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å") ||                   // Canceled status
                        errorMsg.includes("failed") ||                   // API failed response
                        errorMsg.includes("canceled") ||                 // API canceled response
                        errorMsg.includes("do not support") ||           // Content filter rejection
                        errorMsg.includes("photorealistic people") ||    // OpenAI content filter
                        errorMsg.includes("NSFW") ||                     // NSFW filter
                        errorMsg.includes("inappropriate") ||            // Inappropriate content
                        errorMsg.includes("GROK CONTENT FILTER") ||      // üö® CRITICAL: Grok content moderation (saves money!)
                        errorMsg.includes("content moderation") ||       // Content moderation
                        errorMsg.includes("rejected by");                // Rejected by filter

                    if (shouldStopPolling) {
                        console.error(`‚ùå ${currentProvider} Critical Error - Stopping polling:`, errorMsg);
                        handleGenerationError(error); // Stop polling and show error
                    } else {
                        // Non-critical errors - retry
                        console.warn(`‚ö†Ô∏è ${currentProvider} Polling Error (will retry):`, errorMsg);
                        statusText.textContent = `üîÑ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö (${errorMsg}) ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà...`;
                    }
                } finally {
                    // Always reset polling flag
                    isPolling = false;
                }
            }

            // Start consolidated polling loop (1 interval does both jobs)
            pollingLoop = setInterval(() => {
                // Job 1: Update timer (every 1 second)
                elapsedSeconds++;
                syncBothUIs('updateGenerationDetails', { elapsed: `${elapsedSeconds}s` });
                if (elapsedSeconds >= MAX_TIMEOUT) handlePollingTimeout(MAX_TIMEOUT);

                // Job 2: Check API status (every 5 seconds)
                if (elapsedSeconds % 5 === 0) {
                    performAPIStatusCheck();
                }
            }, 1000); // Run every 1 second

            console.log('‚úÖ Consolidated polling loop started (CPU usage reduced ~50%)');
            // ========== End of Consolidated Polling Loop ==========
        }

        // --- Polling & Status Helpers ---
        function clearPollingAndTimer() {
            // ‚úÖ PERFORMANCE FIX: Clear single consolidated loop instead of 2 separate intervals
            if (pollingLoop) {
                clearInterval(pollingLoop);
                pollingLoop = null;
            }
            currentPollingUrl = null; // Clear polling URL
            isPolling = false; // Reset polling guard flag
            console.log("‚úÖ Consolidated polling loop cleared.");
        }

        function handlePollingTimeout(timeoutSeconds) {
            clearPollingAndTimer();
            statusBadge.className = 'status-badge status-failed';
            statusBadge.textContent = 'ERROR';
            statusText.textContent = `‚ùå ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠ (${timeoutSeconds} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)`;
            generateBtn.disabled = false;
            generateSpinner.classList.add('hidden');
            cancelGenerationBtn.classList.add('hidden');
            console.error('Generation timeout:', currentGenerationId, currentProvider);
            currentGenerationId = null; // Reset ID
        }

        function handlePollingMaxAttempts(maxAttempts) {
            clearPollingAndTimer();
            statusBadge.className = 'status-badge status-failed';
            statusBadge.textContent = 'ERROR';
            statusText.textContent = `‚ùå ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à - ‡πÄ‡∏Å‡∏¥‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö (${maxAttempts} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á)`;
            generateBtn.disabled = false;
            generateSpinner.classList.add('hidden');
            cancelGenerationBtn.classList.add('hidden');
            console.error('Max poll count exceeded:', currentGenerationId, currentProvider);
            currentGenerationId = null; // Reset ID
        }

        function updateStatusUI(status, elapsedSeconds) {
            const statusKey = status.toLowerCase();
            const displayText = STATUS_TEXT[statusKey] || status.toUpperCase();
            const badgeStatusKey = (statusKey === 'created' ? 'pending' : statusKey).replace(/[\s_]/g, '-'); // Map created->pending for badge
            statusBadge.className = `status-badge status-${badgeStatusKey}`;
            statusBadge.textContent = displayText;

            let progressPercent = 10;
            if (['pending', 'created'].includes(statusKey)) progressPercent = 20;
            else if (statusKey === 'in_queue') progressPercent = 30;
            else if (statusKey === 'starting') progressPercent = 40;
            else if (['in_progress', 'processing'].includes(statusKey)) progressPercent = 60 + Math.min(30, Math.floor(elapsedSeconds / 5)); // Gradual progress
            else if (['completed', 'succeeded'].includes(statusKey)) progressPercent = 100;
            else if (['failed', 'canceled'].includes(statusKey)) progressPercent = 0;

            // OLD: progressBar.style.width = `${progressPercent}%`;
            // NEW: Update segmented progress bar with status-based colors
            updateSegmentedProgress(progressPercent, `status-${badgeStatusKey}`);
            statusText.textContent = `${displayText}... (${elapsedSeconds} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)`;
        }

        async function handleGenerationSuccess(data, elapsedSeconds) {
            clearPollingAndTimer();

            // ========== ‚úÖ PERFORMANCE FIX: Reset AbortController on completion ==========
            AppState.generation.abortController = null;
            console.log('‚úÖ Generation completed - AbortController reset');
            // ========== End of AbortController reset ==========

            // ========== ‚úÖ Hide video generation hologram overlay ==========
            hideVideoGenerationOverlay();
            // ========== END: Hide Overlay ==========

            // ALWAYS use elapsedSeconds (actual time user waited) as processing time
            // API's processing_time is just backend processing, not total generation time
            const processingTimeSec = elapsedSeconds.toFixed(2);

            console.log('‚è±Ô∏è Processing time calculated:', {
                elapsedSeconds: elapsedSeconds,
                apiProcessingTime: data.processing_time,
                apiInference: data.inference,
                usingElapsed: processingTimeSec
            });

            syncBothUIs('updateStatusBadge', { className: 'status-completed', text: STATUS_TEXT['completed'] });
            syncBothUIs('updateStatusText', { text: `‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤ ${processingTimeSec} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)` });
            syncBothUIs('updateProgress', { width: '100%' });

            // Get proper model display name
            const selectedModelConfig = MODEL_CONFIG[modelSelect.value];
            const modelDisplayName = data.model || selectedModelConfig?.name || selectedModelConfig?.internal_id || 'Unknown';

            // Get additional parameters for re-use feature
            const negativePromptInput = document.getElementById('negative-prompt');
            const shotTypeSelect = document.getElementById('shot-type');
            const promptExpansionCheckbox = document.getElementById('prompt-expansion');

            // ‚ú® ‡∏î‡∏∂‡∏á saved input ‡∏à‡∏≤‡∏Å map (workaround ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤)
            const savedInput = getTaskInput(currentGenerationId);

            if (!savedInput) {
                console.warn('‚ö†Ô∏è No saved input for task:', currentGenerationId);
            }

            currentVideoData = { // Standardized format
                id: currentGenerationId, // Use the ID we tracked during polling
                url: data.video_url,
                // ‚ú® ‡πÉ‡∏ä‡πâ saved input ‡πÅ‡∏ó‡∏ô data ‡∏à‡∏≤‡∏Å API (‡∏ã‡∏∂‡πà‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ)
                prompt: savedInput?.prompt || data.prompt || 'No prompt',
                negativePrompt: savedInput?.negativePrompt || '',
                model: modelDisplayName || savedInput?.model || 'unknown',
                modelKey: savedInput?.modelKey || null, // ‚ú® ‡πÄ‡∏Å‡πá‡∏ö model key ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö reuse
                provider: currentProvider, // Use provider tracked during polling
                duration: savedInput?.duration || data.duration || 0,
                resolution: savedInput?.resolution || data.resolution || 'N/A',
                shotType: savedInput?.shotType || null,
                promptExpansion: savedInput?.promptExpansion || false,
                createdAt: data.completed_at || new Date().toISOString(), // Use completed_at if available
                processingTime: processingTimeSec, // Store seconds
                craftData: savedInput?.craftData || null // ‚ú® ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Prompt Craft
            };

            console.log('‚úÖ Video data with saved input:', currentVideoData);

            console.log('‚úÖ Video generation completed, saving to history:', {
                id: currentVideoData.id,
                model: currentVideoData.model,
                duration: currentVideoData.duration,
                resolution: currentVideoData.resolution,
                provider: currentVideoData.provider,
                processingTime: currentVideoData.processingTime + 's'
            });

            // Video is auto-saved to history (no legacy player to show)
            // üíæ v2.12.14: Use atomic save for Grok videos
            if (currentProvider === 'grok') {
                await saveGrokVideoAtomic(currentVideoData);
                console.log('‚úÖ Grok video saved atomically:', data.video_url);
            } else {
                saveToHistory(); // Auto-save successful generation
                console.log('‚úÖ Video generated and saved to history:', data.video_url);
            }

            // ========== Save Prompt & Apply Dimming Effect After Successful Generation ==========
            // Save the prompt that was used for this generation
            lastUsedPromptForGeneration = promptTextarea ? promptTextarea.value : '';

            // Mark prompt as "used" by adding dim effect (50% opacity)
            localStorage.setItem('vidist_prompt_copied_state', 'true');
            if (typeof applyPromptCopiedState === 'function') {
                applyPromptCopiedState();
            }

            // Reset craft flags to force re-craft for next video
            promptWasCrafted = false;
            promptWasManuallyEdited = false;
            console.log('üîÑ Prompt marked as used (dimmed to 50%), craft flags reset');
            // ========== END ==========

            fetchUsageStats_Wavespeed(); // Refresh Wavespeed stats
            syncBothUIs('enableButtons');
            generateSpinner.classList.add('hidden');
            syncBothUIs('hideCancelButton');
            currentGenerationId = null; // Reset ID after success

            // ========== ‚ú® NEW: Clear generation state after success (v1.11.0) ==========
            clearGenerationState();
            // ========== END: Clear Generation State ==========
        }

        function handleGenerationError(error) {
            clearPollingAndTimer();

            // ========== ‚úÖ PERFORMANCE FIX: Reset AbortController on error ==========
            AppState.generation.abortController = null;
            // ========== End of AbortController reset ==========

            // ========== ‚úÖ Hide video generation hologram overlay ==========
            hideVideoGenerationOverlay();
            // ========== END: Hide Overlay ==========

            console.error(`${currentProvider || 'Unknown'} Generation/Polling Error:`, error);

            // Parse error message for better display
            const errorMsg = error.message || String(error);
            let displayMsg = `‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${errorMsg}`;

            // Specific error messages for common cases (in Thai, short and clear)
            if (errorMsg.includes("photorealistic people")) {
                displayMsg = "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ: ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏°‡∏µ‡∏Ñ‡∏ô‡∏à‡∏£‡∏¥‡∏á ‡∏ã‡∏∂‡πà‡∏á OpenAI ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö";
            } else if (errorMsg.includes("do not support")) {
                displayMsg = "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ: ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÇ‡∏î‡∏¢‡πÇ‡∏°‡πÄ‡∏î‡∏• AI";
            } else if (errorMsg.includes("NSFW") || errorMsg.includes("inappropriate")) {
                displayMsg = "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏î‡πâ: ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°";
            } else if (errorMsg.includes("‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß") || errorMsg.includes("failed")) {
                displayMsg = "‚ùå ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à";
            } else if (errorMsg.includes("404") || errorMsg.includes("‡πÑ‡∏°‡πà‡∏û‡∏ö")) {
                displayMsg = "‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏á‡∏≤‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠";
            }

            // ========== ‚ú® UPDATED: Remove placeholder immediately on failure (don't save failed generations) ==========
            if (currentGenerationId) {
                const placeholderIndex = videoHistoryData.findIndex(v => v.id === currentGenerationId);
                if (placeholderIndex !== -1) {
                    // Remove failed item from history
                    videoHistoryData.splice(placeholderIndex, 1);
                    console.log('üóëÔ∏è Removed failed placeholder from history:', currentGenerationId);

                    // Save cleaned history to localStorage
                    safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                    // Re-render history without the failed item
                    renderVideoHistory();
                }
            } else {
                // If no generation ID, find placeholder by flag
                const placeholderIndex = videoHistoryData.findIndex(v => v.isPlaceholder === true);
                if (placeholderIndex !== -1) {
                    // Remove failed item from history
                    videoHistoryData.splice(placeholderIndex, 1);
                    console.log('üóëÔ∏è Removed failed placeholder from history (no ID)');

                    // Save cleaned history to localStorage
                    safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                    // Re-render history without the failed item
                    renderVideoHistory();
                }
            }
            // ========== END: Remove Failed Placeholder ==========

            syncBothUIs('updateStatusBadge', { className: 'status-failed', text: 'ERROR' });
            syncBothUIs('updateStatusText', { text: displayMsg });
            syncBothUIs('updateProgress', { width: '0%' });
            syncBothUIs('enableButtons');
            generateSpinner.classList.add('hidden');
            syncBothUIs('hideCancelButton');
            currentGenerationId = null; // Reset ID on error

            // ========== ‚ú® NEW: Clear generation state after error (v1.11.0) ==========
            clearGenerationState();
            // ========== END: Clear Generation State ==========
        }


        function cancelGeneration() {
            clearPollingAndTimer(); // Stop polling and timer

            // ========== ‚ú® NEW: Update placeholder to canceled status ==========
            if (currentGenerationId) {
                const placeholderIndex = videoHistoryData.findIndex(v => v.id === currentGenerationId);
                if (placeholderIndex !== -1) {
                    videoHistoryData[placeholderIndex].status = 'canceled';
                    console.log('‚ú® Updated placeholder to canceled status:', currentGenerationId);

                    // Re-render history to show canceled status
                    renderVideoHistory();
                }
            } else {
                // If no generation ID, find placeholder by flag
                const placeholderIndex = videoHistoryData.findIndex(v => v.isPlaceholder === true);
                if (placeholderIndex !== -1) {
                    videoHistoryData[placeholderIndex].status = 'canceled';
                    delete videoHistoryData[placeholderIndex].isPlaceholder;
                    console.log('‚ú® Updated placeholder to canceled status (no ID)');

                    // Re-render history to show canceled status
                    renderVideoHistory();
                }
            }
            // ========== END: Update Placeholder ==========

            // ========== ‚úÖ Hide video generation hologram overlay ==========
            hideVideoGenerationOverlay();
            // ========== END: Hide Overlay ==========

            syncBothUIs('updateStatusBadge', { className: 'status-canceled', text: STATUS_TEXT['canceled'] || '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å' });
            syncBothUIs('updateStatusText', { text: 'üõë ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡πâ‡∏ß' });
            syncBothUIs('updateProgress', { width: '0%' });
            syncBothUIs('enableButtons');
            generateSpinner.classList.add('hidden');
            syncBothUIs('hideCancelButton');
            console.log('Generation cancelled by user:', currentGenerationId, currentProvider);
            // Optionally: Send cancel request to API if supported
            currentGenerationId = null; // Reset ID

            // ========== ‚ú® NEW: Clear generation state after cancel (v1.11.0) ==========
            clearGenerationState();
            // ========== END: Clear Generation State ==========
        }

        // ========== WAN 2.6 IMAGE EDIT SYSTEM ==========

        // State management
        // Note: imageEditHistory and currentHistoryIndex are managed by image_edit_history.js
        let imageEditCounter = 0;        // Auto-increment for filenames

        // Show hologram overlay on image during edit
        function showImageEditOverlay(statusText = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û...') {
            const overlay = document.getElementById('image-edit-processing-overlay');
            const statusTextEl = document.getElementById('image-edit-status-text');
            if (overlay && statusTextEl) {
                statusTextEl.textContent = statusText;
                overlay.classList.remove('hidden');
            }
        }

        // Hide hologram overlay
        function hideImageEditOverlay() {
            const overlay = document.getElementById('image-edit-processing-overlay');
            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        // ========== Video Generation Hologram Overlay Functions ==========
        // Show hologram overlay on source image during video generation
        // Uses the LEFT overlay (image-edit-processing-overlay) since Prompt Craft displays image there
        function showVideoGenerationOverlay(statusText = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠...') {
            const overlay = document.getElementById('image-edit-processing-overlay');
            const statusTextEl = document.getElementById('image-edit-status-text');
            const imagePreviewContainerLeft = document.getElementById('image-preview-container-left');

            // Only show overlay if there's an image preview visible on the left
            if (overlay && statusTextEl && imagePreviewContainerLeft && !imagePreviewContainerLeft.classList.contains('hidden')) {
                statusTextEl.textContent = statusText;
                overlay.classList.remove('hidden');
                console.log('‚ú® Video generation hologram overlay shown (LEFT section)');
            }
        }

        // Hide hologram overlay for video generation
        // Uses the LEFT overlay (image-edit-processing-overlay)
        function hideVideoGenerationOverlay() {
            const overlay = document.getElementById('image-edit-processing-overlay');
            if (overlay && !overlay.classList.contains('hidden')) {
                // Only hide if it's showing video generation status
                const statusTextEl = document.getElementById('image-edit-status-text');
                if (statusTextEl && statusTextEl.textContent.includes('‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠')) {
                    overlay.classList.add('hidden');
                    console.log('‚úÖ Video generation hologram overlay hidden (LEFT section)');
                }
            }
        }

        // Update overlay status text for video generation
        function updateVideoGenerationOverlay(statusText) {
            const statusTextEl = document.getElementById('image-edit-status-text');
            if (statusTextEl) {
                statusTextEl.textContent = statusText;
            }
        }
        // ========== END: Video Generation Overlay Functions ==========

        // ========== Floating Processing Visual Functions (v2.8.2) ==========

        function showFloatingProcessing(sourceImageSrc, initialProgress = 0) {
            const floatingContainer = document.getElementById('floating-processing-container');
            const floatingImage = document.getElementById('floating-processing-image');
            const floatingText = document.getElementById('floating-status-text');
            const dimOverlay = document.getElementById('base-image-dim');
            const baseImage = document.getElementById('image-preview-left');

            if (!floatingContainer || !floatingImage) return;

            // Set source image
            floatingImage.src = sourceImageSrc;
            floatingText.textContent = `processing... ${initialProgress}%`;

            // Scale base image to match floating image size
            if (baseImage) {
                baseImage.classList.add('editing-scaled');
            }

            // Show elements
            floatingContainer.classList.remove('hidden', 'floating-exit');
            dimOverlay.classList.remove('hidden');
            dimOverlay.classList.add('active');

            // Trigger animation (next frame to ensure hidden is removed first)
            requestAnimationFrame(() => {
                floatingContainer.classList.add('floating-active');
            });

            console.log('‚ú® Floating processing visual started');
        }

        function updateFloatingProgress(progress) {
            const floatingText = document.getElementById('floating-status-text');
            if (floatingText) {
                floatingText.textContent = `processing... ${progress}%`;
            }
        }

        function hideFloatingProcessing(callback) {
            const floatingContainer = document.getElementById('floating-processing-container');
            const dimOverlay = document.getElementById('base-image-dim');
            const baseImage = document.getElementById('image-preview-left');

            if (!floatingContainer) {
                if (callback) callback();
                return;
            }

            // Remove active animation, add exit animation
            floatingContainer.classList.remove('floating-active');
            floatingContainer.classList.add('floating-exit');
            dimOverlay.classList.remove('active');

            // Remove scaling from base image
            if (baseImage) {
                baseImage.classList.remove('editing-scaled');
            }

            // Wait for animation to complete
            setTimeout(() => {
                floatingContainer.classList.add('hidden');
                floatingContainer.classList.remove('floating-exit');
                dimOverlay.classList.add('hidden');

                if (callback) callback();
                console.log('‚ú® Floating processing visual hidden');
            }, 400); // Match float-away duration
        }
        // ========== END: Floating Processing Visual Functions ==========

        // Update overlay status text
        function updateImageEditOverlay(statusText) {
            const statusTextEl = document.getElementById('image-edit-status-text');
            if (statusTextEl) {
                statusTextEl.textContent = statusText;
            }
        }

        // Load counter from storage
        function loadImageEditCounter() {
            const stored = localStorage.getItem('vidist_image_edit_counter');
            imageEditCounter = stored ? parseInt(stored) : 0;
        }

        // Save counter to storage
        function saveImageEditCounter() {
            localStorage.setItem('vidist_image_edit_counter', imageEditCounter.toString());
        }

        // Toggle Edit Controls visibility
        function updateImageEditControls() {
            const editControls = document.getElementById('image-edit-controls');

            if (!editControls) {
                console.warn('‚ö†Ô∏è Image Edit Controls element not found');
                return;
            }

            const hasImage = imageBase64Data !== null;

            console.log('üîç Image Edit Controls Check:', {
                hasImage: hasImage,
                imageBase64Data: imageBase64Data ? 'exists' : 'null'
            });

            // Show when image is attached (always uses Wan 2.6 Image Edit API backend)
            if (hasImage) {
                editControls.classList.remove('hidden');
                console.log('‚úÖ Showing Image Edit Controls');
            } else {
                editControls.classList.add('hidden');
                console.log('‚ùå Hiding Image Edit Controls - No image');
            }
        }

        // ========== ‚ú® NEW (v2.9.0): Update UI based on selected image edit model ==========
        // Update UI controls based on selected image edit model
        function updateImageEditModelUI() {
            const modelSelect = document.getElementById('image-edit-model-select');
            const selectedModel = modelSelect?.value;
            const config = MODEL_CONFIG[selectedModel];

            if (!config) return;

            // Show/hide negative prompt based on model support
            const negativePromptContainer = document.getElementById('negative-prompt')?.closest('.mb-4');
            if (negativePromptContainer) {
                negativePromptContainer.classList.toggle('hidden', !config.supportsNegativePrompt);
            }

            // Show/hide expansion toggle based on model support
            const expansionToggle = document.getElementById('enable-expansion')?.closest('.flex');
            if (expansionToggle) {
                expansionToggle.classList.toggle('hidden', !config.supportsExpansion);
            }

            console.log(`üé® Image edit model changed to: ${config.name}`);
        }

        // Route to correct edit function based on selected model
        async function routeImageEdit() {
            const modelSelect = document.getElementById('image-edit-model-select');
            const selectedModel = modelSelect?.value || 'gemini-25-flash-image';
            const config = MODEL_CONFIG[selectedModel];

            if (!config) {
                alert('‚ùå Invalid model selected');
                return;
            }

            console.log(`üé® Routing to ${config.name} (${config.provider})`);

            // Route based on provider
            switch (config.provider) {
                case 'wavespeed':
                    await editImage_Wavespeed();
                    break;
                case 'gemini':
                    await editImage_Gemini();
                    break;
                default:
                    alert(`‚ùå Provider "${config.provider}" not implemented`);
            }
        }
        // ========== END: Model Router ==========

        // Get Wavespeed API Key
        function getWavespeedApiKey() {
            const apiKeyInput = document.getElementById('api-key-wavespeed');
            return apiKeyInput?.value || localStorage.getItem('wavespeed_api_key') || '';
        }

        // Validate before edit
        function validateImageEdit() {
            // Check API key
            const apiKey = getWavespeedApiKey();
            if (!apiKey) {
                alert('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Wavespeed API Key ‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û\n\nPlease enter your Wavespeed API Key before editing.');
                return false;
            }

            // Check image
            if (!imageBase64Data) {
                alert('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏ô‡∏ö‡∏†‡∏≤‡∏û‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç\n\nPlease attach an image before editing.');
                return false;
            }

            // Check prompt
            const prompt = document.getElementById('prompt').value.trim();
            if (!prompt) {
                alert('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Prompt ‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û\n\nPlease enter a prompt before editing.');
                return false;
            }

            // Check negative prompt if applicable
            const negativePrompt = document.getElementById('negative-prompt');
            if (negativePrompt && negativePrompt.required && !negativePrompt.value.trim()) {
                alert('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Negative Prompt\n\nPlease enter a negative prompt.');
                return false;
            }

            // Note: Image Edit always uses Wan 2.6 API backend (no model check needed)

            return true;
        }

        // Main edit function
        async function editImage_Wavespeed() {
            // Validation
            if (!validateImageEdit()) return;

            // Add current image to history before editing (if not already in history)
            if (imageBase64Data && typeof window.imageEditHistory !== 'undefined') {
                // Check if history is empty via the module
                const historyState = window.imageEditHistory.getState?.();
                if (!historyState || historyState.length === 0) {
                    window.imageEditHistory.add(imageBase64Data);
                }
            }

            // Get form data
            const prompt = document.getElementById('prompt').value.trim();
            const seed = parseInt(document.getElementById('seed')?.value) || -1;
            const enableExpansion = document.getElementById('enable-expansion')?.checked || false;

            // Get negative prompt (if exists)
            const negativePrompt = document.getElementById('negative-prompt')?.value?.trim() || '';

            // ‚ú® NEW: Ensure preview shows the EXACT image being sent to API
            const sourceImage = window.imageBase64Data || imageBase64Data;
            const previewImg = document.getElementById('image-preview-left');
            if (previewImg && previewImg.src !== sourceImage) {
                console.warn('‚ö†Ô∏è Preview mismatch detected - syncing to source');
                previewImg.src = sourceImage;
            }

            // Prepare API payload (matching official format)
            const payload = {
                enable_prompt_expansion: enableExpansion,
                images: [window.imageBase64Data || imageBase64Data],  // Use window property (updated by history nav) with fallback
                prompt: prompt,
                seed: seed
            };

            // Add negative_prompt only if not empty
            if (negativePrompt) {
                payload.negative_prompt = negativePrompt;
            }

            console.log('üì§ Sending payload:', {
                enable_prompt_expansion: payload.enable_prompt_expansion,
                images_count: payload.images.length,
                images_preview: payload.images[0].substring(0, 50) + '...',
                prompt: payload.prompt,
                negative_prompt: payload.negative_prompt || '(none)',
                seed: payload.seed
            });

            // UI feedback
            const editBtn = document.getElementById('edit-image-btn');
            const originalText = editBtn.innerHTML;
            editBtn.disabled = true;
            editBtn.innerHTML = '<span class="animate-pulse">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠...</span>';

            // ‚ú® NEW (v2.8.2): Show floating processing visual instead of overlay
            showFloatingProcessing(sourceImage, 0);

            // Get API key
            const apiKey = getWavespeedApiKey();

            try {
                // API call
                const response = await fetch('https://api.wavespeed.ai/api/v3/alibaba/wan-2.6/image-edit', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                // Read response text first
                const responseText = await response.text();
                console.log('üì• API Response:', responseText);

                if (!response.ok) {
                    let errorData = {};
                    try {
                        errorData = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Failed to parse error response:', responseText);
                    }
                    throw new Error(errorData.error || `API Error: ${response.status} - ${responseText.substring(0, 100)}`);
                }

                // Parse JSON response
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('‚ùå JSON Parse Error:', parseError);
                    console.error('Response text:', responseText);
                    throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}`);
                }

                console.log('‚úÖ Parsed response:', data);

                // Extract prediction ID and polling URL from response
                const predictionId = data.data?.id;
                const pollingUrl = data.data?.urls?.get;

                if (!predictionId || !pollingUrl) {
                    throw new Error('Invalid API response: missing prediction ID or polling URL');
                }

                console.log('üîÑ Starting polling:', { predictionId, pollingUrl });

                // Increment counter for new generation to ensure unique filename
                imageEditCounter++;
                saveImageEditCounter();

                // ========== ‚ú® NEW: Save task input for image edit (v2.4.2) ==========
                saveTaskInput(predictionId, {
                    prompt: payload.prompt,
                    negativePrompt: payload.negative_prompt || '',
                    model: 'Wan 2.6 Image Edit',
                    modelKey: 'ws-wan-26-image-edit',
                    outputType: 'image',  // Specify output type
                    timestamp: new Date().toISOString(),
                    imageCounter: imageEditCounter // Save current counter for consistent filenames
                });
                console.log('‚úÖ Task input saved for image edit:', predictionId);

                // ========== ‚ú® NEW: Add placeholder to history (v2.4.2) ==========
                const placeholderImageData = {
                    id: predictionId,
                    url: null,  // ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ output
                    prompt: payload.prompt,
                    negativePrompt: payload.negative_prompt || '',
                    model: 'Wan 2.6 Image Edit',
                    modelKey: 'ws-wan-26-image-edit',
                    provider: 'wavespeed',
                    outputType: 'image',
                    status: 'processing',
                    initialImage: imageBase64Data,  // ‡∏†‡∏≤‡∏û‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
                    createdAt: new Date().toISOString()
                };

                videoHistoryData.unshift(placeholderImageData);
                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                renderVideoHistory();
                console.log('‚úÖ Image edit placeholder added to history');
                // ========== END: Placeholder Creation ==========

                // Start polling using the provided URL
                await pollImageEditStatus(predictionId, pollingUrl);


            } catch (error) {
                console.error('Image edit error:', error);
                alert('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û\n\n' + error.message);
                editBtn.disabled = false;
                editBtn.innerHTML = originalText;
                // ‚ú® NEW (v2.8.2): Hide floating visual on error
                hideFloatingProcessing();
                hideImageEditOverlay();
            }
        }

        // ========== ‚ú® NEW (v2.9.0): Gemini 2.5 Flash Image Edit ==========

        // Gemini 2.5 Flash Image Edit
        async function editImage_Gemini() {
            // Validation
            if (!validateImageEditGemini()) return;

            // Add current image to history before editing (same pattern as WAN)
            if (imageBase64Data && typeof window.imageEditHistory !== 'undefined') {
                const historyState = window.imageEditHistory.getState?.();
                if (!historyState || historyState.length === 0) {
                    window.imageEditHistory.add(imageBase64Data);
                }
            }

            // Get form data
            const prompt = document.getElementById('prompt').value.trim();

            // Ensure preview shows exact image being sent
            const sourceImage = window.imageBase64Data || imageBase64Data;
            const previewImg = document.getElementById('image-preview-left');
            if (previewImg && previewImg.src !== sourceImage) {
                console.warn('‚ö†Ô∏è Preview mismatch detected - syncing to source');
                previewImg.src = sourceImage;
            }

            // Extract base64 data (remove data:image/...;base64, prefix)
            const base64Match = sourceImage.match(/^data:image\/[^;]+;base64,(.+)$/);
            const base64Data = base64Match ? base64Match[1] : sourceImage;

            // Prepare Gemini API payload
            const payload = {
                contents: [{
                    parts: [
                        { text: prompt },
                        {
                            inline_data: {
                                mime_type: "image/jpeg",
                                data: base64Data
                            }
                        }
                    ]
                }],
                generationConfig: {
                    responseModalities: ["IMAGE"]
                }
            };

            console.log('üì§ Sending Gemini payload:', {
                prompt: payload.contents[0].parts[0].text,
                image_size_kb: Math.round(base64Data.length / 1024)
            });

            // UI feedback
            const editBtn = document.getElementById('edit-image-btn');
            const originalText = editBtn.innerHTML;
            editBtn.disabled = true;
            editBtn.innerHTML = '<span class="animate-pulse">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠...</span>';

            // Show floating processing visual
            showFloatingProcessing(sourceImage, 0);

            // Get API key
            const apiKey = getGeminiApiKey();

            try {
                const startTime = Date.now();

                // ‚ú® NEW (v2.9.0): Timeout handling for slow Gemini API
                const abortController = new AbortController();
                const timeoutId = setTimeout(() => {
                    abortController.abort();
                    console.warn('‚è±Ô∏è Gemini API timeout after 30 seconds');
                }, 30000); // 30 second timeout

                // Simulate progress during processing
                const progressInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min((elapsed / 15000) * 100, 95); // 15s expected
                    updateFloatingProgress(Math.round(progress));
                }, 500);

                // Gemini API call (synchronous - no polling needed)
                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: abortController.signal
                    }
                );

                clearTimeout(timeoutId);
                clearInterval(progressInterval);
                updateFloatingProgress(100);

                const data = await response.json();
                console.log('üì• Gemini API Response:', data);

                if (!response.ok) {
                    const errorMsg = data.error?.message || `API Error: ${response.status}`;
                    throw new Error(errorMsg);
                }

                // Extract generated image from response
                const candidate = data.candidates?.[0];
                if (!candidate) {
                    throw new Error('No candidate in response');
                }

                // üîç DEBUG: Log candidate structure
                console.log('üîç Candidate structure:', JSON.stringify(candidate, null, 2));

                // Check for various failure reasons
                if (candidate.finishReason !== 'STOP') {
                    const finishMessage = candidate.finishMessage || 'Unknown error occurred';

                    // Safety blocks
                    if (candidate.finishReason === 'SAFETY' || candidate.finishReason === 'IMAGE_SAFETY') {
                        throw new Error(`üö´ Gemini Safety Block\n\n${finishMessage}\n\nTip: Try rephrasing your prompt with more appropriate language.`);
                    }

                    // Image generation failure
                    if (candidate.finishReason === 'IMAGE_OTHER') {
                        throw new Error(`‚ö†Ô∏è Image Generation Failed\n\n${finishMessage}\n\nTips:\n‚Ä¢ Try simplifying your prompt\n‚Ä¢ Use more specific description\n‚Ä¢ Try a different approach or WAN 2.6`);
                    }

                    // Other errors
                    throw new Error(`‚ùå Gemini Error (${candidate.finishReason})\n\n${finishMessage}`);
                }

                // Find image part in response (support both camelCase and snake_case)
                const imagePart = candidate.content?.parts?.find(p => p.inlineData || p.inline_data);

                // üîç DEBUG: Log parts array
                console.log('üîç Parts array:', candidate.content?.parts);
                console.log('üîç Image part found:', imagePart);

                if (!imagePart) {
                    throw new Error('No image generated in response. The API returned successfully but without image data.');
                }

                // Support both camelCase (inlineData) and snake_case (inline_data)
                const imageData = imagePart.inlineData || imagePart.inline_data;
                const generatedBase64 = imageData.data;
                const mimeType = imageData.mimeType || imageData.mime_type || 'image/jpeg';
                const fullBase64 = `data:${mimeType};base64,${generatedBase64}`;

                console.log('‚úÖ Image generated successfully');

                // Increment counter for unique filename
                imageEditCounter++;
                saveImageEditCounter();

                // Create pseudo prediction ID for history
                const pseudoId = `gemini-${Date.now()}-${imageEditCounter}`;

                // Save task input for history
                saveTaskInput(pseudoId, {
                    prompt: prompt,
                    negativePrompt: '',
                    model: 'Gemini 2.5 Flash',
                    modelKey: 'gemini-25-flash-image',
                    outputType: 'image',
                    timestamp: new Date().toISOString(),
                    imageCounter: imageEditCounter
                });

                // Add to history
                const placeholderImageData = {
                    id: pseudoId,
                    url: fullBase64,  // Gemini returns base64 directly
                    prompt: prompt,
                    negativePrompt: '',
                    model: 'Gemini 2.5 Flash',
                    modelKey: 'gemini-25-flash-image',
                    provider: 'gemini',
                    outputType: 'image',
                    status: 'completed',
                    initialImage: fullBase64,  // ‚úÖ FIX v2.12.18: Use edited image, not original
                    createdAt: new Date().toISOString()
                };

                videoHistoryData.unshift(placeholderImageData);

                // üíæ v2.12.21: Save to localStorage (will be replaced with imgbb URL shortly)
                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                renderVideoHistory();

                // üöÄ v2.12.21: Upload to imgbb for permanent storage
                try {
                    console.log('üì§ Uploading Gemini image to imgbb...');
                    const imgbbUrl = await uploadImageToImgbb(fullBase64);
                    console.log('‚úÖ Gemini image uploaded:', imgbbUrl);

                    // Update history item with permanent URL
                    const geminiIndex = videoHistoryData.findIndex(v => v.id === pseudoId);
                    if (geminiIndex !== -1) {
                        videoHistoryData[geminiIndex].url = imgbbUrl;
                        videoHistoryData[geminiIndex].imgbbUrl = imgbbUrl;
                        // üî• Remove base64 to save space (imgbb URL is now the source)
                        delete videoHistoryData[geminiIndex].initialImage;
                        console.log('üíæ Updated Gemini history with permanent imgbb URL (removed base64)');
                    }

                    // Save with permanent URL (tiny size!)
                    safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                    console.log('üíæ Gemini history saved with imgbb URL (no quota issues!)');

                    // üîÑ Re-render to show imgbb URL instead of base64
                    renderVideoHistory();
                    console.log('üîÑ History re-rendered with imgbb URL');

                } catch (uploadError) {
                    console.warn('‚ö†Ô∏è imgbb upload failed, keeping base64 as fallback:', uploadError.message);
                    // Base64 already saved above, just log the warning
                }

                // Handle completion
                await handleImageEditCompleteGemini(fullBase64);

            } catch (error) {
                console.error('Gemini image edit error:', error);

                // ‚ú® NEW (v2.9.0): Handle specific error types
                let errorMessage = error.message;

                // Timeout error
                if (error.name === 'AbortError') {
                    errorMessage = '‚è±Ô∏è Request Timeout\n\nThe Gemini API took too long to respond (>30s).\n\nTips:\n‚Ä¢ Try again - server might be busy\n‚Ä¢ Simplify your prompt\n‚Ä¢ Try WAN 2.6 instead';
                }
                // Network error
                else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMessage = 'üåê Network Error\n\nCould not connect to Gemini API.\n\nTips:\n‚Ä¢ Check your internet connection\n‚Ä¢ Gemini API might be down\n‚Ä¢ Try again in a few minutes';
                }
                // Invalid API key (401)
                else if (error.message.includes('401') || error.message.includes('API key not valid')) {
                    errorMessage = 'üîë Invalid API Key\n\nYour Gemini API key is invalid or expired.\n\nSolution:\n‚Ä¢ Get a new key at: https://aistudio.google.com/app/apikey\n‚Ä¢ Update the key in Settings';
                }
                // Quota exceeded (429)
                else if (error.message.includes('429') || error.message.includes('quota exceeded')) {
                    errorMessage = 'üìä Quota Exceeded\n\nYou have exceeded your Gemini API quota.\n\nSolution:\n‚Ä¢ Wait for quota reset (usually 1 minute for free tier)\n‚Ä¢ Upgrade at: https://aistudio.google.com/\n‚Ä¢ Use WAN 2.6 instead';
                }

                alert('‚ùå Gemini Error\n\n' + errorMessage);
                editBtn.disabled = false;
                editBtn.innerHTML = originalText;
                hideFloatingProcessing();
                hideImageEditOverlay();
            }
        }

        // Handle Gemini edit completion (similar to WAN handler but no URL fetch)
        async function handleImageEditCompleteGemini(base64Data) {
            try {
                // Update image in UI
                imageBase64Data = base64Data;
                window.imageBase64Data = base64Data;
                const previewImg = document.getElementById('image-preview-left');

                hideFloatingProcessing(() => {
                    if (previewImg) {
                        previewImg.style.transition = 'opacity 300ms ease-in-out';
                        previewImg.style.opacity = '0';

                        setTimeout(() => {
                            previewImg.src = base64Data;
                            previewImg.style.opacity = '1';

                            const previewContainer = document.getElementById('image-preview-container-left');
                            if (previewContainer) {
                                previewContainer.classList.add('border-pulse-cyan');
                                setTimeout(() => {
                                    previewContainer.classList.remove('border-pulse-cyan');
                                }, 1000);
                            }
                        }, 300);
                    }
                });

                // Add to edit history
                if (typeof window.imageEditHistory !== 'undefined') {
                    window.imageEditHistory.add(base64Data);
                }

                // Update modal image if open
                const modalImageFull = document.getElementById('modal-image-full');
                if (modalImageFull) {
                    modalImageFull.src = base64Data;
                }

                // Auto-save to downloads if enabled
                const autoSaveEnabled = document.getElementById('auto-save-toggle')?.checked;
                if (autoSaveEnabled) {
                    downloadImageFromBase64(base64Data, `edited_${imageEditCounter}.jpg`);
                }

                // Reset edit button
                const editBtn = document.getElementById('edit-image-btn');
                editBtn.disabled = false;
                editBtn.innerHTML = '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg> <span id="edit-btn-text">Edit Image</span>';

                syncBothUIs('updateProgress', { width: '100%' });
                syncBothUIs('updateStatusText', { text: 'Completed!' });

                console.log('‚úÖ Gemini image edit completed');

            } catch (error) {
                console.error('Gemini completion error:', error);
                throw error;
            }
        }

        // Validation for Gemini edit
        function validateImageEditGemini() {
            // Check API key
            const apiKey = getGeminiApiKey();
            if (!apiKey) {
                alert('‚ùå Please enter your Gemini API Key before editing.\n\nGet one at: https://aistudio.google.com/app/apikey');
                return false;
            }

            // Check image
            if (!imageBase64Data) {
                alert('‚ùå Please attach an image before editing.');
                return false;
            }

            // Check prompt
            const prompt = document.getElementById('prompt')?.value?.trim();
            if (!prompt) {
                alert('‚ùå Please enter editing instructions in the prompt field.');
                return false;
            }

            return true;
        }

        // Get Gemini API Key (reuse existing storage)
        function getGeminiApiKey() {
            const apiKeyInput = document.getElementById('api-key-gemini');
            return apiKeyInput?.value || localStorage.getItem('gemini_api_key') || '';
        }

        // ========== END: Gemini Integration ==========

        // ========== üöÄ NEW: Grok API Integration (x.ai) ==========

        // Helper: Convert base64 to Blob for file upload
        function base64ToBlob(base64Data, contentType = 'image/jpeg') {
            const base64 = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: contentType });
        }

        // Upload image to imgbb (for Grok video generation - requires public URL)
        async function uploadImageToImgbb(base64Data) {
            const imgbbApiKey = localStorage.getItem('imgbb_api_key');
            if (!imgbbApiKey) {
                throw new Error('imgbb API key not found. Please add it in Settings.');
            }

            console.log('üì§ Uploading image to imgbb...');

            try {
                // Remove data:image/jpeg;base64, prefix if present
                const base64 = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;

                // Create form data
                const formData = new FormData();
                formData.append('image', base64);

                // Upload to imgbb
                const response = await fetch(`https://api.imgbb.com/1/upload?key=${imgbbApiKey}`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`imgbb upload failed: ${response.status}`);
                }

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error?.message || 'Upload failed');
                }

                const publicUrl = data.data.url;
                console.log('‚úÖ Image uploaded to imgbb:', publicUrl);

                return publicUrl;
            } catch (error) {
                console.error('‚ùå imgbb upload failed:', error);
                throw new Error(`Image upload failed: ${error.message}`);
            }
        }

        // Upload image for Grok (uses imgbb to get public URL)
        async function uploadImageToGrok(base64Data) {
            // Grok video generation requires PUBLIC URL, not file_id
            // Files API is for chat/RAG only
            return await uploadImageToImgbb(base64Data);
        }

        // Generate video with Grok
        async function generateVideo_Grok(apiKey, config, prompt, base64Data, duration, resolution, aspectRatio = null, abortController = null) {
            console.log('üé¨ Starting Grok video generation...');

            if (!base64Data) {
                throw new Error("No image provided for Grok Image-to-Video");
            }

            try {
                // 1. Upload image to get file_id or public URL
                const imageRef = await uploadImageToGrok(base64Data);

                // 2. Build payload
                const payload = {
                    model: 'grok-imagine-video',
                    prompt: prompt,
                    image: { url: imageRef },  // Try file_id first (might need public URL)
                    duration: duration || 5,
                    resolution: resolution || '720p'
                };

                // Add aspect ratio ONLY if explicitly provided (otherwise Grok auto-detects from image)
                if (aspectRatio && config.aspectRatios?.includes(aspectRatio)) {
                    payload.aspect_ratio = aspectRatio;
                    console.log('üìê Using explicit aspect ratio:', aspectRatio);
                } else {
                    console.log('üìê Aspect ratio omitted - Grok will auto-detect from source image');
                }

                console.log('üì§ Grok video generation request:', payload);

                // 3. Start generation
                let timeoutId = null;
                if (abortController) {
                    timeoutId = setTimeout(() => {
                        abortController.abort();
                        console.log('‚è±Ô∏è Grok request timeout (120s) - aborted');
                    }, 120000);
                }

                const response = await fetch('https://api.x.ai/v1/videos/generations', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload),
                    signal: abortController?.signal
                });

                if (timeoutId) clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('‚úÖ Grok generation response:', data);

                // 4. Extract request_id (support both flat and nested structure)
                const requestId = data.request_id || data.video?.request_id || data.id;
                if (!requestId) {
                    throw new Error('No request_id found in Grok response');
                }

                console.log('‚úÖ Grok generation started:', requestId);
                currentGenerationId = requestId;
                currentPollingUrl = `https://api.x.ai/v1/videos/${requestId}`;
                syncBothUIs('updateGenerationDetails', { id: requestId });

                // üíæ v2.12.14: CRITICAL - Save metadata immediately for recovery
                await saveGrokMetadata(requestId, {
                    requestId,
                    prompt: prompt,
                    config: {
                        duration,
                        resolution,
                        aspectRatio
                    },
                    createdAt: new Date().toISOString()
                });

                // Save task input
                const taskId = currentGenerationId;
                saveTaskInput(taskId, {
                    prompt: prompt,
                    duration: duration,
                    resolution: resolution,
                    aspectRatio: aspectRatio,
                    model: config?.name || 'Grok Imagine Video',
                    modelKey: 'grok-imagine-video',
                    timestamp: new Date().toISOString(),
                    craftData: captureCraftData()
                });

                // Update placeholder
                const placeholderIndex = videoHistoryData.findIndex(v => v.isPlaceholder === true);
                if (placeholderIndex !== -1) {
                    videoHistoryData[placeholderIndex].id = requestId;
                    videoHistoryData[placeholderIndex].status = 'pending';
                    delete videoHistoryData[placeholderIndex].isPlaceholder;
                    renderVideoHistory();
                }

                saveGenerationState();
                return true;

            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('‚èπÔ∏è Grok generation cancelled');
                    AppState.generation.abortController = null;
                    return false;
                }

                handleGenerationError(error);
                return false;
            }
        }

        // Poll Grok video result
        async function pollGrokVideoStatus(requestId, apiKey) {
            console.log('üîÑ Polling Grok video status:', requestId);

            try {
                const response = await fetch(`https://api.x.ai/v1/videos/${requestId}`, {
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('üì• Grok status:', data.status);

                return {
                    status: data.status,  // pending|processing|completed|failed
                    url: data.url,
                    error: data.error
                };

            } catch (error) {
                console.error('‚ùå Grok polling error:', error);
                return { status: 'failed', error: error.message };
            }
        }

        // Edit image with Grok
        async function editImage_Grok() {
            console.log('üñºÔ∏è Starting Grok image edit...');

            // Validation
            if (!validateImageEditGrok()) {
                return;
            }

            // Get image data
            const imageData = captureImageData();
            if (!imageData || !imageData.cropped) {
                alert('‚ùå No image to edit. Please upload an image first.');
                return;
            }

            // Get prompt
            const prompt = document.getElementById('prompt')?.value?.trim();
            if (!prompt) {
                alert('‚ùå Please enter editing instructions.');
                return;
            }

            // Show processing overlay
            updateImageEditOverlay('‚öôÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û...');

            const apiKey = getGrokApiKey();

            try {
                // Grok accepts base64 data URI directly for image editing!
                const dataUri = imageData.cropped;

                const payload = {
                    model: 'grok-imagine-image',
                    image: dataUri,  // data:image/jpeg;base64,...
                    prompt: prompt
                };

                console.log('üì§ Grok image edit request');

                const response = await fetch('https://api.x.ai/v1/images/edits', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                console.log('‚úÖ Grok image edit complete');

                // Get result URL (instant response, no polling!)
                const resultUrl = data.data?.[0]?.url;
                if (!resultUrl) {
                    throw new Error('No image URL in response');
                }

                // Download and display edited image
                await handleImageEditCompleteGrok(resultUrl);

            } catch (error) {
                console.error('‚ùå Grok image edit failed:', error);
                updateImageEditOverlay('‚ùå ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß');

                let errorMessage = `‚ùå Image Edit Failed\n\n${error.message}`;

                // Check for content filter (CRITICAL for testing!)
                if (checkGrokContentFilter(error.message)) {
                    errorMessage += '\n\n‚ö†Ô∏è Content Filter Detected!';
                    console.warn('üö® GROK CONTENT FILTER TRIGGERED:', error.message);
                }

                alert(errorMessage);
            }
        }

        // Handle Grok image edit complete
        async function handleImageEditCompleteGrok(imageUrl) {
            console.log('üì• Downloading edited image from Grok:', imageUrl);

            try {
                // Download image
                const response = await fetch(imageUrl);
                if (!response.ok) {
                    throw new Error(`Failed to download image: ${response.status}`);
                }

                const blob = await response.blob();
                const base64Data = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });

                // Display edited image
                const imageDisplay = document.getElementById('uploaded-image-display');
                if (imageDisplay) {
                    imageDisplay.src = base64Data;
                    console.log('‚úÖ Edited image displayed');
                }

                // Hide overlay
                updateImageEditOverlay('');

                // Show success message
                alert('‚úÖ Image edited successfully with Grok!');

            } catch (error) {
                console.error('‚ùå Failed to display edited image:', error);
                updateImageEditOverlay('‚ùå ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß');
                alert(`‚ùå Failed to download edited image:\n\n${error.message}`);
            }
        }

        // Validate Grok image edit
        function validateImageEditGrok() {
            // Check API key
            const apiKey = getGrokApiKey();
            if (!apiKey) {
                alert('‚ùå Please enter your Grok API Key in Settings.\n\nGet one at: https://console.x.ai/');
                return false;
            }

            // Check image
            const imageDisplay = document.getElementById('uploaded-image-display');
            if (!imageDisplay || !imageDisplay.src || imageDisplay.src === '') {
                alert('‚ùå No image to edit. Please upload an image first.');
                return false;
            }

            // Check prompt
            const prompt = document.getElementById('prompt')?.value?.trim();
            if (!prompt) {
                alert('‚ùå Please enter editing instructions in the prompt field.');
                return false;
            }

            return true;
        }

        // Get Grok API Key
        function getGrokApiKey() {
            return localStorage.getItem('grok_api_key') || '';
        }

        // Check for Grok content filter (CRITICAL for NSFW testing!)
        // üö® IMPORTANT: Grok charges for every request, even failed ones!
        function checkGrokContentFilter(errorMessage) {
            if (!errorMessage) return false;

            const contentFilterKeywords = [
                'content moderation',       // üö® PRIMARY: Grok's actual error message
                'rejected by',              // üö® PRIMARY: "rejected by content moderation"
                'content filter',
                'content policy',
                'policy violation',
                'inappropriate',
                'nsfw',
                'adult',
                'explicit',
                'safety',
                'harmful'
            ];

            const lowerMsg = errorMessage.toLowerCase();
            return contentFilterKeywords.some(keyword => lowerMsg.includes(keyword));
        }

        // Download Grok video as blob to avoid CORS issues
        async function downloadGrokVideoAsBlob(videoUrl) {
            console.log('üì• Downloading Grok video as blob:', videoUrl);

            try {
                // üß™ TEST: Try WITHOUT Authorization header first
                // Theory: Grok video URLs might be public/pre-signed and don't need auth
                console.log('üß™ Attempting download WITHOUT Authorization header...');
                let response = await fetch(videoUrl);

                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è Download without auth failed: ${response.status}`);

                    // Fallback: Try WITH Authorization header
                    console.log('üîÑ Retrying WITH Authorization header...');
                    const apiKey = getGrokApiKey();
                    response = await fetch(videoUrl, {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed with auth: ${response.status}`);
                    }
                }

                console.log(`‚úÖ Download successful (status: ${response.status})`);
                const blob = await response.blob();
                console.log('‚úÖ Video downloaded, size:', blob.size, 'bytes');

                // Create blob URL
                const blobUrl = URL.createObjectURL(blob);
                console.log('‚úÖ Blob URL created:', blobUrl);

                return blobUrl;
            } catch (error) {
                console.error('‚ùå Failed to download Grok video:', error);
                console.error('‚ùå This video cannot be cached. Using original URL (may have CORS issues)');
                // Fallback to direct URL (may still have CORS issue)
                return videoUrl;
            }
        }

        // ========== END: Grok API Integration ==========

        // ========== ‚ú® NEW: Global scope for image edit tracking (v2.4.2) ==========
        let currentEditPredictionId = null;
        let currentEditStartTime = null;
        // ========== END: Global Tracking Variables ==========

        // Polling for edit status
        async function pollImageEditStatus(predictionId, pollingUrl) {
            // ========== ‚ú® NEW: Store in global scope for handleImageEditComplete (v2.4.2) ==========
            currentEditPredictionId = predictionId;
            currentEditStartTime = Date.now();
            // ========== END: Store Variables ==========

            const maxAttempts = 300;  // 5 minutes max (increased for WAN 2.6 image edit)
            const expectedDuration = 30000; // 30 seconds in milliseconds
            let attempts = 0;

            const startTime = Date.now(); // Track start time

            // Show progress bar (reuse existing video progress UI)
            syncBothUIs('updateProgress', { width: '0%' });
            syncBothUIs('updateStatusText', { text: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...' });

            // Update hologram overlay
            updateImageEditOverlay('‚öôÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...');

            // Get API key
            const apiKey = getWavespeedApiKey();

            const pollInterval = setInterval(async () => {
                attempts++;

                try {
                    // Use the polling URL provided by the API
                    const response = await fetch(pollingUrl, {
                        headers: {
                            'Authorization': `Bearer ${apiKey}`
                        }
                    });

                    // Read response text first
                    const responseText = await response.text();

                    // Parse JSON response
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('‚ùå Polling JSON Parse Error:', parseError);
                        console.error('Response text:', responseText);
                        throw new Error(`Invalid polling response: ${responseText.substring(0, 100)}`);
                    }

                    console.log(`üîÑ Polling attempt ${attempts}:`, data);

                    // Extract status from response (Wan 2.6 format)
                    const status = data.data?.status || data.status;
                    const outputs = data.data?.outputs || data.outputs || [];

                    // Calculate progress based on elapsed time (30 seconds expected)
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min((elapsedTime / expectedDuration) * 100, 95);

                    syncBothUIs('updateProgress', { width: `${progress}%` });
                    syncBothUIs('updateStatusText', { text: status || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...' });

                    // Update hologram overlay with progress
                    updateImageEditOverlay(`‚öôÔ∏è ${status || '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•'}... ${Math.round(progress)}%`);

                    // ‚ú® NEW (v2.8.2): Also update floating visual progress
                    updateFloatingProgress(Math.round(progress));

                    // Check completion (Wan 2.6 status: created -> processing -> completed/failed)
                    if ((status === 'completed' || status === 'succeeded') && outputs.length > 0) {
                        clearInterval(pollInterval);
                        console.log('‚úÖ Image edit completed:', outputs[0]);
                        await handleImageEditComplete(outputs[0]);
                    } else if (status === 'failed') {
                        clearInterval(pollInterval);
                        throw new Error(data.data?.error || data.error || 'Image edit failed');
                    } else if (attempts >= maxAttempts) {
                        clearInterval(pollInterval);
                        console.log('‚ö†Ô∏è Timeout reached. Last status:', status, 'Outputs:', outputs);
                        throw new Error(`Timeout: Image edit took too long (last status: ${status})`);
                    }

                } catch (error) {
                    clearInterval(pollInterval);
                    handleImageEditError(error);
                }
            }, 1000);
        }

        // Handle successful edit
        async function handleImageEditComplete(imageUrl) {
            try {
                // Download and convert to base64
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                const base64 = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });

                // Replace image in UI
                imageBase64Data = base64;
                window.imageBase64Data = base64; // ‚ú® NEW: Sync to window for history navigation
                const previewImg = document.getElementById('image-preview-left');

                // ‚ú® NEW (v2.8.2): Hide floating visual with callback
                hideFloatingProcessing(() => {
                    if (previewImg) {
                        // ‚ú® NEW: Smooth transition when showing result
                        previewImg.style.transition = 'opacity 300ms ease-in-out';
                        previewImg.style.opacity = '0';

                        setTimeout(() => {
                            previewImg.src = base64;
                            previewImg.style.opacity = '1';

                            // Pulse glow effect to indicate new image
                            const previewContainer = document.getElementById('image-preview-container-left');
                            if (previewContainer) {
                                previewContainer.classList.add('border-pulse-cyan');
                                setTimeout(() => {
                                    previewContainer.classList.remove('border-pulse-cyan');
                                }, 1000);
                            }
                        }, 300);

                        // ‚ú® REMOVED: Direct onclick handlers that conflict with wrapper listener
                        // The previewWrapperLeft listener (line 3782) handles clicks via window.imageBase64Data
                    }
                });

                // Add to edit history
                if (typeof window.imageEditHistory !== 'undefined') {
                    window.imageEditHistory.add(base64);
                }

                // ========== ‚ú® NEW: Update placeholder in videoHistoryData (v2.4.2) ==========
                if (currentEditPredictionId) {
                    const placeholderIndex = videoHistoryData.findIndex(v => v.id === currentEditPredictionId);

                    // üîç DEBUG: Log search results (v2.12.15)
                    console.log('üîç Searching for placeholder:', {
                        searchId: currentEditPredictionId,
                        foundIndex: placeholderIndex,
                        totalItems: videoHistoryData.length,
                        allIds: videoHistoryData.map(v => v.id).slice(0, 10)
                    });

                    if (placeholderIndex !== -1) {
                        // Calculate processing time
                        const processingTimeSec = currentEditStartTime ?
                            ((Date.now() - currentEditStartTime) / 1000).toFixed(1) : 0;

                        // üîç DEBUG: Log before update (v2.12.15)
                        console.log('üìù Before update:', {
                            status: videoHistoryData[placeholderIndex].status,
                            initialImage: videoHistoryData[placeholderIndex].initialImage?.substring(0, 50) + '...'
                        });

                        // Update placeholder with completed data
                        videoHistoryData[placeholderIndex] = {
                            ...videoHistoryData[placeholderIndex],
                            url: imageUrl,  // URL ‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
                            initialImage: base64,  // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï thumbnail ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡πÉ‡∏´‡∏°‡πà
                            status: 'completed',  // ‚Üê CRITICAL: Update status
                            processingTime: parseFloat(processingTimeSec)
                        };

                        // üîç DEBUG: Log after update (v2.12.15)
                        console.log('‚úÖ After update:', {
                            status: videoHistoryData[placeholderIndex].status,
                            initialImage: videoHistoryData[placeholderIndex].initialImage?.substring(0, 50) + '...',
                            url: videoHistoryData[placeholderIndex].url
                        });

                        // Save to localStorage with validation
                        let saveSuccess = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                        // üîç DEBUG: Log save result (v2.12.15)
                        console.log('üíæ localStorage save:', saveSuccess ? 'SUCCESS' : 'FAILED');

                        // üö® EMERGENCY FIX (v2.12.16): If save fails due to quota, strip old initialImages
                        if (!saveSuccess) {
                            console.warn('‚ö†Ô∏è Save failed - attempting emergency cleanup of old initialImages...');

                            // Keep only the current edited image's initialImage, remove from others
                            const cleanedHistory = videoHistoryData.map((item, idx) => {
                                if (idx === placeholderIndex) {
                                    // Keep the current edited image
                                    return item;
                                } else if (item.initialImage && item.initialImage.length > 10000) {
                                    // Remove large base64 images from old items
                                    const { initialImage, ...itemWithoutImage } = item;
                                    return itemWithoutImage;
                                }
                                return item;
                            });

                            videoHistoryData = cleanedHistory;
                            saveSuccess = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                            console.log('üîÑ After emergency cleanup:', saveSuccess ? 'SUCCESS' : 'STILL FAILED');
                        }

                        // Re-render (even if save failed, in-memory update is still there)
                        renderVideoHistory();

                        console.log('‚úÖ Updated image edit placeholder:', currentEditPredictionId);
                    } else {
                        // üö® ERROR: Placeholder not found (v2.12.15)
                        console.error('‚ùå PLACEHOLDER NOT FOUND:', {
                            searchId: currentEditPredictionId,
                            totalItems: videoHistoryData.length,
                            providerCounts: {
                                wavespeed: videoHistoryData.filter(v => v.provider === 'wavespeed').length,
                                grok: videoHistoryData.filter(v => v.provider === 'grok').length,
                                gemini: videoHistoryData.filter(v => v.provider === 'gemini').length
                            },
                            recentIds: videoHistoryData.map(v => v.id).slice(0, 5)
                        });

                        // FALLBACK: Add as new item instead of updating
                        const processingTimeSec = currentEditStartTime ?
                            ((Date.now() - currentEditStartTime) / 1000).toFixed(1) : 0;

                        const newItem = {
                            id: currentEditPredictionId,
                            url: imageUrl,
                            initialImage: base64,
                            prompt: 'Image edit completed',
                            model: 'Wan 2.6 Image Edit',
                            modelKey: 'ws-wan-26-image-edit',
                            provider: 'wavespeed',
                            outputType: 'image',
                            status: 'completed',
                            processingTime: parseFloat(processingTimeSec),
                            createdAt: new Date().toISOString()
                        };

                        videoHistoryData.unshift(newItem);
                        let fallbackSaveSuccess = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                        // üö® EMERGENCY FIX (v2.12.16): If save fails, strip old initialImages
                        if (!fallbackSaveSuccess) {
                            console.warn('‚ö†Ô∏è Fallback save failed - attempting emergency cleanup...');
                            const cleanedHistory = videoHistoryData.map((item, idx) => {
                                if (idx === 0) {
                                    return item; // Keep the new edited image
                                } else if (item.initialImage && item.initialImage.length > 10000) {
                                    const { initialImage, ...itemWithoutImage } = item;
                                    return itemWithoutImage;
                                }
                                return item;
                            });
                            videoHistoryData = cleanedHistory;
                            fallbackSaveSuccess = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                            console.log('üîÑ After emergency cleanup:', fallbackSaveSuccess ? 'SUCCESS' : 'STILL FAILED');
                        }

                        renderVideoHistory();

                        console.log('‚ûï Added image edit as new item (fallback)');
                    }
                }
                // ========== END: Update Placeholder ==========

                // Auto-save to Downloads folder (if enabled)
                const autoSaveToggle = document.getElementById('auto-save-toggle');
                if (autoSaveToggle && autoSaveToggle.checked) {
                    await saveEditedImage(base64);
                    console.log('‚úÖ Image auto-saved');
                }

                // Refresh credit balance after image edit
                fetchUsageStats_Wavespeed();

                // Update UI (no longer need isImageEdited state - use history instead)
                syncBothUIs('updateProgress', { width: '100%' });
                syncBothUIs('updateStatusText', { text: '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' });

                // Show success on hologram overlay briefly before hiding
                updateImageEditOverlay('‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
                setTimeout(() => {
                    hideImageEditOverlay();
                }, 1500);

                // Reset edit button
                const editBtn = document.getElementById('edit-image-btn');
                editBtn.disabled = false;
                editBtn.innerHTML = '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg> Edit Image with Wan 2.6 <span class="text-xs text-gray-400">($0.035)</span>';

                // No alert popup - just show the new image


            } catch (error) {
                handleImageEditError(error);
            }
        }

        // Handle edit error
        function handleImageEditError(error) {
            console.error('Image edit error:', error);
            alert('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏†‡∏≤‡∏û\n\n' + error.message);

            const editBtn = document.getElementById('edit-image-btn');
            editBtn.disabled = false;
            editBtn.innerHTML = '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg> Edit Image with Wan 2.6 <span class="text-xs text-gray-400">($0.035)</span>';

            syncBothUIs('updateProgress', { width: '0%' });
            syncBothUIs('updateStatusText', { text: '' });

            // ‚ú® NEW (v2.8.2): Hide floating visual on error
            hideFloatingProcessing();
            // Hide hologram overlay
            hideImageEditOverlay();
        }

        // Save edited image to file system
        async function saveEditedImage(base64Data) {
            try {
                // Increment counter
                imageEditCounter++;
                saveImageEditCounter();

                // Format filename: wan26edit_001.png
                const filename = `wan26edit_${String(imageEditCounter).padStart(3, '0')}.png`;
                const folderPath = 'wan_image_edited';

                // Convert base64 to blob
                const base64WithoutPrefix = base64Data.split(',')[1];
                const byteCharacters = atob(base64WithoutPrefix);
                const byteArrays = [];
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteArrays.push(byteCharacters.charCodeAt(i));
                }
                const blob = new Blob([new Uint8Array(byteArrays)], { type: 'image/png' });

                // Auto-download (browser will save to default download folder)
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);

                console.log(`‚úÖ Auto-downloading edited image: ${filename}`);

            } catch (error) {
                console.error('Failed to save edited image:', error);
            }
        }

        // Note: Undo/Redo functionality now handled by image_edit_history.js
        // Using navigation buttons < Edited > instead of simple undo button

        // Initialize image edit system
        function initImageEditSystem() {
            loadImageEditCounter();

            // ========== ‚ú® UPDATED (v2.9.0): Route to provider-specific function ==========
            // Edit button listener - routes to correct provider
            document.getElementById('edit-image-btn')?.addEventListener('click', routeImageEdit);

            // Model selector listener - update UI when changed
            document.getElementById('image-edit-model-select')?.addEventListener('change', updateImageEditModelUI);

            // Initialize model-specific UI on load
            updateImageEditModelUI();
            // ========== END: Model Router Setup ==========

            // ‚ú® NEW: Listen for history navigation to sync local variable
            window.addEventListener('imageHistoryNavigated', (e) => {
                imageBase64Data = e.detail.imageData;
                console.log(`üì∏ Image synced from history: ${e.detail.index + 1}`);
            });

            // Note: Undo/Redo handled by image_edit_history.js navigation buttons
            // History is cleared automatically when new image is uploaded (handled in image_edit_history.js)

            console.log('‚úÖ Image Edit System initialized (Gemini + WAN 2.6)');
        }

        // Debug helper - call from console: debugImageEditControls()
        window.debugImageEditControls = function () {
            console.log('=== IMAGE EDIT DEBUG INFO ===');
            console.log('Controls element:', document.getElementById('image-edit-controls'));
            console.log('Image data exists:', imageBase64Data !== null);
            console.log('Image data length:', imageBase64Data?.length);
            console.log('Controls visible:', !document.getElementById('image-edit-controls')?.classList.contains('hidden'));
            console.log('Note: Image Edit uses Wan 2.6 API backend (not related to video model dropdown)');
            console.log('============================');
            updateImageEditControls();
        };

        // ========== END: WAN 2.6 IMAGE EDIT SYSTEM ==========

        // --- Video History ---
        function loadHistoryFromLocalStorage() {
            try {
                let storedHistory = localStorage.getItem('videoHistory');
                videoHistoryData = storedHistory ? JSON.parse(storedHistory) : [];
                if (!Array.isArray(videoHistoryData)) {
                    console.warn("localStorage 'videoHistory' was not an array, resetting.");
                    videoHistoryData = [];
                }

                // üßπ AUTO-CLEANUP: Remove invalid/failed items without URL
                // üîß v2.12.13 FIX: Check BOTH "url" (current) AND "video_url" (legacy) fields
                const beforeCount = videoHistoryData.length;
                videoHistoryData = videoHistoryData.filter(video => {
                    // Keep items that have url OR video_url (legacy) OR are currently processing
                    // üõ°Ô∏è v2.12.19: Gemini images have initialImage instead of url
                    const hasValidUrl = (video.url && video.url.trim() !== '') ||
                                        (video.video_url && video.video_url.trim() !== '');
                    const hasValidImage = video.initialImage && video.initialImage.length > 100;
                    const isProcessing = video.status === 'pending' || video.status === 'processing' || video.status === 'starting';

                    // Keep items with valid URL OR valid image OR currently processing
                    if (!hasValidUrl && !hasValidImage && !isProcessing) {
                        console.log(`üóëÔ∏è Auto-cleanup: Removing invalid item ${video.id} (no URL/image, status: ${video.status})`);
                        return false;  // Remove this item
                    }
                    return true;  // Keep this item
                });

                // Save cleaned data back to localStorage if any items were removed
                if (videoHistoryData.length !== beforeCount) {
                    localStorage.setItem('videoHistory', JSON.stringify(videoHistoryData));
                    console.log(`‚úÖ Auto-cleanup: Removed ${beforeCount - videoHistoryData.length} invalid items`);
                }
            } catch (e) {
                console.error("Error parsing history from localStorage:", e);
                videoHistoryData = []; // Reset if parsing fails
                localStorage.removeItem('videoHistory'); // Clear corrupted data
            }
            renderVideoHistory(); // Always attempt to render, even if empty
        }

        // ========== ‚ú® NEW: Resume Pending Polling After Page Refresh ==========
        /**
         * Resume polling for pending/processing videos after page refresh
         * Scans history for incomplete items and checks their status
         */
        async function resumePendingPolling() {
            console.log('üîÑ Checking for pending items to resume...');

            // Check if API key is available
            const apiKey = apiKeyInput_ws?.value?.trim();
            if (!apiKey) {
                console.log('‚ö†Ô∏è No API key available, skipping resume polling');
                return;
            }

            // Find all pending/processing items
            const pendingStatuses = ['pending', 'in_progress', 'processing', 'in_queue', 'starting'];
            const pendingItems = videoHistoryData.filter(item =>
                item.id &&
                !item.url &&
                pendingStatuses.includes(item.status)
            );

            if (pendingItems.length === 0) {
                console.log('‚úÖ No pending items found');
                return;
            }

            console.log(`üìã Found ${pendingItems.length} pending item(s) to check`);

            // Check status for each pending item
            for (const item of pendingItems) {
                try {
                    // Construct polling URL from ID
                    // Format: https://api.wavespeed.ai/api/v3/predictions/{id}/result
                    const pollingUrl = `${WAVESPEED_API_BASE_URL}/predictions/${item.id}/result`;

                    console.log(`üîç Checking status for: ${item.id}`);

                    const response = await fetch(pollingUrl, {
                        method: 'GET',
                        headers: { 'Authorization': `Bearer ${apiKey}` }
                    });

                    if (!response.ok) {
                        console.warn(`‚ö†Ô∏è Failed to check ${item.id}: HTTP ${response.status}`);
                        continue;
                    }

                    const data = await response.json();

                    if (data.code === 200 && data.data) {
                        const status = data.data.status;
                        const outputs = data.data.outputs;

                        console.log(`üìä ${item.id} status: ${status}`);

                        // Update item in history
                        const itemIndex = videoHistoryData.findIndex(v => v.id === item.id);
                        if (itemIndex !== -1) {
                            videoHistoryData[itemIndex].status = status;

                            // If completed, save the video URL
                            if ((status === 'completed' || status === 'succeeded') && outputs && outputs[0]) {
                                videoHistoryData[itemIndex].url = outputs[0];
                                console.log(`‚úÖ ${item.id} completed! URL saved.`);

                                // Save to localStorage
                                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                            } else if (status === 'failed' || status === 'canceled') {
                                console.log(`‚ùå ${item.id} ${status}`);
                                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                            } else {
                                // Still processing - for the FIRST pending item, resume polling
                                if (pendingItems[0].id === item.id && !currentGenerationId) {
                                    console.log(`‚èØÔ∏è Resuming polling for ${item.id}...`);
                                    currentGenerationId = item.id;
                                    currentPollingUrl = pollingUrl;
                                    currentProvider = 'wavespeed';

                                    // Update UI
                                    if (statusBadge) {
                                        statusBadge.className = 'status-badge status-processing';
                                        statusBadge.textContent = 'RESUMING';
                                    }
                                    if (statusText) {
                                        statusText.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡πà‡∏≠...';
                                    }

                                    // Start polling
                                    startPolling(apiKey, pollingUrl);
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå Error checking ${item.id}:`, error);
                }
            }

            // Re-render history with updated statuses
            renderVideoHistory();
        }
        // ========== END: Resume Pending Polling ==========

        // ========== ‚ú® NEW: Recovery/Retry Functions ==========
        /**
         * Manually check status for a stuck video
         * @param {string} videoId - The video ID to check
         */
        async function checkVideoStatus(videoId) {
            console.log(`üîç Manually checking status for: ${videoId}`);

            const apiKey = apiKeyInput_ws?.value?.trim();
            if (!apiKey) {
                alert('API key required to check status');
                return;
            }

            try {
                const pollingUrl = `${WAVESPEED_API_BASE_URL}/predictions/${videoId}/result`;
                const response = await fetch(pollingUrl, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });

                if (!response.ok) {
                    alert(`Failed to check status: HTTP ${response.status}`);
                    return;
                }

                const data = await response.json();

                if (data.code === 200 && data.data) {
                    const status = data.data.status;
                    const outputs = data.data.outputs;

                    // Update item in history
                    const itemIndex = videoHistoryData.findIndex(v => v.id === videoId);
                    if (itemIndex !== -1) {
                        videoHistoryData[itemIndex].status = status;

                        if ((status === 'completed' || status === 'succeeded') && outputs && outputs[0]) {
                            videoHistoryData[itemIndex].url = outputs[0];
                            alert(`‚úÖ Video completed! Status: ${status}`);
                        } else if (status === 'failed' || status === 'canceled') {
                            alert(`‚ùå Video ${status}`);
                        } else {
                            alert(`‚ÑπÔ∏è Still processing. Status: ${status}`);
                        }

                        safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                        renderVideoHistory();
                    }
                } else {
                    alert('Failed to parse API response');
                }
            } catch (error) {
                console.error('Error checking status:', error);
                alert(`Error: ${error.message}`);
            }
        }

        /**
         * Mark a stuck video as failed
         * @param {string} videoId - The video ID to mark as failed
         */
        function markVideoAsFailed(videoId) {
            if (!confirm('Mark this video as failed? This cannot be undone.')) {
                return;
            }

            const itemIndex = videoHistoryData.findIndex(v => v.id === videoId);
            if (itemIndex !== -1) {
                videoHistoryData[itemIndex].status = 'failed';
                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));
                renderVideoHistory();
                console.log(`‚ùå Marked ${videoId} as failed`);
            }
        }

        /**
         * Retry a failed video generation with the same parameters
         * @param {string} videoId - The failed video ID
         */
        async function retryFailedVideo(videoId) {
            console.log(`üîÑ Retrying failed video: ${videoId}`);

            // Get saved task input
            const savedInput = getTaskInput(videoId);
            if (!savedInput) {
                alert('Cannot retry: No saved parameters found for this video');
                return;
            }

            // Confirm with user
            if (!confirm(`Retry with these parameters?\n\nPrompt: ${savedInput.prompt?.substring(0, 100)}...\nModel: ${savedInput.model}\nDuration: ${savedInput.duration}s`)) {
                return;
            }

            // Fill form with saved parameters
            const promptTextarea = document.getElementById('prompt');
            const negativePromptInput = document.getElementById('negative-prompt');
            const modelSelect = document.getElementById('model-select');
            const durationSelect = document.getElementById('duration-select');
            const resolutionSelect = document.getElementById('resolution-select');

            if (promptTextarea) promptTextarea.value = savedInput.prompt || '';
            if (negativePromptInput) negativePromptInput.value = savedInput.negativePrompt || '';
            if (modelSelect && savedInput.modelKey) modelSelect.value = savedInput.modelKey;
            if (durationSelect && savedInput.duration) durationSelect.value = savedInput.duration;
            if (resolutionSelect && savedInput.resolution) resolutionSelect.value = savedInput.resolution;

            // Restore Prompt Craft data if available
            if (savedInput.craftData) {
                restoreCraftData(savedInput.craftData);
            }

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });

            alert('‚úÖ Parameters restored! Click Generate to retry.');
        }

        // Make functions globally accessible
        window.checkVideoStatus = checkVideoStatus;
        window.markVideoAsFailed = markVideoAsFailed;
        window.retryFailedVideo = retryFailedVideo;
        // ========== END: Recovery/Retry Functions ==========

        // ========== ‚ú® NEW: Search/Filter/Export Functions ==========
        /**
         * Apply search, filter, and sort to history
         * Modifies videoHistoryData temporarily for rendering
         */
        let originalHistoryData = null; // Store original before filtering

        function applyHistorySearchFilter() {
            // Restore original data if we filtered before
            if (originalHistoryData) {
                videoHistoryData = [...originalHistoryData];
            } else {
                originalHistoryData = [...videoHistoryData];
            }

            let filteredData = [...videoHistoryData];

            // Apply search filter
            const searchInput = document.getElementById('history-search-input');
            if (searchInput && searchInput.value.trim()) {
                const searchTerm = searchInput.value.trim().toLowerCase();
                filteredData = filteredData.filter(v => {
                    // Pattern 1: Duration matching - "3s", "5s", "10s" ‚Üí match duration number
                    const durationMatch = searchTerm.match(/^(\d+)s?$/);
                    if (durationMatch) {
                        const durationValue = parseInt(durationMatch[1]);
                        if (v.duration === durationValue) return true;
                    }

                    // Pattern 2: Resolution matching - "480", "480p", "720", "720p", "1080", "1080p" ‚Üí match resolution string
                    const resolutionMatch = searchTerm.match(/^(\d+)p?$/);
                    if (resolutionMatch && v.resolution) {
                        const resNum = resolutionMatch[1];
                        if (v.resolution.toLowerCase().includes(resNum)) return true;
                    }

                    // Pattern 3: Output type matching - "image", "video", "edit"
                    if (searchTerm === 'image' || searchTerm === 'video') {
                        if (v.outputType && v.outputType.toLowerCase() === searchTerm) return true;
                    }
                    if (searchTerm === 'edit') {
                        if (v.outputType === 'image') return true;
                        if (v.modelKey && v.modelKey.toLowerCase().includes('edit')) return true;
                    }

                    // Pattern 4: Existing text search - prompt and model (preserve backward compatibility)
                    if ((v.prompt || '').toLowerCase().includes(searchTerm)) return true;
                    if ((v.model || '').toLowerCase().includes(searchTerm)) return true;

                    return false;
                });
            }

            // Apply status filter
            const statusFilter = document.getElementById('history-status-filter');
            if (statusFilter && statusFilter.value !== 'all') {
                const status = statusFilter.value;
                if (status === 'completed') {
                    filteredData = filteredData.filter(v =>
                        v.status === 'completed' || v.status === 'succeeded'
                    );
                } else if (status === 'failed') {
                    filteredData = filteredData.filter(v =>
                        v.status === 'failed' || v.status === 'canceled'
                    );
                } else if (status === 'processing') {
                    filteredData = filteredData.filter(v =>
                        v.status === 'pending' || v.status === 'in_progress' ||
                        v.status === 'processing' || v.status === 'in_queue'
                    );
                }
            }

            // Apply sort
            const sortOrder = document.getElementById('history-sort-order');
            if (sortOrder) {
                if (sortOrder.value === 'newest') {
                    filteredData.sort((a, b) =>
                        new Date(b.createdAt || 0) - new Date(a.createdAt || 0)
                    );
                } else if (sortOrder.value === 'oldest') {
                    filteredData.sort((a, b) =>
                        new Date(a.createdAt || 0) - new Date(b.createdAt || 0)
                    );
                }
            }

            // Update display
            videoHistoryData = filteredData;
            renderVideoHistory();
        }

        /**
         * Export history to JSON or CSV
         */
        function exportHistory() {
            if (!videoHistoryData || videoHistoryData.length === 0) {
                alert('No history to export');
                return;
            }

            // Ask user for format
            const format = prompt('Export format:\n1. JSON (full data)\n2. CSV (simplified)\n\nEnter 1 or 2:', '1');

            if (format === '1') {
                // Export as JSON
                const jsonData = JSON.stringify(videoHistoryData, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vidist_history_${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
                console.log('‚úÖ Exported history as JSON');
            } else if (format === '2') {
                // Export as CSV
                const headers = ['ID', 'Prompt', 'Model', 'Status', 'Duration', 'Resolution', 'Created At', 'URL'];
                const rows = videoHistoryData.map(v => [
                    v.id || '',
                    (v.prompt || '').replace(/"/g, '""'), // Escape quotes
                    v.model || '',
                    v.status || '',
                    v.duration || '',
                    v.resolution || '',
                    v.createdAt || '',
                    v.url || ''
                ]);

                const csv = [
                    headers.join(','),
                    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
                ].join('\n');

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `vidist_history_${new Date().toISOString().slice(0, 10)}.csv`;
                a.click();
                URL.revokeObjectURL(url);
                console.log('‚úÖ Exported history as CSV');
            } else {
                alert('Invalid format selected');
            }
        }

        // Make functions globally accessible
        window.applyHistorySearchFilter = applyHistorySearchFilter;
        window.exportHistory = exportHistory;
        // ========== END: Search/Filter/Export Functions ==========

        // ========== ‚ú® NEW: Kebab Menu Toggle Functions ==========
        /**
         * Toggle export menu dropdown
         */
        function toggleExportMenu() {
            const menu = document.getElementById('export-menu-list');
            if (!menu) return;

            const isHidden = menu.classList.contains('hidden');
            if (isHidden) {
                openExportMenu();
            } else {
                hideExportMenu();
            }
        }

        /**
         * Open export menu
         */
        function openExportMenu() {
            const menu = document.getElementById('export-menu-list');
            if (!menu) return;

            menu.classList.remove('hidden');
        }

        /**
         * Hide/close export menu
         */
        function hideExportMenu() {
            const menu = document.getElementById('export-menu-list');
            if (!menu) return;

            menu.classList.add('hidden');
        }

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const container = document.getElementById('export-menu-container');
            const menu = document.getElementById('export-menu-list');

            if (container && menu && !container.contains(e.target)) {
                hideExportMenu();
            }
        });

        // Make functions globally accessible
        window.toggleExportMenu = toggleExportMenu;
        window.hideExportMenu = hideExportMenu;
        // ========== END: Kebab Menu Toggle Functions ==========

        // ========== ‚ú® NEW: Smart Merge Helper for API Sync ==========
        /**
         * Merge local history item with API data without losing local fields
         * Local data (prompt, settings) is source of truth - never overwrite from API
         * API data (status, video_url) is updated
         *
         * @param {Object} localItem - Existing item from local history
         * @param {Object} apiData - Fresh data from API
         * @returns {Object} - Merged item
         */
        function mergeHistoryItem(localItem, apiData) {
            // Extract video URL from various API formats
            let videoUrl = null;
            if (apiData.outputs && Array.isArray(apiData.outputs) && apiData.outputs.length > 0) {
                videoUrl = apiData.outputs[0];
            } else if (apiData.output && Array.isArray(apiData.output) && apiData.output.length > 0) {
                videoUrl = apiData.output[0];
            } else if (typeof apiData.output === 'string') {
                videoUrl = apiData.output;
            }

            // üõ°Ô∏è SPECIAL: For completed image edits, NEVER overwrite initialImage (v2.12.15)
            const isCompletedImageEdit = localItem.outputType === 'image' &&
                                         localItem.status === 'completed' &&
                                         localItem.modelKey === 'ws-wan-26-image-edit';

            // Smart merge: Preserve all local fields, only update API-specific fields
            const merged = {
                ...localItem,                     // Keep all local data (base)
                status: apiData.status || localItem.status,  // Update status from API
                url: videoUrl || localItem.url,   // Update URL only if API provides one
                createdAt: apiData.created_at || localItem.createdAt, // Use API timestamp if available
                processingTime: apiData.metrics?.predict_time ||
                               (apiData.timings?.inference ? apiData.timings.inference / 1000 : localItem.processingTime),
                // CRITICAL: Never overwrite these fields from API
                // prompt, negativePrompt, craftData, modelKey, settings
                // These are already in localItem and should NOT be touched
            };

            // üõ°Ô∏è CRITICAL: For completed image edits, preserve edited image (v2.12.15)
            if (isCompletedImageEdit && localItem.initialImage) {
                merged.initialImage = localItem.initialImage;  // Force keep edited image
                console.log('üõ°Ô∏è Protected edited image for:', localItem.id);
            }

            return merged;
        }
        // ========== END: Smart Merge Helper ==========

        // ... (skipping refreshHistory modifications already done) ...

        // Go to downloadImage at the end of file to update it too
        // Since I cannot replace multiple non-contiguous blocks without MultiReplace (which works but Replace is safer for this context),
        // I will do saveEditedImage first, then downloadImage in next call or use MultiReplace if sure of context.
        // Actually, let's use MultiReplaceFileContent to cover both files changes in one go if I had enough context view.
        // But here I'm replacing a specific contiguous block for saveEditedImage.

        // I will submit this replacement for saveEditedImage first.


        async function refreshHistory() {
            console.log("Refreshing history from API and local storage...");
            const apiKey_ws = apiKeyInput_ws.value.trim();
            const wavespeedEnabled = toggleWavespeedApi.checked;

            if (!apiKey_ws) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà Wavespeed API key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥');
                return;
            }

            if (!wavespeedEnabled) {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Wavespeed API ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥');
                return;
            }

            videoHistory.innerHTML = '<p class="text-sm text-center py-8 neon-text-cyan pulse-glow">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Wavespeed... (Fetching from API)</p>';

            // 1. Prepare Local Data
            let allHistory = [];
            try {
                if (Array.isArray(videoHistoryData)) {
                    allHistory = [...videoHistoryData];
                }
            } catch (e) { allHistory = []; }

            // üõ°Ô∏è v2.12.14: ALWAYS include Grok videos from IndexedDB
            const grokVideosFromIDB = await getAllGrokVideos();
            const grokWithProvider = grokVideosFromIDB.map(v => ({ ...v, provider: 'grok' }));

            // Separate non-wavespeed items to preserve them (including Gemini which has no API)
            let otherProviderHistory = allHistory.filter(h => h && h.provider !== 'wavespeed');

            // Merge Grok from IDB with other providers
            otherProviderHistory = [
                ...otherProviderHistory,
                ...grokWithProvider
            ];

            // Deduplicate by ID
            const otherProviderMap = new Map();
            otherProviderHistory.forEach(h => {
                if (h.id && !otherProviderMap.has(h.id)) {
                    otherProviderMap.set(h.id, h);
                }
            });
            otherProviderHistory = Array.from(otherProviderMap.values());

            // ‚ú® NEW (v2.9.0): Gemini items don't have API to refresh - keep as-is
            const geminiHistory = otherProviderHistory.filter(h => h && h.provider === 'gemini');
            console.log(`üì∏ Preserving ${geminiHistory.length} Gemini image edits (no API refresh available)`);

            // Map for Wavespeed items (ID -> Item)
            const wavespeedMap = new Map();

            // Fill with existing local Wavespeed items first
            allHistory
                .filter(h => h && h.provider === 'wavespeed' && h.id)
                .forEach(item => {
                    wavespeedMap.set(item.id, item);
                });

            console.log(`Loaded ${wavespeedMap.size} Wavespeed videos from local cache.`);

            // 2. Fetch from Wavespeed API
            try {
                const WAVESPEED_API_BASE_URL = "https://api.wavespeed.ai/api/v3";
                console.log(`üì° Fetching history from: ${WAVESPEED_API_BASE_URL}/predictions (POST)`);

                const response = await fetch(`${WAVESPEED_API_BASE_URL}/predictions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey_ws}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        page: 1,
                        page_size: 50
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    let apiResults = [];

                    console.log('üì° API Response:', data); // Debug log

                    // Normalize API response structure
                    // Spec: { code: 200, data: { items: [ ... ], page: 1, ... } }
                    if (data.data && Array.isArray(data.data.items)) {
                        apiResults = data.data.items;
                    }
                    // Fallbacks for other possible structures
                    else if (data.data && Array.isArray(data.data)) {
                        apiResults = data.data;
                    } else if (Array.isArray(data)) {
                        apiResults = data;
                    } else if (data.items && Array.isArray(data.items)) {
                        apiResults = data.items;
                    }

                    console.log(`üì° Fetched ${apiResults.length} items from Wavespeed API`);

                    for (const apiItem of apiResults) {
                        const id = apiItem.id;
                        if (!id) continue;

                        const status = apiItem.status;

                        // Extract URL
                        let videoUrl = null;
                        if (apiItem.outputs && Array.isArray(apiItem.outputs) && apiItem.outputs.length > 0) {
                            videoUrl = apiItem.outputs[0];
                        } else if (apiItem.output && Array.isArray(apiItem.output) && apiItem.output.length > 0) {
                            videoUrl = apiItem.output[0];
                        } else if (typeof apiItem.output === 'string') {
                            videoUrl = apiItem.output;
                        }

                        // Extract Model Name
                        let modelName = 'unknown';
                        let outputType = 'video';  // Default to video

                        if (apiItem.model) {
                            if (typeof apiItem.model === 'string') {
                                modelName = apiItem.model;

                                // ========== ‚ú® NEW: Detect image-edit from model string (v2.4.2) ==========
                                if (modelName.includes('image-edit')) {
                                    outputType = 'image';
                                }
                                // ========== END: Image Edit Detection ==========
                            } else if (apiItem.model.name) {
                                modelName = apiItem.model.name;
                            }
                        }

                        // ‚ú® ‡∏•‡∏≠‡∏á‡∏î‡∏∂‡∏á input ‡∏à‡∏≤‡∏Å saved map ‡∏Å‡πà‡∏≠‡∏ô (workaround ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤)
                        const savedInput = getTaskInput(id);

                        // ========== ‚ú® NEW: Override outputType from savedInput if available (v2.4.2) ==========
                        if (savedInput?.outputType) {
                            outputType = savedInput.outputType;
                        }
                        // ========== END: outputType Override ==========

                        // ‚ú® NEW: ‡∏î‡∏∂‡∏á craftData ‡πÅ‡∏•‡∏∞ modelKey ‡∏à‡∏≤‡∏Å existing item ‡πÉ‡∏ô wavespeedMap (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
                        const existingItem = wavespeedMap.get(id);

                        // ========== ‚ú® IMPROVED: Smart Merge Strategy (v2.7.2) ==========
                        let historyItem;

                        if (existingItem) {
                            // Item exists in local history - use smart merge to preserve local data
                            historyItem = mergeHistoryItem(existingItem, apiItem);
                            console.log(`üîÑ Merged existing item ${id} (preserved local data)`);
                        } else {
                            // New item from API - create fresh entry
                            historyItem = {
                                id: id,
                                url: videoUrl || null,
                                // ‚ú® FIXED: Wavespeed API returns fields at top level, not under .input
                                prompt: savedInput?.prompt || apiItem.prompt || "No prompt available",
                                negativePrompt: savedInput?.negativePrompt || apiItem.negative_prompt || '',
                                model: savedInput?.model || modelName || 'unknown',
                                modelKey: savedInput?.modelKey || null,
                                outputType: outputType,
                                provider: 'wavespeed',
                                duration: savedInput?.duration || apiItem.duration || 0,
                                resolution: savedInput?.resolution || apiItem.resolution || 'N/A',
                                shotType: savedInput?.shotType || apiItem.shot_type || null,
                                promptExpansion: savedInput?.promptExpansion || apiItem.enable_prompt_expansion || false,
                                seed: savedInput?.seed || apiItem.seed || null,
                                sourceImage: savedInput?.sourceImage || apiItem.image || null,
                                createdAt: apiItem.created_at || new Date().toISOString(),
                                processingTime: apiItem.metrics?.predict_time || (apiItem.timings?.inference ? apiItem.timings.inference / 1000 : 0),
                                status: status,
                                craftData: savedInput?.craftData || null,
                                imageCounter: savedInput?.imageCounter || null
                            };
                            console.log(`‚ûï Added new item ${id} from API`);
                        }
                        // ========== END: Smart Merge ==========

                        wavespeedMap.set(id, historyItem);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è API Fetch failed: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error("‚ùå Error fetching Wavespeed history:", error);
                videoHistory.innerHTML += `<br><span class="text-red-400 text-xs">Error: ${error.message}</span>`;
            }

            // 3. Combine and Sort
            const newWavespeedHistory = Array.from(wavespeedMap.values());
            const finalHistory = [...otherProviderHistory, ...newWavespeedHistory];

            if (finalHistory.length === 0) {
                videoHistory.innerHTML = '<p class="text-sm text-gray-500 text-center py-8">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ (No History Found)</p>';
                videoHistoryData = [];
                localStorage.setItem('videoHistory', JSON.stringify([]));
                return;
            }

            // Sort by date (newest first)
            finalHistory.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

            // Update state with quota handling
            videoHistoryData = finalHistory.slice(0, 50); // Limit total history

            // ‚ú® NEW (v2.9.0): Handle localStorage quota errors with aggressive cleanup
            try {
                localStorage.setItem('videoHistory', JSON.stringify(videoHistoryData));
            } catch (e) {
                if (e.name === 'QuotaExceededError' || e.code === 22) {
                    console.warn('‚ö†Ô∏è localStorage quota exceeded during refresh - performing aggressive cleanup');

                    // üõ°Ô∏è v2.12.14: Protect Grok videos during quota cleanup
                    const grokVideos = finalHistory.filter(h => h.provider === 'grok' && h.status === 'completed');
                    const otherVideos = finalHistory.filter(h => h.provider !== 'grok');

                    // üî• v2.12.20: Strip redundant url from Gemini to reduce size
                    const otherVideosOptimized = otherVideos.map(item => {
                        if (item.provider === 'gemini' && item.outputType === 'image' && item.initialImage) {
                            const { url, ...itemWithoutUrl } = item;
                            return itemWithoutUrl;
                        }
                        return item;
                    });

                    const reducedHistory = [...grokVideos, ...otherVideosOptimized.slice(0, 10)];
                    videoHistoryData = reducedHistory;

                    try {
                        localStorage.setItem('videoHistory', JSON.stringify(reducedHistory));
                        console.log(`üõ°Ô∏è Protected ${grokVideos.length} Grok videos, kept ${otherVideosOptimized.slice(0, 10).length} others`);
                    } catch (e2) {
                        // üö® v2.12.20: NEVER clear entirely - remove Gemini instead
                        console.warn('‚ö†Ô∏è Still quota error - removing ALL Gemini images to preserve Grok videos');

                        const grokOnly = reducedHistory.filter(h => h.provider === 'grok');
                        const wavespeedOnly = reducedHistory.filter(h => h.provider === 'wavespeed').slice(0, 5);
                        const finalReduced = [...grokOnly, ...wavespeedOnly];

                        videoHistoryData = finalReduced;

                        try {
                            localStorage.setItem('videoHistory', JSON.stringify(finalReduced));
                            console.log(`üõ°Ô∏è EMERGENCY: Kept ${grokOnly.length} Grok + ${wavespeedOnly.length} Wavespeed (removed all Gemini)`);
                        } catch (e3) {
                            // Last resort: keep only Grok
                            videoHistoryData = grokOnly;
                            localStorage.setItem('videoHistory', JSON.stringify(grokOnly));
                            console.error('üö® CRITICAL: Kept only Grok videos, removed everything else');
                        }
                    }
                } else {
                    console.error('‚ùå localStorage error:', e);
                }
            }

            // Render
            renderVideoHistory();
            console.log(`‚úÖ History refresh complete. Total: ${videoHistoryData.length} (WS: ${newWavespeedHistory.length}, Gemini: ${geminiHistory.length})`);
        }

        function saveToHistory() {
            if (!currentVideoData || !currentVideoData.id) return; // Need ID to save

            // ========== ‚ú® NEW: Update placeholder instead of adding new video ==========
            // Check if video exists (including placeholder)
            const existingIndex = videoHistoryData.findIndex(v => v.id === currentVideoData.id && v.provider === currentVideoData.provider);

            if (existingIndex !== -1) {
                // Update existing placeholder with completed video data
                videoHistoryData[existingIndex] = {
                    ...videoHistoryData[existingIndex],
                    ...currentVideoData,
                    status: 'completed' // Mark as completed
                };
                console.log('‚ú® Updated placeholder with completed video:', currentVideoData.id);

                // Save to localStorage
                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                // Re-render history to show real video thumbnail
                renderVideoHistory();

                console.log(`‚úÖ Updated history (${videoHistoryData.length}/${STORAGE_LIMITS.VIDEO_HISTORY_MAX})`);
            } else {
                // Fallback: Video not found, add new entry (shouldn't happen with placeholder system)
                videoHistoryData.unshift(currentVideoData);
                videoHistoryData = videoHistoryData.slice(0, STORAGE_LIMITS.VIDEO_HISTORY_MAX);

                safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                // ‚ú® v2.8.14: Always call renderVideoHistory() to ensure UI updates
                renderVideoHistory();

                console.log(`‚úÖ Added new to history (${videoHistoryData.length}/${STORAGE_LIMITS.VIDEO_HISTORY_MAX})`);
            }
            // ========== END: Update Placeholder ==========
        }

        /**
         * Prepend newly generated video to history with shimmer effect
         * @param {Object} video - Video data object
         * @param {number} index - Index in videoHistoryData (0 = newest)
         */
        async function prependNewVideoToHistory(video, index) {
            if (!video || typeof video !== 'object') return;

            // Check if grid container exists, if not create it
            let gridContainer = videoHistory.querySelector('.grid');
            if (!gridContainer) {
                videoHistory.innerHTML = '<div class="grid grid-cols-1 gap-3"></div>';
                gridContainer = videoHistory.querySelector('.grid');
            }

            // Build video item HTML
            const provider = video.provider || 'wavespeed';
            const modelDisplay = video.model || 'unknown';
            const durationDisplay = video.duration ? `${video.duration}s` : '?s';
            const resolutionDisplay = video.resolution || 'N/A';
            const promptDisplay = video.prompt || 'No prompt available';

            // Preload video to cache if possible
            try {
                if (video.id && video.url && video.provider) {
                    await preloadVideoToCache(video.id, video.url, video.provider);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to preload new video to cache:', error.message);
            }

            // Try to get cached URL
            const cachedUrl = await getCachedVideo(video.id);
            const videoUrl = cachedUrl || video.url;
            const canPlay = !!videoUrl;

            const videoItemHTML = `
                <div class="video-thumbnail rounded-xl overflow-hidden just-added slide-in ${canPlay ? 'cursor-pointer' : 'opacity-60 pointer-events-none'}" data-index="${index}" ${canPlay ? `onclick="openVideoModalSafe(${index})"` : 'title="Video URL missing"'}>
                    <div class="relative bg-black aspect-video overflow-hidden">
                        ${canPlay ? `
                            <video
                                class="w-full h-full object-contain bg-black"
                                src="${videoUrl}"
                                preload="metadata"
                                muted
                                playsinline
                                loop
                                onerror="console.error('Video load error:', '${video.id}', this.error); this.style.display='none'; this.parentElement.querySelector('.placeholder-icon').style.display='flex';"
                            ></video>
                            <div class="placeholder-icon absolute inset-0 flex items-center justify-center bg-gray-900" style="display: none;">
                                <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                <p class="text-xs text-gray-500 mt-2">Failed to load</p>
                            </div>
                            <div class="absolute inset-0 flex items-center justify-center bg-black/30 hover:bg-black/10 transition-all group">
                                <!-- Download Button -->
                                <button
                                    onclick="event.stopPropagation(); downloadVideoFromHistory(${index})"
                                    class="absolute top-1 left-1 w-8 h-8 bg-gradient-to-br from-purple-500/90 to-cyan-500/90 hover:from-purple-400 hover:to-cyan-400 border border-purple-300/50 hover:border-cyan-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-purple-500/50 hover:scale-110"
                                    title="Download Video"
                                    style="backdrop-filter: blur(10px);">
                                    <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                    </svg>
                                </button>

                                <!-- Re-use Button -->
                                <button
                                    onclick="event.stopPropagation(); reuseVideoParameters(${escapeHtml(JSON.stringify(video))})"
                                    class="absolute bottom-1 left-1 w-8 h-8 bg-gradient-to-br from-cyan-500/90 to-green-500/90 hover:from-cyan-400 hover:to-green-400 border border-cyan-300/50 hover:border-green-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-cyan-500/50 hover:scale-110"
                                    title="Re-use Parameters"
                                    style="backdrop-filter: blur(10px);">
                                    <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                </button>

                                <svg class="w-12 h-12 text-cyan-400 opacity-0 group-hover:opacity-90 transition-opacity drop-shadow-lg" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/>
                                </svg>
                            </div>
                        ` : `
                            <div class="absolute inset-0 flex items-center justify-center bg-gray-900">
                                <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                <span class="absolute bottom-2 text-xs text-red-400">Missing URL</span>
                            </div>
                        `}
                    </div>
                    <div class="p-3 bg-[#131320]/80">
                        <p class="text-xs font-medium text-gray-300 truncate mb-1" title="${promptDisplay}">${promptDisplay}</p>
                        <div class="flex justify-between text-xs text-gray-500">
                            <span class="truncate text-cyan-400" title="${modelDisplay}">${modelDisplay}</span>
                            <span class="whitespace-nowrap ml-2 text-purple-400">${durationDisplay}‚Ä¢${resolutionDisplay}</span>
                        </div>
                    </div>
                </div>
            `;

            // Create element and prepend
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = videoItemHTML;
            const newVideoElement = tempDiv.firstElementChild;

            // Prepend to grid (top of list)
            gridContainer.insertBefore(newVideoElement, gridContainer.firstChild);

            // Remove animation classes after animation completes
            setTimeout(() => {
                newVideoElement.classList.remove('just-added', 'slide-in');
            }, 2500); // 2.5s (2s shimmer + 0.5s slide-in)

            console.log('‚ú® New video prepended with shimmer effect');
        }

        function clearHistory() {
            if (!confirm('‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?\n\n(‡∏à‡∏∞‡∏•‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡πÅ‡∏Ñ‡∏ä‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û I2V)')) {
                return;
            }

            try {
                // Clear video history
                videoHistoryData = [];
                localStorage.removeItem('videoHistory');

                // Clear image cache
                localStorage.removeItem(IMAGE_CACHE_KEY);

                // Re-render empty history
                renderVideoHistory();

                console.log('‚úÖ History and cache cleared successfully');
                alert('‚úÖ ‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
            } catch (error) {
                console.error('‚ùå Error clearing history:', error);
                alert('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥');
            }
        }

        // ========== üóëÔ∏è Delete Individual History Item ==========
        /**
         * Delete history item both locally and from Wavespeed server
         * @param {string} videoId - Prediction ID for API deletion
         * @param {number} itemIndex - Array index (may be -1 for processing items, not used for finding)
         */
        async function deleteHistoryItem(videoId, itemIndex) {
            console.log(`üóëÔ∏è Attempting to delete item: ${videoId}`);

            // === STEP 1: Find item in array (more reliable than using index) ===
            const itemToDelete = videoHistoryData.find(v => v.id === videoId);
            if (!itemToDelete) {
                console.error('‚ùå Item not found in history:', videoId);
                await alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ');
                return;
            }

            // === STEP 2: Confirmation Dialog (v2.8.10: Simplified) ===
            if (!await confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ?')) {
                console.log('üö´ Deletion cancelled by user');
                return;
            }

            // === STEP 3: Get API Key ===
            const apiKey = getWavespeedApiKey();
            if (!apiKey) {
                console.warn('‚ö†Ô∏è No API key found - will delete locally only');
            }

            // === STEP 4: API Deletion (if API key exists) ===
            let apiDeleteSuccess = false;
            let apiDeleteError = null;

            if (apiKey && itemToDelete.provider === 'wavespeed') {
                try {
                    console.log('üì° Calling Wavespeed DELETE API...');

                    const response = await fetch('https://api.wavespeed.ai/api/v3/predictions/delete', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            ids: [videoId]
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API returned ${response.status}: ${response.statusText}`);
                    }

                    const result = await response.json();
                    console.log('üì° API Response:', result);

                    // Check if deletion was successful
                    if (result.code === 200 && result.data?.deleted_count > 0) {
                        apiDeleteSuccess = true;
                        console.log('‚úÖ Server deletion successful');
                    } else if (result.data?.deleted_count === 0) {
                        // Item doesn't exist on server (already deleted or never uploaded)
                        console.warn('‚ö†Ô∏è Item not found on server (may have been deleted already)');
                        apiDeleteSuccess = true; // Treat as success for local deletion
                    } else {
                        throw new Error(`Unexpected response: ${JSON.stringify(result)}`);
                    }

                } catch (error) {
                    console.error('‚ùå API deletion failed:', error);
                    apiDeleteError = error.message;

                    // Ask user if they want to continue with local deletion (v2.8.10: Simplified)
                    const continueLocal = await confirm('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏à‡∏≤‡∏Å Server ‡πÑ‡∏î‡πâ\n‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏à‡∏≤‡∏Å Local ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô?');

                    if (!continueLocal) {
                        console.log('üö´ User cancelled after API failure');
                        return;
                    }
                }
            }

            // === STEP 5: Local Deletion ===
            try {
                console.log('üíæ Deleting from local storage...');

                // Find actual index (may have changed since button was rendered)
                const actualIndex = videoHistoryData.findIndex(v => v.id === videoId);

                if (actualIndex === -1) {
                    throw new Error('Item no longer exists in local array');
                }

                // Remove from array
                videoHistoryData.splice(actualIndex, 1);

                // Save to localStorage
                const saveSuccess = safeSetLocalStorage('videoHistory', JSON.stringify(videoHistoryData));

                if (!saveSuccess) {
                    throw new Error('Failed to save updated history to localStorage');
                }

                console.log(`‚úÖ Local deletion successful (${videoHistoryData.length} items remaining)`);

            } catch (error) {
                console.error('‚ùå Local deletion failed:', error);
                await alert(`‡∏•‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${error.message}`);
                return;
            }

            // === STEP 6: Clean up related caches ===
            try {
                // Remove from image cache (if this was an I2V item)
                if (itemToDelete.initialImage) {
                    const imageCache = JSON.parse(localStorage.getItem(IMAGE_CACHE_KEY) || '{}');
                    if (imageCache[videoId]) {
                        delete imageCache[videoId];
                        safeSetLocalStorage(IMAGE_CACHE_KEY, JSON.stringify(imageCache));
                        console.log('üñºÔ∏è Removed from image cache');
                    }
                }

                // Remove from task input persistence
                const taskInputs = JSON.parse(localStorage.getItem(TASK_INPUT_STORAGE_KEY) || '{}');
                if (taskInputs[videoId]) {
                    delete taskInputs[videoId];
                    safeSetLocalStorage(TASK_INPUT_STORAGE_KEY, JSON.stringify(taskInputs));
                    console.log('üìù Removed from task inputs');
                }

            } catch (cacheError) {
                console.warn('‚ö†Ô∏è Cache cleanup failed (non-critical):', cacheError);
            }

            // === STEP 7: Re-render History ===
            await renderVideoHistory();

            // === STEP 8: Success Feedback (v2.8.10: Silent success, no alert) ===
            console.log('üéâ Deletion completed successfully');
            if (apiDeleteSuccess) {
                console.log('‚úÖ Removed from server and local history');
            } else if (!apiKey) {
                console.log('‚úÖ Removed from local history (no API key)');
            } else if (apiDeleteError) {
                console.log('‚ö†Ô∏è Removed from local history (server deletion failed)');
            }
        }

        // Make function globally accessible
        window.deleteHistoryItem = deleteHistoryItem;

        // ========== ‚ú® NEW: History Filter System (v2.4.2) ==========
        // Filter modes: 'all' (both), 'video' (videos only), 'image' (images only)
        let historyFilterMode = 'all';
        const HISTORY_FILTER_KEY = 'historyFilterMode';

        // Load filter mode from localStorage
        function loadHistoryFilter() {
            const saved = localStorage.getItem(HISTORY_FILTER_KEY);
            historyFilterMode = saved || 'all';
            console.log('üìÇ Loaded history filter:', historyFilterMode);
            return historyFilterMode;
        }

        // Save filter mode to localStorage
        function saveHistoryFilter(mode) {
            localStorage.setItem(HISTORY_FILTER_KEY, mode);
            historyFilterMode = mode;
            console.log('üíæ Saved history filter:', mode);
        }

        // Cycle through filter modes: all ‚Üí video ‚Üí image ‚Üí all
        function cycleHistoryFilter() {
            const modes = ['all', 'video', 'image'];
            const currentIndex = modes.indexOf(historyFilterMode);
            const nextIndex = (currentIndex + 1) % modes.length;
            const newMode = modes[nextIndex];

            // Save new mode
            saveHistoryFilter(newMode);

            // Update UI
            updateHistoryFilterUI();

            // Re-render history with new filter
            renderVideoHistory();

            console.log('üîÑ Filter cycled:', historyFilterMode);
        }

        // Update filter icon color and description text
        function updateHistoryFilterUI() {
            const filterIcon = document.getElementById('history-filter-icon');
            const descriptionText = document.getElementById('history-filter-description');

            if (!filterIcon || !descriptionText) return;

            // Update icon color based on mode
            if (historyFilterMode === 'all') {
                filterIcon.classList.remove('text-purple-400', 'text-cyan-400');
                filterIcon.classList.add('text-cyan-400'); // Default cyan
                descriptionText.textContent = 'All videos and images';
            } else if (historyFilterMode === 'video') {
                filterIcon.classList.remove('text-cyan-400', 'text-purple-400');
                filterIcon.classList.add('text-purple-400'); // Purple for video
                descriptionText.textContent = 'Videos only';
            } else if (historyFilterMode === 'image') {
                filterIcon.classList.remove('text-cyan-400', 'text-purple-400');
                filterIcon.classList.add('text-cyan-400'); // Cyan for image
                descriptionText.textContent = 'Images only';
            }
        }

        // Get filtered history based on current filter mode
        function getFilteredHistory() {
            if (historyFilterMode === 'all') {
                return videoHistoryData; // Return all
            } else if (historyFilterMode === 'video') {
                // Filter only videos (has url and NOT an image)
                // Always show placeholders (processing animations)
                return videoHistoryData.filter(item => {
                    // ‚úÖ FIX v2.4.7: Check processing status to show animations during processing
                    const status = (item.status || '').toLowerCase();
                    const isProcessing = status &&
                        status !== 'completed' &&
                        status !== 'succeeded' &&
                        status !== 'failed' &&
                        status !== 'canceled';

                    return isProcessing ||  // Show all processing videos/images (animations visible)
                           item.isPlaceholder === true ||  // Show placeholders before ID assigned
                           (item.url && item.outputType !== 'image');  // Show completed videos only
                });
            } else if (historyFilterMode === 'image') {
                // Filter only images (marked as image output)
                // Always show placeholders (processing animations)
                return videoHistoryData.filter(item => {
                    // ‚úÖ FIX v2.4.7: Same fix for image filter
                    const status = (item.status || '').toLowerCase();
                    const isProcessing = status &&
                        status !== 'completed' &&
                        status !== 'succeeded' &&
                        status !== 'failed' &&
                        status !== 'canceled';

                    return isProcessing ||  // Show all processing videos/images (animations visible)
                           item.isPlaceholder === true ||  // Show placeholders before ID assigned
                           item.outputType === 'image';  // Show completed images only
                });
            }
            return videoHistoryData; // Fallback
        }

        // Initialize filter on page load
        function initHistoryFilter() {
            loadHistoryFilter();
            updateHistoryFilterUI();
            console.log('‚úÖ History filter initialized:', historyFilterMode);
        }
        // ========== END: History Filter System ==========

        // Toggle history visibility
        function toggleHistoryVisibility() {
            const historyContainer = document.getElementById('video-history');
            const iconVisible = document.getElementById('history-icon-visible');
            const iconHidden = document.getElementById('history-icon-hidden');

            // Get current state from localStorage (default: true/visible)
            const isVisible = localStorage.getItem('history_visible') !== 'false';

            // Toggle state
            const newState = !isVisible;
            localStorage.setItem('history_visible', newState);

            // Update UI
            if (newState) {
                // Show history
                historyContainer.classList.remove('hidden');
                iconVisible.classList.remove('hidden');
                iconHidden.classList.add('hidden');
            } else {
                // Hide history
                historyContainer.classList.add('hidden');
                iconVisible.classList.add('hidden');
                iconHidden.classList.remove('hidden');
            }

            console.log('History visibility toggled:', newState ? 'visible' : 'hidden');
        }

        // Initialize history visibility on page load
        function initHistoryVisibility() {
            const historyContainer = document.getElementById('video-history');
            const iconVisible = document.getElementById('history-icon-visible');
            const iconHidden = document.getElementById('history-icon-hidden');

            // Get saved state (default: true/visible)
            const isVisible = localStorage.getItem('history_visible') !== 'false';

            console.log('üìä Init History Visibility:', {
                isVisible,
                savedState: localStorage.getItem('history_visible'),
                historyContainer: historyContainer,
                hasVideos: videoHistoryData.length
            });

            // Apply state
            if (!isVisible) {
                historyContainer.classList.add('hidden');
                iconVisible.classList.add('hidden');
                iconHidden.classList.remove('hidden');
                console.log('üôà History is hidden by user preference');
            } else {
                console.log('üëÅÔ∏è History is visible');
            }
        }

        /**
         * Toggle between grid and list view for video history
         */
        function toggleGridView() {
            // Get current mode (default: list)
            const currentMode = localStorage.getItem('history_view_mode') || 'list';

            // Toggle mode
            const newMode = currentMode === 'list' ? 'grid' : 'list';

            // Save to localStorage
            localStorage.setItem('history_view_mode', newMode);

            // Update icons
            updateGridIcons(newMode);

            // Re-render history with new layout
            renderVideoHistory();

            console.log(`üìä View mode changed: ${currentMode} ‚Üí ${newMode}`);
        }

        /**
         * Update grid/list icon visibility based on current mode
         */
        function updateGridIcons(mode) {
            const gridIcon = document.getElementById('grid-icon');
            const listIcon = document.getElementById('list-icon');

            if (mode === 'grid') {
                // In grid mode: show list icon (to switch back to list)
                gridIcon.classList.add('hidden');
                listIcon.classList.remove('hidden');
            } else {
                // In list mode: show grid icon (to switch to grid)
                gridIcon.classList.remove('hidden');
                listIcon.classList.add('hidden');
            }
        }

        /**
         * Initialize grid view mode on page load
         */
        function initGridView() {
            const mode = localStorage.getItem('history_view_mode') || 'list';
            updateGridIcons(mode);
        }

        // ========== START: ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ (‡πÄ‡∏û‡∏¥‡πà‡∏° Fallbacks ‡πÅ‡∏•‡∏∞ Error Handling) ==========
        async function renderVideoHistory() {
            // ========== ‚ú® NEW: Increment FIRST to track all calls (Race Condition Fix) ==========
            const currentRenderingId = ++renderingId;
            console.log(`üé¨ Starting render #${currentRenderingId}`);
            // ========== END: Rendering ID ==========

            // ‚ú® NEW: Get filtered history based on current filter mode
            const filteredData = getFilteredHistory();

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ filteredData ‡πÄ‡∏õ‡πá‡∏ô array ‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á
            if (!Array.isArray(filteredData) || filteredData.length === 0) {
                // Show different message based on filter mode
                let emptyMessage = '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏¢!';
                if (historyFilterMode === 'video') {
                    emptyMessage = 'No videos in history';
                } else if (historyFilterMode === 'image') {
                    emptyMessage = 'No images in history';
                }
                videoHistory.innerHTML = `<p class="text-sm text-gray-500 text-center py-8">${emptyMessage}</p>`;
                console.log(`‚úÖ Render #${currentRenderingId} completed (empty state)`);
                return;
            }

            // ‡πÅ‡∏™‡∏î‡∏á loading message
            videoHistory.innerHTML = '<p class="text-sm text-cyan-400 text-center py-8">‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠...</p>';

            // ========== Pre-load videos to cache ==========
            console.log('üîÑ Pre-loading videos to cache...');
            const preloadPromises = filteredData
                .filter(video => video && video.id && video.url && video.provider)
                .map(async (video) => {
                    try {
                        await preloadVideoToCache(video.id, video.url, video.provider);
                    } catch (error) {
                        console.error('‚ö†Ô∏è Pre-load failed for:', video.id, error.message);
                    }
                });

            // ‡∏£‡∏≠‡πÉ‡∏´‡πâ pre-load ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏´‡∏£‡∏∑‡∏≠ timeout 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
            await Promise.race([
                Promise.all(preloadPromises),
                new Promise(resolve => setTimeout(resolve, 10000))
            ]);
            console.log('‚úÖ Pre-loading completed');

            // ========== ‚ú® CHECKPOINT 1 - Cancel if newer render started (Race Condition Fix) ==========
            if (currentRenderingId !== renderingId) {
                console.log(`üö´ Render #${currentRenderingId} cancelled after pre-load (current: #${renderingId})`);
                return; // Exit early, don't update state or DOM
            }
            console.log(`‚úÖ Render #${currentRenderingId} still current after pre-load`);
            // ========== END: CHECKPOINT 1 ==========

            // ========== Separate processing and completed videos ==========
            const processingVideos = filteredData.filter(v => {
                const status = (v.status || '').toLowerCase();
                return status && status !== 'completed' && status !== 'succeeded' && status !== 'failed' && status !== 'canceled';
            });

            const completedVideos = filteredData.filter(v => {
                const status = (v.status || '').toLowerCase();
                return !status || status === 'completed' || status === 'succeeded' || status === 'failed' || status === 'canceled';
            });

            console.log(`üìä Video counts: ${processingVideos.length} processing, ${completedVideos.length} completed`);

            // ========== Update global completed videos array for modal index mapping ==========
            completedVideosData = completedVideos;

            // ========== Render history with cached URLs ==========
            // Get all cached URLs first (sync after pre-load)
            const cachedUrls = new Map();
            for (const video of completedVideos) {
                if (video && video.id) {
                    const cached = await getCachedVideo(video.id);
                    if (cached) {
                        cachedUrls.set(video.id, cached);
                    }
                }
            }

            // ========== ‚ú® CHECKPOINT 2 - Cancel before DOM update (Race Condition Fix) ==========
            if (currentRenderingId !== renderingId) {
                console.log(`üö´ Render #${currentRenderingId} cancelled before DOM update (current: #${renderingId})`);
                return; // Exit early, don't render DOM
            }
            console.log(`‚úÖ Render #${currentRenderingId} proceeding to DOM update`);
            // ========== END: CHECKPOINT 2 ==========

            // Get current view mode and set grid class accordingly
            const viewMode = localStorage.getItem('history_view_mode') || 'list';
            const gridClass = viewMode === 'grid' ? 'grid-cols-2' : 'grid-cols-1';

            videoHistory.innerHTML = `
                <div class="grid ${gridClass} gap-3">
                    ${processingVideos.length > 0 ? `
                        <!-- Processing Videos Section -->
                        <div class="border-b border-cyan-500/20 pb-3 mb-3">
                            <p class="text-xs text-cyan-400 mb-2 uppercase tracking-wide">‚è≥ Processing (${processingVideos.length})</p>
                            ${processingVideos.map((video) => {
                const provider = video.provider || 'wavespeed';
                const modelDisplay = video.model || 'unknown';
                const promptDisplay = (video.prompt || 'Processing...').substring(0, 150); // ‚ú® Increased from 100 to 150
                const promptFullText = video.prompt || 'Processing...'; // ‚ú® Full prompt for tooltip
                const statusDisplay = (video.status || 'processing').toUpperCase();

                // ========== ‚ú® NEW: Calculate processing time for recovery buttons ==========
                const createdTime = video.createdAt ? new Date(video.createdAt) : new Date();
                const elapsedMinutes = (Date.now() - createdTime.getTime()) / (1000 * 60);
                const showCheckStatus = elapsedMinutes > 5; // Show after 5 minutes
                const showMarkFailed = elapsedMinutes > 30; // Show after 30 minutes
                // ========== END: Time calculation ==========

                return `
                                    <div class="video-thumbnail rounded-xl overflow-hidden opacity-60 mb-3" title="Video is still processing">
                                        <div class="relative bg-gray-900 aspect-video overflow-hidden group">
                                            <!-- Initial Image Layer (if available) -->
                                            ${video.initialImage ? `
                                                <img src="${video.initialImage}"
                                                     alt="Initial frame"
                                                     class="absolute inset-0 w-full h-full object-cover">
                                            ` : `
                                                <!-- Fallback: Gradient background if no image -->
                                                <div class="absolute inset-0 bg-gradient-to-br from-gray-800 to-gray-900"></div>
                                            `}

                                            <!-- Hologram Effect Overlay -->
                                            <div class="absolute inset-0 hologram-overlay"></div>

                                            <!-- Spinner + Text Overlay -->
                                            <div class="absolute inset-0 flex flex-col items-center justify-center">
                                                <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-cyan-500 mb-3 drop-shadow-[0_0_10px_rgba(6,182,212,0.8)]"></div>
                                                <p class="text-cyan-400 text-sm font-semibold drop-shadow-[0_2px_8px_rgba(0,0,0,0.9)]">${statusDisplay}</p>
                                                <p class="text-gray-300 text-xs mt-1 drop-shadow-[0_2px_8px_rgba(0,0,0,0.9)]">Please wait... (${Math.round(elapsedMinutes)}m)</p>
                                            </div>

                                            <!-- ========== ‚ú® NEW: Recovery Buttons ========== -->
                                            ${showCheckStatus ? `
                                                <button
                                                    onclick="checkVideoStatus('${video.id}')"
                                                    class="absolute top-2 right-2 px-3 py-1 bg-cyan-500/90 hover:bg-cyan-400 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-all cursor-pointer z-20 shadow-lg"
                                                    title="Manually check status">
                                                    üîÑ Check Status
                                                </button>
                                            ` : ''}
                                            ${showMarkFailed ? `
                                                <button
                                                    onclick="markVideoAsFailed('${video.id}')"
                                                    class="absolute bottom-2 right-2 px-3 py-1 bg-red-500/90 hover:bg-red-400 text-white text-xs rounded-lg opacity-0 group-hover:opacity-100 transition-all cursor-pointer z-20 shadow-lg"
                                                    title="Mark as failed">
                                                    ‚ùå Mark Failed
                                                </button>
                                            ` : ''}
                                            <!-- ========== END: Recovery Buttons ========== -->

                                            <!-- v2.8.11: Delete button removed - processing cards are non-interactive -->

                                        </div>
                                        <div class="p-3 bg-gray-900/50 border-t border-cyan-500/20">
                                            <p class="text-xs text-gray-400 line-clamp-2" title="${promptFullText}">${promptDisplay}...</p>
                                            <div class="flex items-center justify-between mt-2">
                                                <span class="text-xs text-cyan-400">${modelDisplay}</span>
                                                <span class="text-xs text-gray-500 status-${video.status || 'processing'}">${statusDisplay}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
            }).join('')}
                        </div>
                    ` : ''}

                    <!-- Completed Videos Section -->
                    ${completedVideos.map((video, index) => {
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô
                if (!video || typeof video !== 'object') return '';

                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ Fallback
                const provider = video.provider || 'wavespeed';
                const modelDisplay = video.model || 'unknown';
                const durationDisplay = video.duration ? `${video.duration}s` : '?s';
                const resolutionDisplay = video.resolution || 'N/A';
                const promptDisplay = video.prompt || 'No prompt available';

                // **‡πÉ‡∏ä‡πâ cached URL ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ, ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ original URL**
                const cachedUrl = cachedUrls.get(video.id);

                // ========== ‚ú® NEW: Check if this is an image (v2.4.2) ==========
                const isImage = video.outputType === 'image' ||
                    video.modelKey === 'ws-wan-26-image-edit';
                // ========== END: Image Detection ==========

                // üöÄ v2.12.21: For Gemini, prefer imgbb URL (permanent), fallback to base64
                // For images: prefer imgbbUrl (permanent) > url > initialImage (base64)
                // For videos: prefer cachedUrl or video.url
                const videoUrl = isImage
                    ? (video.imgbbUrl || video.url || video.initialImage || cachedUrl)
                    : (cachedUrl || video.url);

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ URL ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                const canPlay = !!videoUrl;

                // ========== ‚ú® NEW: Render image card (v2.4.2) ==========
                if (isImage) {
                    return `
                            <div class="video-thumbnail image-thumbnail rounded-xl overflow-hidden border-2 border-pink-400/40 ${canPlay ? 'cursor-pointer' : 'opacity-60 pointer-events-none'}" data-index="${index}" ${canPlay ? `onclick="openHistoryImageModalSafe('${escapeHtml(videoUrl)}', ${index})"` : 'title="Image URL missing"'}>
                                <div class="relative bg-black aspect-video overflow-hidden">
                                    ${canPlay ? `
                                        <img
                                            src="${videoUrl}"
                                            alt="${escapeHtml(promptDisplay.substring(0, 50))}"
                                            class="w-full h-full object-cover"
                                            onerror="this.style.display='none'; this.parentElement.querySelector('.placeholder-icon').style.display='flex';">
                                        <div class="placeholder-icon absolute inset-0 flex items-center justify-center bg-gray-900" style="display: none;">
                                            <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                                            <p class="text-xs text-gray-500 mt-2">Failed to load</p>
                                        </div>
                                        <!-- Hover overlay with action buttons (same style as video) -->
                                        <div class="absolute inset-0 flex items-center justify-center bg-black/30 hover:bg-black/10 transition-all group">
                                            <!-- Download Button (top-left) -->
                                            <button
                                                onclick="event.stopPropagation(); downloadImage('${videoUrl}', '${video.id}', ${video.imageCounter || 'null'})"
                                                class="action-button absolute top-1 left-1 w-8 h-8 bg-gradient-to-br from-purple-500/90 to-cyan-500/90 hover:from-purple-400 hover:to-cyan-400 border border-purple-300/50 hover:border-cyan-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-purple-500/50 hover:scale-110"
                                                title="Download Image"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                                </svg>
                                            </button>
                                            <!-- Reuse Button (bottom-left) -->
                                            <button
                                                onclick="event.stopPropagation(); reuseVideoParameters(${escapeHtml(JSON.stringify(video))})"
                                                class="action-button absolute bottom-1 left-1 w-8 h-8 bg-gradient-to-br from-cyan-500/90 to-green-500/90 hover:from-cyan-400 hover:to-green-400 border border-cyan-300/50 hover:border-green-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-cyan-500/50 hover:scale-110"
                                                title="Re-use Parameters"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                                </svg>
                                            </button>
                                            <!-- Delete Button (bottom-right) -->
                                            <button
                                                onclick="event.stopPropagation(); deleteHistoryItem('${video.id}', ${index})"
                                                class="action-button absolute bottom-1 right-1 w-8 h-8 bg-gradient-to-br from-red-500/90 to-pink-500/90 hover:from-red-400 hover:to-pink-400 border border-red-300/50 hover:border-pink-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-red-500/50 hover:scale-110"
                                                title="Delete Image Permanently"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                                </svg>
                                            </button>
                                            <!-- Center image icon on hover -->
                                            <svg class="w-12 h-12 text-pink-400 opacity-0 group-hover:opacity-90 transition-opacity drop-shadow-lg" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>
                                            </svg>
                                        </div>
                                    ` : `
                                        <div class="absolute inset-0 flex items-center justify-center bg-gray-900">
                                            <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                                            <p class="text-xs text-gray-500 mt-2">Failed to load</p>
                                        </div>
                                    `}
                                </div>
                                <div class="p-3 bg-[#131320]/80">
                                    <p class="text-xs font-medium text-gray-300 truncate mb-1" title="${escapeHtml(promptDisplay)}">${escapeHtml(promptDisplay)}</p>
                                    <div class="flex justify-between text-xs text-gray-500">
                                        <span class="truncate text-cyan-400" title="${modelDisplay}">üì∑ ${modelDisplay}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                }
                // ========== END: Image Card Rendering ==========

                // ========== Existing: Video Card Rendering ==========
                return `
                            <div class="video-thumbnail rounded-xl overflow-hidden border-2 border-cyan-500/30 ${canPlay ? 'cursor-pointer' : 'opacity-60 pointer-events-none'}" data-index="${index}" ${canPlay ? `onclick="openVideoModalSafe(${index})"` : 'title="Video URL missing"'}>
                                <div class="relative bg-black aspect-video overflow-hidden">
                                    ${canPlay ? `
                                        <video
                                            class="w-full h-full object-contain bg-black"
                                            src="${videoUrl}"
                                            preload="metadata"
                                            muted
                                            playsinline
                                            loop
                                            onerror="console.error('Video load error:', '${video.id}', this.error); this.style.display='none'; this.parentElement.querySelector('.placeholder-icon').style.display='flex';"
                                        ></video>
                                        <div class="placeholder-icon absolute inset-0 flex items-center justify-center bg-gray-900" style="display: none;">
                                            <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                            <p class="text-xs text-gray-500 mt-2">Failed to load</p>
                                        </div>
                                        <div class="absolute inset-0 flex items-center justify-center bg-black/30 hover:bg-black/10 transition-all group">
                                            <!-- Download Button -->
                                            <button
                                                onclick="event.stopPropagation(); downloadVideoFromHistory(${index})"
                                                class="action-button absolute top-1 left-1 w-8 h-8 bg-gradient-to-br from-purple-500/90 to-cyan-500/90 hover:from-purple-400 hover:to-cyan-400 border border-purple-300/50 hover:border-cyan-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-purple-500/50 hover:scale-110"
                                                title="Download Video"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                                                </svg>
                                            </button>

                                            <!-- Re-use Button -->
                                            <button
                                                onclick="event.stopPropagation(); reuseVideoParameters(${escapeHtml(JSON.stringify(video))})"
                                                class="action-button absolute bottom-1 left-1 w-8 h-8 bg-gradient-to-br from-cyan-500/90 to-green-500/90 hover:from-cyan-400 hover:to-green-400 border border-cyan-300/50 hover:border-green-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-cyan-500/50 hover:scale-110"
                                                title="Re-use Parameters"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                                </svg>
                                            </button>

                                            <!-- ========== ‚ú® NEW: Retry Button (only for failed videos) ========== -->
                                            ${video.status === 'failed' || video.status === 'canceled' ? `
                                                <button
                                                    onclick="event.stopPropagation(); retryFailedVideo('${video.id}')"
                                                    class="action-button absolute top-1 right-1 px-2 py-1 bg-gradient-to-br from-orange-500/90 to-red-500/90 hover:from-orange-400 hover:to-red-400 border border-orange-300/50 hover:border-red-300 rounded-lg flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-orange-500/50 hover:scale-110"
                                                    title="Retry with same parameters"
                                                    style="backdrop-filter: blur(10px);">
                                                    <svg class="w-3 h-3 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                                    </svg>
                                                    <span class="text-[10px] font-semibold text-white">RETRY</span>
                                                </button>
                                            ` : ''}
                                            <!-- ========== END: Retry Button ========== -->

                                            <!-- Delete Button (bottom-right) -->
                                            <button
                                                onclick="event.stopPropagation(); deleteHistoryItem('${video.id}', ${index})"
                                                class="action-button absolute bottom-1 right-1 w-8 h-8 bg-gradient-to-br from-red-500/90 to-pink-500/90 hover:from-red-400 hover:to-pink-400 border border-red-300/50 hover:border-pink-300 rounded-lg flex items-center justify-center opacity-0 group-hover:opacity-100 transition-all duration-300 z-20 cursor-pointer shadow-lg hover:shadow-red-500/50 hover:scale-110"
                                                title="Delete Video Permanently"
                                                style="backdrop-filter: blur(10px);">
                                                <svg class="w-4 h-4 text-white drop-shadow-[0_0_3px_rgba(255,255,255,0.8)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                                </svg>
                                            </button>

                                            <svg class="w-12 h-12 text-cyan-400 opacity-0 group-hover:opacity-90 transition-opacity drop-shadow-lg" fill="currentColor" viewBox="0 0 20 20">
                                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z"/>
                                            </svg>
                                        </div>
                                    ` : `
                                        <div class="absolute inset-0 flex items-center justify-center bg-gray-900">
                                            <svg class="w-12 h-12 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                            <span class="absolute bottom-2 text-xs text-red-400">Missing URL</span>
                                        </div>
                                    `}
                                </div>
                                <div class="p-3 bg-[#131320]/80">
                                    <p class="text-xs font-medium text-gray-300 truncate mb-1" title="${promptDisplay}">${promptDisplay}</p>
                                    <div class="flex justify-between text-xs text-gray-500">
                                        <span class="truncate text-cyan-400" title="${modelDisplay}">${modelDisplay}</span>
                                        <span class="whitespace-nowrap ml-2 text-purple-400">${durationDisplay}‚Ä¢${resolutionDisplay}</span>
                                    </div>
                                </div>
                            </div>
                        `;
            }).join('')}
                </div>
            `;

            console.log('‚úÖ Video history rendered with', videoHistoryData.length, 'videos');

            // v2.8.0: Initialize touch handlers for mobile
            if (window.matchMedia('(max-width: 768px)').matches) {
                initHistoryTouchHandlers();
            }

            // ========== ‚ú® LOG: Render completion (Race Condition Fix) ==========
            console.log(`‚úÖ Render #${currentRenderingId} completed successfully`);
            // ========== END: Render Completion ==========
        }

        // --- Load Video with Authentication ---
        // --- Download Video from History ---
        async function downloadVideoFromHistory(index) {
            const video = videoHistoryData[index];
            if (!video) {
                console.error('downloadVideoFromHistory: Video not found at index', index);
                alert('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠');
                return;
            }

            console.log('üì• Downloading video from history:', {
                id: video.id,
                model: video.model,
                provider: video.provider
            });

            try {
                // Generate filename with model and timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const modelName = (video.model || 'unknown').replace(/[^a-zA-Z0-9-_]/g, '_');
                const filename = `vidist_${modelName}_${timestamp}.mp4`;

                let blob;

                // Get cached or fetch video
                const cachedUrl = await getCachedVideo(video.id);

                if (cachedUrl && cachedUrl.startsWith('blob:')) {
                    // Already have blob URL, fetch the blob from it
                    console.log('üì• Using cached blob URL');
                    const response = await fetch(cachedUrl);
                    blob = await response.blob();
                } else if (video.url) {
                    // Wavespeed: direct URL, fetch without auth
                    console.log('üì• Fetching Wavespeed video...');
                    const response = await fetch(video.url);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    blob = await response.blob();
                } else {
                    throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö URL ‡∏Ç‡∏≠‡∏á‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠');
                }

                // Verify we got a video blob
                if (!blob || !blob.type.startsWith('video/')) {
                    console.warn('‚ö†Ô∏è Blob type:', blob?.type);
                    // Continue anyway, might still work
                }

                // Create blob URL for download
                const downloadUrl = URL.createObjectURL(blob);

                // Force download using anchor with download attribute
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);

                // Trigger download
                a.click();

                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(downloadUrl);
                    console.log('‚úÖ Download completed:', filename);
                    console.log('üßπ Temporary blob URL revoked');
                }, 100);

            } catch (error) {
                console.error('‚ùå Error downloading video:', error);
                alert(`‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÑ‡∏î‡πâ: ${error.message}`);
            }
        }

        // --- Re-use Video Parameters Function ---
        function reuseVideoParameters(identifier) {
            // Support passing object directly or index
            let video;
            if (typeof identifier === 'object') {
                video = identifier;
            } else {
                video = videoHistoryData[identifier];
            }

            if (!video) {
                console.error('reuseVideoParameters: Video not found at index', index);
                return;
            }

            console.log('üîÑ Re-using prompts from video:', {
                id: video.id,
                prompt: video.prompt?.substring(0, 50) + '...'
            });

            // 1. Push current prompt to undo stack (if different)
            if (promptTextarea && promptTextarea.value !== video.prompt && video.prompt) {
                try {
                    if (promptCraftController && promptCraftController.state) {
                        promptCraftController.state.pushPromptUndo(promptTextarea.value);
                    }
                } catch (e) {
                    console.warn('Could not push to undo stack:', e);
                }
            }

            // 2. Load prompt
            if (video.prompt && promptTextarea) {
                promptTextarea.value = video.prompt;
                try {
                    localStorage.setItem(PROMPT_STORAGE_KEY, video.prompt);
                } catch (e) {
                    console.warn('Could not save prompt to localStorage:', e);
                }
            }

            // 3. Load negative prompt
            try {
                const negativePromptInput = document.getElementById('negative-prompt');
                if (negativePromptInput && video.negativePrompt !== undefined) {
                    negativePromptInput.value = video.negativePrompt || '';
                }
            } catch (e) {
                console.warn('Could not load negative prompt:', e);
            }

            // 4. Apply glow effect to prompt box (like after crafting)
            try {
                if (typeof window.markPromptAsFresh === 'function') {
                    window.markPromptAsFresh();
                }
            } catch (e) {
                console.warn('Could not apply glow effect:', e);
            }

            // 5. Restore Prompt Craft Data
            try {
                restoreCraftData(video.craftData);
            } catch (e) {
                console.warn('Could not restore craft data:', e);
            }

            // 6. Show success message
            try {
                statusText.textContent = `‚úÖ Prompt loaded from history - Ready to generate`;
                setTimeout(() => {
                    if (statusText.textContent.includes('Prompt loaded')) {
                        statusText.textContent = 'Ready to generate';
                    }
                }, 3000);
            } catch (e) {
                console.warn('Could not update status text:', e);
            }

            console.log('‚úÖ Parameters re-used successfully');
        }

        // ========== NEW: Restore Prompt Craft Data Function ==========
        /**
         * Restore ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Prompt Craft ‡∏à‡∏≤‡∏Å history item
         * @param {Object|null} craftData - CraftData object ‡∏à‡∏≤‡∏Å history
         */
        function restoreCraftData(craftData) {
            const craftInputElement = document.getElementById('prompt-craft-input');

            // Legacy history (‡πÑ‡∏°‡πà‡∏°‡∏µ craftData)
            if (!craftData) {
                console.log('‚ÑπÔ∏è Legacy history - no craft data');
                showCraftDataStatus('legacy');
                return;
            }

            // Manual Prompt
            if (craftData.isManualPrompt) {
                console.log('üìù Manual prompt');
                showCraftDataStatus('manual');
                if (craftInputElement) craftInputElement.value = '';
                return;
            }

            // Prompt Craft - Restore ‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á
            console.log('üé® Restoring Prompt Craft settings...');

            // 1. Craft Input
            if (craftInputElement && craftData.craftInput) {
                craftInputElement.value = craftData.craftInput;
                // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á localStorage ‡∏î‡πâ‡∏ß‡∏¢
                try {
                    localStorage.setItem('vidist_craft_input', craftData.craftInput);
                } catch (e) {
                    console.warn('Could not save craft input to localStorage:', e);
                }
                console.log('  ‚úì Craft input restored:', craftData.craftInput.substring(0, 50) + '...');
            }

            // 2. Red Mode
            if (craftData.redModeEnabled !== null) {
                localStorage.setItem('red_mode_enabled', craftData.redModeEnabled.toString());
                const redModeToggle = document.getElementById('red-mode-toggle');
                if (redModeToggle) {
                    redModeToggle.checked = craftData.redModeEnabled;
                    redModeToggle.dispatchEvent(new Event('change'));
                }
                console.log('  ‚úì Red mode restored:', craftData.redModeEnabled);
            }

            // 3. Intensity Level
            if (craftData.intensityLevel !== null) {
                localStorage.setItem('intensity_level', craftData.intensityLevel.toString());
                const intensityRadio = document.querySelector(
                    `input[name="intensity-level"][value="${craftData.intensityLevel}"]`
                );
                if (intensityRadio) intensityRadio.checked = true;
                console.log('  ‚úì Intensity level restored:', craftData.intensityLevel);
            }

            // 4. Language
            if (craftData.promptLanguage) {
                localStorage.setItem('prompt_language', craftData.promptLanguage);
                const langRadio = document.querySelector(
                    `input[name="prompt-language"][value="${craftData.promptLanguage}"]`
                );
                if (langRadio) langRadio.checked = true;
                console.log('  ‚úì Language restored:', craftData.promptLanguage);
            }

            // 5. Custom Dialog
            if (craftData.customDialogEnabled) {
                const dialogCheckbox = document.getElementById('custom-dialog-checkbox');
                const dialogInput = document.getElementById('custom-dialog-input');
                if (dialogCheckbox) {
                    dialogCheckbox.checked = true;
                    dialogCheckbox.dispatchEvent(new Event('change'));
                }
                if (dialogInput && craftData.customDialogText) {
                    dialogInput.value = craftData.customDialogText;
                }
                console.log('  ‚úì Custom dialog restored');
            }

            // 6. MUTE Audio State
            if (craftData.muteAudioEnabled) {
                const muteCheckbox = document.getElementById('mute-audio-checkbox');
                if (muteCheckbox) {
                    muteCheckbox.checked = true;
                    muteCheckbox.dispatchEvent(new Event('change'));
                    console.log('  ‚úì MUTE audio restored: enabled');
                }
            }

            // 6. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ promptWasCrafted = true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡∏°‡∏≤‡∏à‡∏≤‡∏Å craft
            promptWasCrafted = true;
            lastCraftedPrompt = document.getElementById('prompt')?.value || '';

            showCraftDataStatus('restored');
            console.log('‚úÖ All Prompt Craft settings restored');
        }

        /**
         * ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏Ç‡∏≠‡∏á prompt ‡πÉ‡∏ô statusText
         * @param {'manual'|'restored'|'legacy'} type
         */
        function showCraftDataStatus(type) {
            const messages = {
                manual: 'üìù Prompt ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ',
                restored: 'üé® Craft Settings Restored',
                legacy: '‚ÑπÔ∏è Legacy (‡πÑ‡∏°‡πà‡∏°‡∏µ craft data)'
            };

            const message = messages[type] || '';
            if (message && statusText) {
                const currentStatus = statusText.textContent;
                statusText.textContent = currentStatus + ' - ' + message;
            }
        }
        // ========== END: Restore Prompt Craft Data ==========

        // --- Clear Video Player Function ---
        // --- Load Video in Modal with Authentication ---
        let currentVideoFetchController = null; // AbortController for canceling fetch

        async function loadVideoInModal(videoUrl, provider, videoId) {
            console.log('üé¨ Loading video in modal:', { url: videoUrl, provider, videoId });

            // üîß v2.12.13: Removed new tab workaround - Grok now plays in modal!
            // Key: Don't set crossOrigin for Grok (opaque CORS mode allows playback)

            const loadingOverlay = document.getElementById('video-loading-overlay');
            const videoPlayer = modalVideoPlayer;

            // Cancel previous fetch if still ongoing
            if (currentVideoFetchController) {
                currentVideoFetchController.abort();
                console.log('‚ö†Ô∏è Cancelled previous video fetch');
            }

            // Create new AbortController for this fetch
            currentVideoFetchController = new AbortController();

            // Show loading overlay
            loadingOverlay.style.display = 'flex';
            videoPlayer.style.opacity = '0';
            videoPlayer.style.transition = 'opacity 0.3s ease-in-out';

            try {
                // Load video directly from server
                // v2.12.13: Pass provider so setupVideoLoading can skip crossOrigin for Grok
                console.log('üåê Loading video directly from server');
                await setupVideoLoading(videoPlayer, loadingOverlay, videoUrl, provider);
                console.log('‚úÖ Video loaded and ready');

            } catch (error) {
                // Ignore AbortError - happens when user closes modal during load
                if (error.name === 'AbortError') {
                    console.log('‚ÑπÔ∏è Video fetch cancelled (modal closed)');
                    return;
                }

                console.error('‚ùå Error loading video in modal:', error);
                console.log('üí° Tip: If video does not load, close and retry');

                // Throw error so openVideoModal() knows loading failed
                throw error;
            }
        }

        // Helper function to setup video loading and wait for ready
        // v2.12.13: Added provider parameter to skip crossOrigin for Grok
        function setupVideoLoading(videoPlayer, loadingOverlay, videoSrc, provider = 'wavespeed') {
            return new Promise((resolve, reject) => {
                // Setup event listeners BEFORE setting src to avoid race conditions

                let timeoutId;

                // Success: Video is ready to play
                const onCanPlay = function () {
                    cleanup();
                    loadingOverlay.style.display = 'none';
                    videoPlayer.style.opacity = '1';
                    console.log('‚úÖ Video ready to play');
                    resolve();
                };

                // Error: Video failed to load
                const onError = function (e) {
                    cleanup();
                    const errorCode = videoPlayer.error?.code || 'unknown';
                    const errorMessage = getVideoErrorMessage(errorCode);
                    console.error('‚ùå Video error:', {
                        code: errorCode,
                        message: errorMessage,
                        src: videoSrc.substring(0, 100) + '...',
                        error: e
                    });
                    console.log('üí° Tip: If video does not load, close and retry');
                    reject(new Error(`Video failed to load (code: ${errorCode})`));
                };

                // Cleanup function to remove listeners
                const cleanup = () => {
                    videoPlayer.removeEventListener('canplay', onCanPlay);
                    videoPlayer.removeEventListener('error', onError);
                    if (timeoutId) clearTimeout(timeoutId);
                };

                // Attach event listeners FIRST
                // Use 'canplaythrough' instead of 'canplay' for better buffering
                videoPlayer.addEventListener('canplaythrough', onCanPlay, { once: true });
                videoPlayer.addEventListener('error', onError, { once: true });

                // Timeout: Safety net for slow networks (30 seconds for canplaythrough)
                timeoutId = setTimeout(() => {
                    cleanup();
                    reject(new Error('Video loading timeout after 30s'));
                }, 30000);

                // NOW set the src AFTER listeners are attached
                console.log('üé¨ Setting video src:', videoSrc.substring(0, 100) + '...');

                // üîß v2.12.13 FIX: Only set crossOrigin for providers with CORS headers
                // Grok videos DON'T have CORS headers - setting crossOrigin forces CORS check and fails
                // Without crossOrigin, browser uses "opaque" mode which allows playback!
                if (provider !== 'grok') {
                    videoPlayer.crossOrigin = "anonymous";
                    console.log('üîí crossOrigin set for', provider);
                } else {
                    // Remove any existing crossOrigin attribute for Grok
                    videoPlayer.removeAttribute('crossorigin');
                    console.log('üîì crossOrigin skipped for Grok (opaque CORS mode)');
                }

                videoPlayer.src = videoSrc;
                videoPlayer.load(); // Explicitly trigger load
            });
        }

        // Helper function to get human-readable error message
        function getVideoErrorMessage(code) {
            const errors = {
                1: 'MEDIA_ERR_ABORTED - Video loading was aborted',
                2: 'MEDIA_ERR_NETWORK - Network error while loading video',
                3: 'MEDIA_ERR_DECODE - Video decoding failed',
                4: 'MEDIA_ERR_SRC_NOT_SUPPORTED - Video format not supported or URL invalid'
            };
            return errors[code] || 'Unknown error';
        }

        // Helper function to show error overlay
        function showErrorOverlay(overlay, message) {
            overlay.innerHTML = `
                <div class="text-center">
                    <!-- Error Icon -->
                    <div class="relative w-24 h-24 mx-auto mb-6">
                        <div class="absolute inset-0 border-4 border-red-500/30 rounded-full"></div>
                        <svg class="w-24 h-24 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </div>
                    <!-- Error Text -->
                    <p class="text-red-400 font-bold text-xl mb-2 neon-text tracking-wider uppercase">Error</p>
                    <p class="text-gray-400 text-sm">${message}</p>
                    <button onclick="document.getElementById('video-modal').classList.add('hidden')"
                            class="mt-4 px-6 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-500/50 rounded-lg text-red-400 transition-all">
                        Close
                    </button>
                </div>
            `;
            overlay.style.display = 'flex';
        }

        // --- Video Modal ---
        // v2.8.0: Safe wrapper for mobile two-tap interaction
        function openVideoModalSafe(index) {
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (isMobile) {
                const card = document.querySelector(`.video-thumbnail[data-index="${index}"], .image-thumbnail[data-index="${index}"]`);
                if (card && !card.classList.contains('touch-active')) {
                    return; // First tap, don't open modal
                }
            }
            // Desktop or second tap: open modal
            openVideoModal(index);
        }

        async function openVideoModal(index) {
            // Use completedVideosData instead of videoHistoryData to avoid index mismatch
            const video = completedVideosData[index];
            if (!video) {
                console.error('openVideoModal: Video not found at index', index, 'in completedVideosData');
                console.error('Available videos:', completedVideosData.length);
                return;
            }

            console.log('Opening video modal for index:', index, '(from completedVideosData)');
            console.log('Video data:', {
                id: video.id,
                model: video.model,
                duration: video.duration,
                resolution: video.resolution,
                provider: video.provider,
                prompt: video.prompt?.substring(0, 50) + '...'
            });

            // ‡πÅ‡∏™‡∏î‡∏á Modal ‡∏Å‡πà‡∏≠‡∏ô (‡πÉ‡∏´‡πâ user ‡πÄ‡∏´‡πá‡∏ô loading state)
            videoModal.classList.remove('hidden');
            videoModal.classList.add('flex');

            // Update modal info
            modalVideoInfo.innerHTML = `
                <strong>Prompt:</strong> ${video.prompt || 'N/A'}<br>
                <strong>Provider:</strong> ${video.provider?.toUpperCase() || 'N/A'} | <strong>Model:</strong> ${video.model || 'N/A'}<br>
                <strong>Duration:</strong> ${video.duration || '?'}s | <strong>Resolution:</strong> ${video.resolution || 'N/A'}<br>
                <strong>Created:</strong> ${video.createdAt ? new Date(video.createdAt).toLocaleString('th-TH') : 'N/A'} | <strong>Processing Time:</strong> ${video.processingTime || '?'}s <br>
                <strong>ID:</strong> <span class="font-mono text-xs">${video.id || 'N/A'}</span>
            `;

            try {
                // Wait for video to load and be ready to play
                await loadVideoInModal(video.url, video.provider, video.id);

                // Initialize click/tap toggle for play/pause (especially for mobile)
                initVideoPlayerClickToggle();

                // Play video when ready
                await modalVideoPlayer.play();
                console.log('‚úÖ Video is playing');

            } catch (error) {
                // Handle auto-play blocking (browser policy)
                if (error.name === 'NotAllowedError') {
                    console.warn("‚ö†Ô∏è Video auto-play was blocked by browser. User needs to click play.");
                    // User can manually click play button - no action needed
                } else {
                    console.error('‚ùå Error in openVideoModal:', error);
                    // Video is ready but couldn't auto-play - user can still manually play
                }
            }
        }

        // ========== Video Player Tap/Click Toggle (Mobile) ==========
        function initVideoPlayerClickToggle() {
            const videoPlayer = document.getElementById('modal-video-player');
            if (!videoPlayer) return;

            // Remove existing listener if any
            videoPlayer.removeEventListener('click', toggleVideoPlayPause);

            // Add click/tap handler to toggle play/pause
            videoPlayer.addEventListener('click', toggleVideoPlayPause);
        }

        function toggleVideoPlayPause(e) {
            const videoPlayer = e.target;

            // Don't interfere with control bar clicks
            // Only toggle if clicking the video area itself
            if (videoPlayer.paused) {
                videoPlayer.play().catch(err => {
                    console.warn('Cannot play video:', err);
                });
            } else {
                videoPlayer.pause();
            }
        }

        function closeVideoModal() {
            videoModal.classList.add('hidden');
            videoModal.classList.remove('flex');

            // Cancel ongoing video fetch if any
            if (currentVideoFetchController) {
                currentVideoFetchController.abort();
                currentVideoFetchController = null;
                console.log('üõë Video fetch cancelled (modal closed)');
            }

            // **‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:** ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏•‡πà‡∏ô‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÅ‡∏•‡∏∞‡∏•‡πâ‡∏≤‡∏á source ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î
            modalVideoPlayer.pause();
            modalVideoPlayer.src = "";
        }

        function closeVideoModalOnBackdrop(event) {
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏µ‡∏î‡∏≥ (videoModal) ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ï‡∏±‡∏ß‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠
            if (event.target === videoModal) {
                closeVideoModal();
            }
        }


        // --- Image Modal Functions ---
        function openImageModal(imageSrc) {
            if (!imageSrc || imageSrc === '#' || imageSrc === '') {
                console.warn('openImageModal: Invalid image source');
                return;
            }
            modalImageFull.src = imageSrc;
            imageModal.classList.remove('hidden');
            imageModal.classList.add('flex');

            // ‚ú® NEW: Update modal navigation UI
            updateModalNavigationUI();

            console.log('Image modal opened:', imageSrc.substring(0, 50) + '...');
        }

        function closeImageModalFunction() {
            imageModal.classList.add('hidden');
            imageModal.classList.remove('flex');
            // Don't clear src - keep for reopening
            console.log('Image modal closed');
        }

        function closeImageModalOnBackdrop(event) {
            // Close if clicking on backdrop (not the card inside)
            if (event.target === imageModal) {
                closeImageModalFunction();
            }
        }

        // ‚ú® NEW: Modal Image Navigation
        function navigateModalImage(direction) {
            if (typeof window.imageEditHistory === 'undefined') {
                console.warn('Image edit history not available');
                return;
            }

            // Navigate history
            window.imageEditHistory.navigate(direction);

            // Update modal image to current history position
            if (window.imageBase64Data) {
                modalImageFull.src = window.imageBase64Data;
            }

            // Update navigation UI
            updateModalNavigationUI();

            console.log('üîÑ Modal navigation:', direction > 0 ? 'next' : 'prev');
        }

        function updateModalNavigationUI() {
            const prevBtn = document.getElementById('modal-prev-btn');
            const nextBtn = document.getElementById('modal-next-btn');
            const counterText = document.getElementById('modal-history-text');
            const counterDiv = document.getElementById('modal-history-counter');

            if (!prevBtn || !nextBtn || !counterText || !counterDiv) return;

            // Get history state
            if (typeof window.imageEditHistory === 'undefined') {
                // No history system - hide navigation
                prevBtn.classList.add('hidden');
                nextBtn.classList.add('hidden');
                counterDiv.classList.add('hidden');
                return;
            }

            const historyState = window.imageEditHistory.getState();
            if (!historyState || historyState.length === 0) {
                // No images in history - hide navigation
                prevBtn.classList.add('hidden');
                nextBtn.classList.add('hidden');
                counterDiv.classList.add('hidden');
                return;
            }

            // Show navigation elements
            prevBtn.classList.remove('hidden');
            nextBtn.classList.remove('hidden');
            counterDiv.classList.remove('hidden');

            // Get current index (need to expose this from image_edit_history.js)
            const currentIndex = window.imageEditHistory.getCurrentIndex ?
                window.imageEditHistory.getCurrentIndex() : 0;

            // Update button states
            prevBtn.disabled = currentIndex <= 0;
            nextBtn.disabled = currentIndex >= historyState.length - 1;

            // Update counter text
            const position = currentIndex + 1;
            counterText.textContent = `${position}/${historyState.length}`;
        }

        // --- Initialize App on DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', initializeApp);

        // ========== Red Mode Toggle Class ==========
        class RedModeToggle {
            constructor(containerId, onChange = null) {
                this.container = document.getElementById(containerId);
                if (!this.container) {
                    console.error('‚ùå Red Mode Toggle container not found:', containerId);
                    return;
                }

                this.track = this.container.querySelector('.red-mode-toggle-track');
                this.thumb = this.container.querySelector('.red-mode-toggle-thumb');
                this.glow = this.container.querySelector('.red-mode-toggle-glow');
                this.onChange = onChange;

                // State
                this.isRedMode = false;
                this.isDragging = false;
                this.holdTimer = null;
                this.startY = 0;
                this.currentY = 0;

                // Constants
                this.HOLD_DELAY = 200;      // ms to wait before drag can start
                this.DRAG_THRESHOLD = 15;   // px to drag to toggle

                this.init();
            }

            init() {
                // Load saved state from localStorage
                const savedState = localStorage.getItem('red_mode_enabled');
                if (savedState === 'true') {
                    this.isRedMode = true;
                    this.container.classList.add('red-mode-active');
                }

                // Setup event listeners (desktop-friendly)
                this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));

                // Touch support (bonus)
                this.container.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this));

                console.log('üé® Red Mode Toggle initialized:', this.isRedMode ? 'RED MODE' : 'CREATIVE MODE');
            }

            handleMouseDown(e) {
                e.preventDefault();
                this.startHold(e.clientY);
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                this.startHold(touch.clientY);
            }

            startHold(clientY) {
                this.startY = clientY;
                this.currentY = clientY;

                // Start hold timer
                this.holdTimer = setTimeout(() => {
                    this.isDragging = true;
                    this.container.classList.add('dragging');
                    console.log('üé® Drag mode activated (held for 200ms)');
                }, this.HOLD_DELAY);
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                this.updateDrag(e.clientY);
            }

            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.updateDrag(touch.clientY);
            }

            updateDrag(clientY) {
                this.currentY = clientY;
                const deltaY = this.startY - this.currentY;

                // Calculate thumb position (constrained to track)
                const thumbPosition = Math.max(2, Math.min(20, -deltaY + 2));
                this.thumb.style.top = `${thumbPosition}px`;

                // Visual feedback based on drag direction
                if (deltaY > this.DRAG_THRESHOLD) {
                    // Dragging UP ‚Üí Red Mode
                    this.container.classList.add('red-mode-active');
                } else if (deltaY < -this.DRAG_THRESHOLD) {
                    // Dragging DOWN ‚Üí Creative Mode
                    this.container.classList.remove('red-mode-active');
                }
            }

            handleMouseUp(e) {
                this.endDrag();
            }

            handleTouchEnd(e) {
                this.endDrag();
            }

            endDrag() {
                // Clear hold timer if not yet dragging
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }

                // If was dragging, process the toggle
                if (this.isDragging) {
                    const deltaY = this.startY - this.currentY;

                    // Determine new state based on drag distance
                    let newState = this.isRedMode;

                    if (deltaY > this.DRAG_THRESHOLD) {
                        newState = true;  // Red Mode
                    } else if (deltaY < -this.DRAG_THRESHOLD) {
                        newState = false; // Creative Mode
                    }

                    // Apply state change
                    if (newState !== this.isRedMode) {
                        this.setRedMode(newState);
                    } else {
                        // Snap back to current position
                        this.resetThumbPosition();
                    }

                    this.isDragging = false;
                    this.container.classList.remove('dragging');
                }

                // Reset thumb position (with animation)
                this.thumb.style.top = '';
            }

            setRedMode(enabled) {
                this.isRedMode = enabled;

                // Update visual state
                if (enabled) {
                    this.container.classList.add('red-mode-active');
                } else {
                    this.container.classList.remove('red-mode-active');
                }

                // Save to localStorage
                localStorage.setItem('red_mode_enabled', enabled.toString());

                // Trigger callback
                if (this.onChange) {
                    this.onChange(enabled);
                }

                console.log('üé® Red Mode toggled:', enabled ? 'ENABLED (NSFW)' : 'DISABLED (Creative)');
            }

            resetThumbPosition() {
                this.thumb.style.top = '';
            }

            isEnabled() {
                return this.isRedMode;
            }
        }




        // --- Copy Prompt Function ---
        function copyPromptToClipboard() {
            const promptText = promptTextarea ? promptTextarea.value : '';
            if (!promptText) return;

            navigator.clipboard.writeText(promptText).then(() => {
                const btn = document.getElementById('copy-prompt-btn');
                if (!btn) return;

                // Store original content if not already stored
                if (!btn.dataset.originalContent) {
                    btn.dataset.originalContent = btn.innerHTML;
                }

                // Visual feedback
                btn.innerHTML = `<svg class="w-4 h-4 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg><span class="text-green-400">Copied!</span>`;
                btn.classList.add('border-green-500/50', 'bg-green-500/10');

                // Mark prompt as copied (dim the text)
                localStorage.setItem('vidist_prompt_copied_state', 'true');
                if (typeof applyPromptCopiedState === 'function') {
                    applyPromptCopiedState();
                }

                setTimeout(() => {
                    btn.innerHTML = btn.dataset.originalContent;
                    btn.classList.remove('border-green-500/50', 'bg-green-500/10');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback for older browsers if needed, or just log error
            });
        }

        // ========== Prompt Craft Initialization ==========
        // Initialize Prompt Craft controller (using external prompt_craft.js module)
        let promptCraftController = null;

        function initPromptCraft() {
            // Wait for prompt_craft.js to load
            if (typeof window.PromptCraft === 'undefined') {
                console.warn('‚ö†Ô∏è Prompt Craft module not loaded yet, retrying...');
                setTimeout(initPromptCraft, 100);
                return;
            }

            // Get DOM elements at the beginning to avoid hoisting issues
            const promptTextarea = document.getElementById('prompt');

            // ========== NEW: Set up callback for Craft success notification ==========
            window.promptCraftCallback = {
                onCraftSuccess: function (craftedPrompt) {
                    lastCraftedPrompt = craftedPrompt;
                    promptWasCrafted = true;
                    promptWasManuallyEdited = false;
                    console.log('‚úÖ Prompt was crafted, validation flag set');
                }
            };
            // ========== END: Craft callback ==========

            // Create controller instance
            promptCraftController = new window.PromptCraft.Controller();

            // Initialize with DOM elements
            promptCraftController.init({
                // Input fields
                descriptionInput: promptCraftInput,
                promptTextarea: promptTextarea,
                negativePromptTextarea: document.getElementById('negative-prompt'),
                apiKeyInput: geminiApiKeyInput,

                // Buttons
                generateBtn: promptCraftBtn,
                clearCraftBtn: document.getElementById('clear-craft-input-btn'),

                // UI elements
                spinner: promptCraftSpinner,
                statusText: statusText,
                apiKeySection: apiKeySection,
                apiKeyChevron: apiKeyChevron,

                // Data getters
                getImageData: () => imageBase64Data
            });

            // Load Gemini API toggle state
            const geminiEnabled = localStorage.getItem('gemini_api_enabled');
            toggleGeminiApi.checked = geminiEnabled !== 'false';

            // Initialize Red Mode Toggle
            const redModeToggle = new RedModeToggle('red-mode-toggle-container', (enabled) => {
                // Callback: Update controller state when toggle changes
                if (promptCraftController && typeof promptCraftController.onRedModeChange === 'function') {
                    promptCraftController.onRedModeChange(enabled);
                }

                // ========== NEW: Show/Hide Intensity Level Selector ==========
                const intensitySelector = document.getElementById('intensity-level-selector');
                if (intensitySelector) {
                    if (enabled) {
                        // Red Mode ON ‚Üí Show selector
                        intensitySelector.classList.remove('hidden');
                        console.log('üéöÔ∏è Intensity Level Selector shown');
                    } else {
                        // Creative Mode ON ‚Üí Hide selector
                        intensitySelector.classList.add('hidden');
                        console.log('üéöÔ∏è Intensity Level Selector hidden');
                    }
                }

                // ========== NEW: Show/Hide Custom Dialog Container ==========
                const customDialogContainer = document.getElementById('custom-dialog-container');
                if (customDialogContainer) {
                    if (enabled) {
                        // Red Mode ON ‚Üí Show custom dialog override
                        customDialogContainer.classList.remove('hidden');
                        console.log('‚óé Custom Dialog Override shown');
                    } else {
                        // Creative Mode ON ‚Üí Hide custom dialog override
                        customDialogContainer.classList.add('hidden');
                        console.log('‚óé Custom Dialog Override hidden');
                    }
                }

                // ========== NEW: Show/Hide MUTE Audio Container ==========
                const muteAudioContainer = document.getElementById('mute-audio-container');
                if (muteAudioContainer) {
                    if (enabled) {
                        // Red Mode ON ‚Üí Show MUTE audio checkbox
                        muteAudioContainer.classList.remove('hidden');
                        console.log('üîá MUTE Audio container shown');
                    } else {
                        // Creative Mode ON ‚Üí Hide MUTE audio checkbox
                        muteAudioContainer.classList.add('hidden');
                        console.log('üîá MUTE Audio container hidden');
                    }
                }

                // ========== UPDATE: Show/Hide Step Complexity Selector ==========
                updateStepComplexityVisibility();
            });

            // ========== NEW: Load initial Red Mode state and show/hide selector ==========
            const savedRedMode = localStorage.getItem('red_mode_enabled');
            const isRedModeEnabled = savedRedMode === 'true';
            const intensitySelector = document.getElementById('intensity-level-selector');
            if (intensitySelector && isRedModeEnabled) {
                intensitySelector.classList.remove('hidden');
                console.log('üéöÔ∏è Intensity Level Selector shown (Red Mode active on load)');
            }

            // ========== NEW: Load initial Red Mode state and show/hide custom dialog container ==========
            const customDialogContainer = document.getElementById('custom-dialog-container');
            if (customDialogContainer && isRedModeEnabled) {
                customDialogContainer.classList.remove('hidden');
                console.log('‚óé Custom Dialog Override shown (Red Mode active on load)');
            }

            // ========== NEW: Load initial Red Mode state and show/hide MUTE audio container ==========
            const muteAudioContainer = document.getElementById('mute-audio-container');
            if (muteAudioContainer && isRedModeEnabled) {
                muteAudioContainer.classList.remove('hidden');
                console.log('üîá MUTE Audio container shown (Red Mode active on load)');
            }

            // ========== NEW: Custom Dialog Checkbox Toggle ==========
            const customDialogCheckbox = document.getElementById('custom-dialog-checkbox');
            const customDialogInputContainer = document.getElementById('custom-dialog-input-container');

            if (customDialogCheckbox && customDialogInputContainer) {
                customDialogCheckbox.addEventListener('change', (e) => {
                    // Save to localStorage
                    localStorage.setItem('vidist_dialog_override_enabled', e.target.checked.toString());

                    if (e.target.checked) {
                        customDialogInputContainer.classList.remove('hidden');
                        console.log('‚óé Custom Dialog input shown');
                    } else {
                        customDialogInputContainer.classList.add('hidden');
                        console.log('‚óé Custom Dialog input hidden');
                    }
                });
            }

            // ========== Custom Dialog Persistence ==========
            const DIALOG_CHECKBOX_KEY = 'vidist_dialog_override_enabled';
            const DIALOG_INPUT_KEY = 'vidist_dialog_override_text';

            // Load saved state on page load
            function loadDialogOverrideState() {
                const customDialogCheckbox = document.getElementById('custom-dialog-checkbox');
                const customDialogInput = document.getElementById('custom-dialog-input');
                const customDialogInputContainer = document.getElementById('custom-dialog-input-container');

                if (!customDialogCheckbox || !customDialogInput || !customDialogInputContainer) return;

                // Load checkbox state
                const savedCheckboxState = localStorage.getItem(DIALOG_CHECKBOX_KEY);
                if (savedCheckboxState === 'true') {
                    customDialogCheckbox.checked = true;
                    customDialogInputContainer.classList.remove('hidden');
                    console.log('‚óé Restored Dialog Override checkbox state: enabled');
                }

                // Load input value
                const savedInputValue = localStorage.getItem(DIALOG_INPUT_KEY);
                if (savedInputValue) {
                    customDialogInput.value = savedInputValue;
                    console.log('‚óé Restored Dialog Override text');
                }
            }

            // Save input value when changed (debounced)
            const customDialogInput = document.getElementById('custom-dialog-input');
            if (customDialogInput) {
                let dialogSaveTimeout;
                customDialogInput.addEventListener('input', (e) => {
                    clearTimeout(dialogSaveTimeout);
                    dialogSaveTimeout = setTimeout(() => {
                        localStorage.setItem(DIALOG_INPUT_KEY, e.target.value);
                        console.log('‚óé Saved Dialog Override text');
                    }, 500); // Debounce 500ms
                });
            }

            // Load state on page load
            loadDialogOverrideState();

            // ========== MUTE Audio Feature ==========
            const MUTE_CHECKBOX_KEY = 'vidist_mute_audio_enabled';

            // 1. Load saved MUTE state
            function loadMuteAudioState() {
                const muteAudioCheckbox = document.getElementById('mute-audio-checkbox');
                const savedMuteState = localStorage.getItem(MUTE_CHECKBOX_KEY);
                if (savedMuteState === 'true' && muteAudioCheckbox) {
                    muteAudioCheckbox.checked = true;
                    // Auto-disable SPEECH checkbox
                    disableSpeechCheckbox();
                    console.log('üîá Restored MUTE state: enabled');
                }
            }

            // 2. Disable SPEECH checkbox when MUTE is ON
            function disableSpeechCheckbox() {
                const customDialogCheckbox = document.getElementById('custom-dialog-checkbox');
                const customDialogInputContainer = document.getElementById('custom-dialog-input-container');
                if (customDialogCheckbox) {
                    customDialogCheckbox.disabled = true;
                    customDialogCheckbox.checked = false; // Uncheck it
                    customDialogCheckbox.classList.add('opacity-50', 'cursor-not-allowed');
                    // Save unchecked state
                    localStorage.setItem('vidist_dialog_override_enabled', 'false');
                    // Hide the input field too
                    if (customDialogInputContainer) {
                        customDialogInputContainer.classList.add('hidden');
                    }
                    console.log('üîá SPEECH disabled due to MUTE');
                }
            }

            // 3. Enable SPEECH checkbox when MUTE is OFF
            function enableSpeechCheckbox() {
                const customDialogCheckbox = document.getElementById('custom-dialog-checkbox');
                if (customDialogCheckbox) {
                    customDialogCheckbox.disabled = false;
                    customDialogCheckbox.classList.remove('opacity-50', 'cursor-not-allowed');
                    console.log('üîä SPEECH enabled (MUTE off)');
                }
            }

            // 4. MUTE checkbox change event
            const muteAudioCheckbox = document.getElementById('mute-audio-checkbox');
            if (muteAudioCheckbox) {
                muteAudioCheckbox.addEventListener('change', function() {
                    const isMuted = this.checked;

                    // Save state
                    localStorage.setItem(MUTE_CHECKBOX_KEY, isMuted);

                    // Disable/Enable SPEECH checkbox
                    if (isMuted) {
                        disableSpeechCheckbox();
                        console.log('üîá MUTE enabled - All audio removed from prompts');
                    } else {
                        enableSpeechCheckbox();
                        console.log('üîä MUTE disabled - Audio can be generated');
                    }
                });
            }

            // 5. Load state on page load
            loadMuteAudioState();

            // ========== Language Selector Event Listeners ==========
            const languageRadios = document.querySelectorAll('input[name="prompt-language"]');
            if (languageRadios.length > 0 && promptCraftController) {
                languageRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        const language = e.target.value;

                        // Update state
                        if (promptCraftController && promptCraftController.state) {
                            promptCraftController.state.setLanguage(language);
                        }

                        // Visual feedback
                        const languageNames = {
                            'en': 'English',
                            'th': '‡πÑ‡∏ó‡∏¢',
                            'ja': 'Êó•Êú¨Ë™û'
                        };
                        console.log(`üåê Language changed to: ${languageNames[language]}`);
                    });
                });

                // Load saved language on page load
                const savedLanguage = localStorage.getItem('prompt_language') || 'en';
                const savedRadio = document.querySelector(`input[name="prompt-language"][value="${savedLanguage}"]`);
                if (savedRadio) {
                    savedRadio.checked = true;
                    console.log(`üåê Language loaded: ${savedLanguage.toUpperCase()}`);
                }
            }

            // ========== Prompt Copy State Management ==========
            const PROMPT_COPIED_KEY = 'vidist_prompt_copied_state';

            // Apply copied state (dimmed) to textarea
            function applyPromptCopiedState() {
                const promptTextarea = document.getElementById('prompt');
                if (!promptTextarea) return;

                const copiedState = localStorage.getItem(PROMPT_COPIED_KEY);
                if (copiedState === 'true') {
                    promptTextarea.classList.add('prompt-copied');
                } else {
                    promptTextarea.classList.remove('prompt-copied');
                }
            }

            // Mark prompt as fresh (not copied)
            function markPromptAsFresh() {
                localStorage.setItem(PROMPT_COPIED_KEY, 'false');
                applyPromptCopiedState();

                // Apply shimmer animation
                const promptTextarea = document.getElementById('prompt');
                if (promptTextarea) {
                    promptTextarea.classList.remove('prompt-just-generated');
                    // Force reflow to restart animation
                    void promptTextarea.offsetWidth;
                    promptTextarea.classList.add('prompt-just-generated');

                    // Remove animation class after completion (2s)
                    setTimeout(() => {
                        promptTextarea.classList.remove('prompt-just-generated');
                    }, 2000);
                }
            }

            // Expose functions globally for use by prompt_craft.js
            window.applyPromptCopiedState = applyPromptCopiedState;
            window.markPromptAsFresh = markPromptAsFresh;

            // Load state on page load
            applyPromptCopiedState();

            // Reset copied state when user manually edits prompt
            if (promptTextarea) {
                promptTextarea.addEventListener('input', () => {
                    // Reset copied state when user edits
                    localStorage.setItem(PROMPT_COPIED_KEY, 'false');
                    applyPromptCopiedState();
                });
            }

            console.log('‚úÖ Prompt Craft initialized using external module');
            console.log('‚úÖ Red Mode Toggle connected to Prompt Craft controller');
        }

        // ========== End Prompt Craft Initialization ==========

        // ========== ‚ú® NEW: History Image Modal (v2.4.2) ==========
        // NOTE: This is for HISTORY panel cards. Preview panel uses openImageModal() at line ~7734

        // v2.8.0: Safe wrapper for mobile two-tap interaction
        function openHistoryImageModalSafe(imageUrl, imageIndex) {
            const isMobile = window.matchMedia('(max-width: 768px)').matches;
            if (isMobile) {
                const card = document.querySelector(`.image-thumbnail[data-index="${imageIndex}"]`);
                if (card && !card.classList.contains('touch-active')) {
                    return; // First tap, don't open modal
                }
            }
            // Desktop or second tap: open modal
            openHistoryImageModal(imageUrl, imageIndex);
        }

        // Open history image in full-screen modal
        function openHistoryImageModal(imageUrl, imageIndex) {
            console.log('üñºÔ∏è Opening history image modal:', imageUrl);

            // Create modal if not exists (use different ID to avoid conflict)
            let modal = document.getElementById('history-image-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'history-image-modal';
                // Increase z-index to 9999 to ensure it stays on top of everything
                modal.className = 'fixed inset-0 z-[9999] bg-black/95 hidden flex items-center justify-center backdrop-blur-sm';
                modal.innerHTML = `
                    <div class="relative w-full h-full p-4 flex items-center justify-center" onclick="closeHistoryImageModal()">
                        <img id="history-modal-image-display" src="" alt="Edited image"
                             class="max-w-full max-h-full object-contain shadow-2xl drop-shadow-2xl"
                             onclick="event.stopPropagation()">
                        <button onclick="closeHistoryImageModal()"
                                class="absolute top-6 right-6 text-white bg-red-600/80 hover:bg-red-600 rounded-lg px-4 py-2 text-sm font-semibold z-50 transition-all hover:scale-105">
                            ‚úï Close
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            // Set image source and show modal
            const img = modal.querySelector('#history-modal-image-display');
            if (img) img.src = imageUrl;
            modal.classList.remove('hidden');
        }

        // Close history image modal
        function closeHistoryImageModal() {
            const modal = document.getElementById('history-image-modal');
            if (modal) {
                modal.classList.add('hidden');
                const img = modal.querySelector('#history-modal-image-display');
                if (img) img.src = '';
            }
        }

        // Download image function
        async function downloadImage(imageUrl, imageId, imageCounter) {
            try {
                console.log('üì• Downloading image:', imageId, 'Counter:', imageCounter);
                const response = await fetch(imageUrl);
                const blob = await response.blob();

                // Generate filename using counter if available, otherwise simplified ID
                // Use .png to match saveEditedImage format
                const filename = imageCounter
                    ? `wan26edit_${String(imageCounter).padStart(3, '0')}.png`
                    : `wan26edit_${imageId.substring(0, 8)}.png`;

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('‚úÖ Image downloaded:', filename);
            } catch (error) {
                console.error('‚ùå Failed to download image:', error);
                alert('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ\n\nFailed to download image.');
            }
        }

        // NOTE: Reuse function not needed - using existing reuseVideoParameters(index) instead
        // It already handles: prompt, negative prompt, model, craft data restoration, etc.

        // Expose functions globally
        window.openImageModal = openImageModal; // Preview modal
        window.closeImageModalFunction = closeImageModalFunction; // Preview modal close
        window.openHistoryImageModal = openHistoryImageModal; // History modal
        window.closeHistoryImageModal = closeHistoryImageModal; // History modal close
        window.downloadImage = downloadImage;
        window.updateModalNavigationUI = updateModalNavigationUI; // ‚ú® NEW: Modal navigation UI update
        // window.reuseImageParameters removed - use reuseVideoParameters(index) instead

        console.log('‚úÖ Image modal and helper functions initialized');

        // ========== END: Image Modal and Helper Functions ==========


    </script>

    <!-- Image Edit History Module -->
    <script src="js/image_edit_history.js"></script>

    <!-- Prompt Craft Module (External) -->
    <script src="js/prompt_craft.js"></script>

</body>

</html>